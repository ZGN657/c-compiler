349
0 57
declaration -> declaration_specifiers ; 	0
$ 
direct_declarator -> direct_declarator ( ) 	0
{ SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC TYPEDEF CONST UNION EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ 
pointer -> * 	0
IDENTIFIER ( 
argumented_translation_unit -> translation_unit 	0
$ 
type_specifier -> INT 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
translation_unit -> external_declaration 	0
STATIC LONG $ INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT FLOAT STRUCT REGISTER UNION CONST CHAR * UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID ENUM 
function_definition -> declarator compound_statement 	0
$ 
storage_class_specifier -> REGISTER 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
declaration -> declaration_specifiers init_declarator_list ; 	0
$ 
struct_or_union -> STRUCT 	0
{ IDENTIFIER 
translation_unit -> translation_unit external_declaration 	0
STATIC LONG $ INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT FLOAT STRUCT REGISTER UNION CONST CHAR * UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID ENUM 
declarator -> direct_declarator 	0
{ VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM 
external_declaration -> function_definition 	0
$ 
external_declaration -> declaration 	0
$ 
function_definition -> declaration_specifiers declarator declaration_list compound_statement 	0
$ 
function_definition -> declaration_specifiers declarator compound_statement 	0
$ 
function_definition -> declarator declaration_list compound_statement 	0
$ 
direct_declarator -> direct_declarator ( identifier_list ) 	0
{ SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC TYPEDEF CONST UNION EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ 
declaration_specifiers -> type_specifier declaration_specifiers 	0
IDENTIFIER * ( ; 
declaration_specifiers -> type_specifier 	0
IDENTIFIER * ( ; 
type_specifier -> struct_or_union_specifier 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
declaration_specifiers -> storage_class_specifier 	0
IDENTIFIER * ( ; 
declaration_specifiers -> storage_class_specifier declaration_specifiers 	0
IDENTIFIER * ( ; 
type_specifier -> SIGNED 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
declaration_specifiers -> type_qualifier 	0
IDENTIFIER * ( ; 
declaration_specifiers -> type_qualifier declaration_specifiers 	0
IDENTIFIER * ( ; 
declarator -> pointer direct_declarator 	0
{ VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM 
type_specifier -> CHAR 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
storage_class_specifier -> STATIC 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
type_specifier -> FLOAT 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_specifier -> TYPE_NAME 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
storage_class_specifier -> EXTERN 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
type_specifier -> SHORT 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_specifier -> LONG 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_specifier -> VOID 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_specifier -> DOUBLE 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_specifier -> UNSIGNED 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_specifier -> enum_specifier 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_qualifier -> CONST 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
storage_class_specifier -> AUTO 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
enum_specifier -> ENUM { enumerator_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; 
direct_declarator -> IDENTIFIER 	0
{ SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC TYPEDEF CONST UNION EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ 
storage_class_specifier -> TYPEDEF 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
type_qualifier -> VOLATILE 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
pointer -> * type_qualifier_list 	0
IDENTIFIER ( 
pointer -> * pointer 	0
IDENTIFIER ( 
pointer -> * type_qualifier_list pointer 	0
IDENTIFIER ( 
direct_declarator -> ( declarator ) 	0
{ SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC TYPEDEF CONST UNION EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ 
direct_declarator -> direct_declarator ( parameter_type_list ) 	0
{ SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC TYPEDEF CONST UNION EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ 
direct_declarator -> direct_declarator [ ] 	0
{ SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC TYPEDEF CONST UNION EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ 
direct_declarator -> direct_declarator [ constant_expression ] 	0
{ SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC TYPEDEF CONST UNION EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ 
struct_or_union_specifier -> struct_or_union { struct_declaration_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; 
enum_specifier -> ENUM IDENTIFIER { enumerator_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; 
struct_or_union_specifier -> struct_or_union IDENTIFIER { struct_declaration_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; 
struct_or_union_specifier -> struct_or_union IDENTIFIER 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; 
enum_specifier -> ENUM IDENTIFIER 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; 
struct_or_union -> UNION 	0
{ IDENTIFIER 

1 1
type_specifier -> LONG 	1
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; : [ ) , 

2 1
type_specifier -> INT 	1
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; : [ ) , 

3 1
direct_declarator -> IDENTIFIER 	1
; { VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ ) = , : 

4 1
storage_class_specifier -> TYPEDEF 	1
INT IDENTIFIER CHAR * SHORT SIGNED TYPE_NAME VOLATILE ( ; REGISTER STRUCT STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM [ ) , 

5 14
direct_declarator -> ( declarator ) 	1
; { VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ ) = , : 
direct_declarator -> ( declarator ) 	0
) ( [ 
declarator -> pointer direct_declarator 	0
) 
declarator -> direct_declarator 	0
) 
pointer -> * type_qualifier_list 	0
IDENTIFIER ( 
direct_declarator -> direct_declarator ( ) 	0
) ( [ 
pointer -> * 	0
IDENTIFIER ( 
direct_declarator -> IDENTIFIER 	0
) ( [ 
pointer -> * type_qualifier_list pointer 	0
IDENTIFIER ( 
pointer -> * pointer 	0
IDENTIFIER ( 
direct_declarator -> direct_declarator ( parameter_type_list ) 	0
) ( [ 
direct_declarator -> direct_declarator [ ] 	0
) ( [ 
direct_declarator -> direct_declarator [ constant_expression ] 	0
) ( [ 
direct_declarator -> direct_declarator ( identifier_list ) 	0
) ( [ 

6 1
type_specifier -> DOUBLE 	1
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; : [ ) , 

7 1
type_specifier -> CHAR 	1
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; : [ ) , 

8 12
pointer -> * pointer 	0
IDENTIFIER ( [ ) , 
pointer -> * type_qualifier_list 	1
IDENTIFIER ( [ ) , 
pointer -> * type_qualifier_list pointer 	0
IDENTIFIER ( [ ) , 
pointer -> * 	1
IDENTIFIER ( [ ) , 
type_qualifier_list -> type_qualifier_list type_qualifier 	0
IDENTIFIER ( [ CONST ) , VOLATILE * 
pointer -> * type_qualifier_list pointer 	1
IDENTIFIER ( [ ) , 
pointer -> * pointer 	1
IDENTIFIER ( [ ) , 
pointer -> * type_qualifier_list 	0
IDENTIFIER ( [ ) , 
pointer -> * 	0
IDENTIFIER ( [ ) , 
type_qualifier_list -> type_qualifier 	0
IDENTIFIER ( [ CONST ) , VOLATILE * 
type_qualifier -> VOLATILE 	0
IDENTIFIER ( [ ) CONST , * VOLATILE 
type_qualifier -> CONST 	0
IDENTIFIER ( [ ) CONST , * VOLATILE 

9 1
storage_class_specifier -> STATIC 	1
INT IDENTIFIER CHAR * SHORT SIGNED TYPE_NAME VOLATILE ( ; REGISTER STRUCT STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM [ ) , 

10 1
type_specifier -> SHORT 	1
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; : [ ) , 

11 1
storage_class_specifier -> EXTERN 	1
INT IDENTIFIER CHAR * SHORT SIGNED TYPE_NAME VOLATILE ( ; REGISTER STRUCT STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM [ ) , 

12 1
storage_class_specifier -> AUTO 	1
INT IDENTIFIER CHAR * SHORT SIGNED TYPE_NAME VOLATILE ( ; REGISTER STRUCT STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM [ ) , 

13 1
storage_class_specifier -> REGISTER 	1
INT IDENTIFIER CHAR * SHORT SIGNED TYPE_NAME VOLATILE ( ; REGISTER STRUCT STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM [ ) , 

14 1
type_specifier -> VOID 	1
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; : [ ) , 

15 1
type_specifier -> FLOAT 	1
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; : [ ) , 

16 1
type_specifier -> TYPE_NAME 	1
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; : [ ) , 

17 1
type_specifier -> SIGNED 	1
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; : [ ) , 

18 1
type_specifier -> UNSIGNED 	1
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; : [ ) , 

19 1
struct_or_union -> STRUCT 	1
{ IDENTIFIER 

20 1
struct_or_union -> UNION 	1
{ IDENTIFIER 

21 3
enum_specifier -> ENUM { enumerator_list } 	1
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; : [ ) , 
enum_specifier -> ENUM IDENTIFIER { enumerator_list } 	1
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; : [ ) , 
enum_specifier -> ENUM IDENTIFIER 	1
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; : [ ) , 

22 1
type_qualifier -> CONST 	1
INT IDENTIFIER CHAR * SHORT SIGNED TYPE_NAME VOLATILE ( ; REGISTER STRUCT STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM : [ ) , 

23 1
type_qualifier -> VOLATILE 	1
INT IDENTIFIER CHAR * SHORT SIGNED TYPE_NAME VOLATILE ( ; REGISTER STRUCT STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM : [ ) , 

24 3
struct_or_union_specifier -> struct_or_union { struct_declaration_list } 	1
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; : [ ) , 
struct_or_union_specifier -> struct_or_union IDENTIFIER 	1
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; : [ ) , 
struct_or_union_specifier -> struct_or_union IDENTIFIER { struct_declaration_list } 	1
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; : [ ) , 

25 56
type_specifier -> UNSIGNED 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
argumented_translation_unit -> translation_unit 	1
$ 
translation_unit -> translation_unit external_declaration 	1
STATIC INT IDENTIFIER FLOAT SHORT SIGNED TYPE_NAME VOLATILE REGISTER STRUCT CONST UNION * CHAR UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID $ LONG ENUM 
declarator -> direct_declarator 	0
{ VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM 
external_declaration -> function_definition 	0
STATIC INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT FLOAT STRUCT REGISTER UNION CONST CHAR * UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID LONG $ ENUM 
external_declaration -> declaration 	0
STATIC INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT FLOAT STRUCT REGISTER UNION CONST CHAR * UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID LONG $ ENUM 
function_definition -> declaration_specifiers declarator compound_statement 	0
STATIC INT IDENTIFIER FLOAT SHORT SIGNED TYPE_NAME VOLATILE REGISTER STRUCT CONST UNION * CHAR UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID $ LONG ENUM 
type_specifier -> INT 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
function_definition -> declarator compound_statement 	0
STATIC INT IDENTIFIER FLOAT SHORT SIGNED TYPE_NAME VOLATILE REGISTER STRUCT CONST UNION * CHAR UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID $ LONG ENUM 
storage_class_specifier -> REGISTER 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
declaration -> declaration_specifiers init_declarator_list ; 	0
STATIC INT IDENTIFIER FLOAT SHORT SIGNED TYPE_NAME VOLATILE REGISTER STRUCT CONST UNION * CHAR UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID $ LONG ENUM 
declaration -> declaration_specifiers ; 	0
STATIC INT IDENTIFIER FLOAT SHORT SIGNED TYPE_NAME VOLATILE REGISTER STRUCT CONST UNION * CHAR UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID $ LONG ENUM 
function_definition -> declaration_specifiers declarator declaration_list compound_statement 	0
STATIC INT IDENTIFIER FLOAT SHORT SIGNED TYPE_NAME VOLATILE REGISTER STRUCT CONST UNION * CHAR UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID $ LONG ENUM 
function_definition -> declarator declaration_list compound_statement 	0
STATIC INT IDENTIFIER FLOAT SHORT SIGNED TYPE_NAME VOLATILE REGISTER STRUCT CONST UNION * CHAR UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID $ LONG ENUM 
direct_declarator -> direct_declarator ( identifier_list ) 	0
{ SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC TYPEDEF CONST UNION EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ 
declaration_specifiers -> type_specifier declaration_specifiers 	0
IDENTIFIER * ( ; 
declaration_specifiers -> type_specifier 	0
IDENTIFIER * ( ; 
type_specifier -> struct_or_union_specifier 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
declaration_specifiers -> storage_class_specifier 	0
IDENTIFIER * ( ; 
declaration_specifiers -> storage_class_specifier declaration_specifiers 	0
IDENTIFIER * ( ; 
type_specifier -> SIGNED 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
declaration_specifiers -> type_qualifier 	0
IDENTIFIER * ( ; 
declaration_specifiers -> type_qualifier declaration_specifiers 	0
IDENTIFIER * ( ; 
declarator -> pointer direct_declarator 	0
{ VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM 
type_specifier -> CHAR 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
storage_class_specifier -> STATIC 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
type_specifier -> FLOAT 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_specifier -> TYPE_NAME 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
storage_class_specifier -> EXTERN 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
type_specifier -> SHORT 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_specifier -> LONG 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_specifier -> VOID 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_specifier -> DOUBLE 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_specifier -> enum_specifier 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_qualifier -> CONST 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
storage_class_specifier -> AUTO 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
enum_specifier -> ENUM { enumerator_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; 
direct_declarator -> IDENTIFIER 	0
{ SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC TYPEDEF CONST UNION EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ 
storage_class_specifier -> TYPEDEF 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
type_qualifier -> VOLATILE 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
direct_declarator -> direct_declarator ( ) 	0
{ SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC TYPEDEF CONST UNION EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ 
pointer -> * 	0
IDENTIFIER ( 
pointer -> * type_qualifier_list 	0
IDENTIFIER ( 
pointer -> * pointer 	0
IDENTIFIER ( 
pointer -> * type_qualifier_list pointer 	0
IDENTIFIER ( 
direct_declarator -> ( declarator ) 	0
{ SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC TYPEDEF CONST UNION EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ 
direct_declarator -> direct_declarator ( parameter_type_list ) 	0
{ SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC TYPEDEF CONST UNION EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ 
direct_declarator -> direct_declarator [ ] 	0
{ SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC TYPEDEF CONST UNION EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ 
direct_declarator -> direct_declarator [ constant_expression ] 	0
{ SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC TYPEDEF CONST UNION EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ 
struct_or_union_specifier -> struct_or_union { struct_declaration_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; 
enum_specifier -> ENUM IDENTIFIER { enumerator_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; 
struct_or_union_specifier -> struct_or_union IDENTIFIER { struct_declaration_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; 
struct_or_union_specifier -> struct_or_union IDENTIFIER 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; 
enum_specifier -> ENUM IDENTIFIER 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; 
struct_or_union -> STRUCT 	0
{ IDENTIFIER 
struct_or_union -> UNION 	0
{ IDENTIFIER 

26 35
declaration_specifiers -> storage_class_specifier 	1
IDENTIFIER * ( [ ; ) , 
declaration_specifiers -> storage_class_specifier declaration_specifiers 	1
IDENTIFIER * ( [ ; ) , 
declaration_specifiers -> storage_class_specifier declaration_specifiers 	0
IDENTIFIER * ( ; [ ) , 
type_specifier -> struct_or_union_specifier 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; [ ) , 
declaration_specifiers -> storage_class_specifier 	0
IDENTIFIER * ( ; [ ) , 
declaration_specifiers -> type_specifier 	0
IDENTIFIER * ( ; [ ) , 
declaration_specifiers -> type_specifier declaration_specifiers 	0
IDENTIFIER * ( ; [ ) , 
type_specifier -> CHAR 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; [ ) , 
declaration_specifiers -> type_qualifier declaration_specifiers 	0
IDENTIFIER * ( ; [ ) , 
type_specifier -> SIGNED 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; [ ) , 
declaration_specifiers -> type_qualifier 	0
IDENTIFIER * ( ; [ ) , 
storage_class_specifier -> STATIC 	0
INT IDENTIFIER SHORT CHAR * ( [ ; ) , STRUCT REGISTER SIGNED TYPE_NAME VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
type_specifier -> FLOAT 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; [ ) , 
type_specifier -> TYPE_NAME 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; [ ) , 
storage_class_specifier -> EXTERN 	0
INT IDENTIFIER SHORT CHAR * ( [ ; ) , STRUCT REGISTER SIGNED TYPE_NAME VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
type_specifier -> SHORT 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; [ ) , 
type_specifier -> LONG 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; [ ) , 
type_specifier -> VOID 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; [ ) , 
type_specifier -> INT 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; [ ) , 
type_specifier -> DOUBLE 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; [ ) , 
type_specifier -> UNSIGNED 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; [ ) , 
type_specifier -> enum_specifier 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; [ ) , 
type_qualifier -> CONST 	0
INT IDENTIFIER SHORT CHAR * ( [ ; ) , STRUCT REGISTER SIGNED TYPE_NAME VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
storage_class_specifier -> AUTO 	0
INT IDENTIFIER SHORT CHAR * ( [ ; ) , STRUCT REGISTER SIGNED TYPE_NAME VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
enum_specifier -> ENUM { enumerator_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; [ ) , 
storage_class_specifier -> TYPEDEF 	0
INT IDENTIFIER SHORT CHAR * ( [ ; ) , STRUCT REGISTER SIGNED TYPE_NAME VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
storage_class_specifier -> REGISTER 	0
INT IDENTIFIER SHORT CHAR * ( [ ; ) , STRUCT REGISTER SIGNED TYPE_NAME VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
type_qualifier -> VOLATILE 	0
INT IDENTIFIER SHORT CHAR * ( [ ; ) , STRUCT REGISTER SIGNED TYPE_NAME VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
struct_or_union_specifier -> struct_or_union { struct_declaration_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; [ ) , 
enum_specifier -> ENUM IDENTIFIER { enumerator_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; [ ) , 
struct_or_union_specifier -> struct_or_union IDENTIFIER { struct_declaration_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; [ ) , 
struct_or_union_specifier -> struct_or_union IDENTIFIER 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; [ ) , 
enum_specifier -> ENUM IDENTIFIER 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; [ ) , 
struct_or_union -> STRUCT 	0
{ IDENTIFIER 
struct_or_union -> UNION 	0
{ IDENTIFIER 

27 6
direct_declarator -> direct_declarator ( ) 	1
; { VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ ) = , : 
declarator -> direct_declarator 	1
; { SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC TYPEDEF CONST UNION EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ) = , : 
direct_declarator -> direct_declarator [ ] 	1
; { VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ ) = , : 
direct_declarator -> direct_declarator ( identifier_list ) 	1
; { VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ ) = , : 
direct_declarator -> direct_declarator ( parameter_type_list ) 	1
; { VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ ) = , : 
direct_declarator -> direct_declarator [ constant_expression ] 	1
; { VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ ) = , : 

28 1
external_declaration -> declaration 	1
STATIC LONG $ INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT FLOAT STRUCT REGISTER UNION CONST CHAR * UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID ENUM 

29 1
external_declaration -> function_definition 	1
STATIC LONG $ INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT FLOAT STRUCT REGISTER UNION CONST CHAR * UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID ENUM 

30 21
declaration -> declaration_specifiers ; 	1
STATIC LONG $ INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT FLOAT STRUCT REGISTER UNION CONST CHAR * UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID ENUM 
init_declarator_list -> init_declarator 	0
; , 
init_declarator -> declarator 	0
; 
declarator -> pointer direct_declarator 	0
; { VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM = 
declaration -> declaration_specifiers init_declarator_list ; 	1
STATIC LONG $ INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT FLOAT STRUCT REGISTER UNION CONST CHAR * UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID ENUM 
function_definition -> declaration_specifiers declarator compound_statement 	1
STATIC LONG $ INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT FLOAT STRUCT REGISTER UNION CONST CHAR * UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID ENUM 
declarator -> direct_declarator 	0
; { VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM = 
function_definition -> declaration_specifiers declarator declaration_list compound_statement 	1
STATIC LONG $ INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT FLOAT STRUCT REGISTER UNION CONST CHAR * UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID ENUM 
init_declarator_list -> init_declarator_list , init_declarator 	0
; , 
direct_declarator -> direct_declarator ( parameter_type_list ) 	0
{ SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC TYPEDEF CONST UNION EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ 
pointer -> * 	0
IDENTIFIER ( 
direct_declarator -> direct_declarator ( ) 	0
{ SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC TYPEDEF CONST UNION EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ 
pointer -> * type_qualifier_list 	0
IDENTIFIER ( 
pointer -> * pointer 	0
IDENTIFIER ( 
init_declarator -> declarator = initializer 	0
; 
pointer -> * type_qualifier_list pointer 	0
IDENTIFIER ( 
direct_declarator -> ( declarator ) 	0
{ SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC TYPEDEF CONST UNION EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ 
direct_declarator -> IDENTIFIER 	0
{ SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC TYPEDEF CONST UNION EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ 
direct_declarator -> direct_declarator [ ] 	0
{ SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC TYPEDEF CONST UNION EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ 
direct_declarator -> direct_declarator [ constant_expression ] 	0
{ SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC TYPEDEF CONST UNION EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ 
direct_declarator -> direct_declarator ( identifier_list ) 	0
{ SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC TYPEDEF CONST UNION EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ 

31 35
declaration_specifiers -> type_specifier 	1
IDENTIFIER * ( [ ; ) , 
type_specifier -> INT 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; [ ) , 
declaration_specifiers -> type_specifier declaration_specifiers 	1
IDENTIFIER * ( [ ; ) , 
declaration_specifiers -> storage_class_specifier declaration_specifiers 	0
IDENTIFIER * ( ; [ ) , 
declaration_specifiers -> storage_class_specifier 	0
IDENTIFIER * ( ; [ ) , 
type_specifier -> struct_or_union_specifier 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; [ ) , 
declaration_specifiers -> type_specifier 	0
IDENTIFIER * ( ; [ ) , 
declaration_specifiers -> type_specifier declaration_specifiers 	0
IDENTIFIER * ( ; [ ) , 
type_specifier -> CHAR 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; [ ) , 
declaration_specifiers -> type_qualifier declaration_specifiers 	0
IDENTIFIER * ( ; [ ) , 
declaration_specifiers -> type_qualifier 	0
IDENTIFIER * ( ; [ ) , 
type_specifier -> SIGNED 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; [ ) , 
type_specifier -> FLOAT 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; [ ) , 
storage_class_specifier -> STATIC 	0
INT IDENTIFIER SHORT CHAR * ( [ ; ) , STRUCT REGISTER SIGNED TYPE_NAME VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
type_specifier -> TYPE_NAME 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; [ ) , 
type_specifier -> SHORT 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; [ ) , 
storage_class_specifier -> EXTERN 	0
INT IDENTIFIER SHORT CHAR * ( [ ; ) , STRUCT REGISTER SIGNED TYPE_NAME VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
type_specifier -> VOID 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; [ ) , 
type_specifier -> LONG 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; [ ) , 
type_specifier -> DOUBLE 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; [ ) , 
type_specifier -> UNSIGNED 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; [ ) , 
type_specifier -> enum_specifier 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; [ ) , 
storage_class_specifier -> AUTO 	0
INT IDENTIFIER SHORT CHAR * ( [ ; ) , STRUCT REGISTER SIGNED TYPE_NAME VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
type_qualifier -> CONST 	0
INT IDENTIFIER SHORT CHAR * ( [ ; ) , STRUCT REGISTER SIGNED TYPE_NAME VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
storage_class_specifier -> TYPEDEF 	0
INT IDENTIFIER SHORT CHAR * ( [ ; ) , STRUCT REGISTER SIGNED TYPE_NAME VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
enum_specifier -> ENUM { enumerator_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; [ ) , 
storage_class_specifier -> REGISTER 	0
INT IDENTIFIER SHORT CHAR * ( [ ; ) , STRUCT REGISTER SIGNED TYPE_NAME VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
type_qualifier -> VOLATILE 	0
INT IDENTIFIER SHORT CHAR * ( [ ; ) , STRUCT REGISTER SIGNED TYPE_NAME VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
struct_or_union_specifier -> struct_or_union { struct_declaration_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; [ ) , 
struct_or_union_specifier -> struct_or_union IDENTIFIER { struct_declaration_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; [ ) , 
enum_specifier -> ENUM IDENTIFIER { enumerator_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; [ ) , 
struct_or_union_specifier -> struct_or_union IDENTIFIER 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; [ ) , 
enum_specifier -> ENUM IDENTIFIER 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; [ ) , 
struct_or_union -> STRUCT 	0
{ IDENTIFIER 
struct_or_union -> UNION 	0
{ IDENTIFIER 

32 35
declaration_specifiers -> type_qualifier declaration_specifiers 	1
IDENTIFIER * ( [ ; ) , 
declaration_specifiers -> type_qualifier 	1
IDENTIFIER * ( [ ; ) , 
type_specifier -> DOUBLE 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; [ ) , 
declaration_specifiers -> storage_class_specifier declaration_specifiers 	0
IDENTIFIER * ( ; [ ) , 
declaration_specifiers -> storage_class_specifier 	0
IDENTIFIER * ( ; [ ) , 
type_specifier -> struct_or_union_specifier 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; [ ) , 
declaration_specifiers -> type_specifier 	0
IDENTIFIER * ( ; [ ) , 
declaration_specifiers -> type_specifier declaration_specifiers 	0
IDENTIFIER * ( ; [ ) , 
type_specifier -> CHAR 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; [ ) , 
declaration_specifiers -> type_qualifier declaration_specifiers 	0
IDENTIFIER * ( ; [ ) , 
declaration_specifiers -> type_qualifier 	0
IDENTIFIER * ( ; [ ) , 
type_specifier -> SIGNED 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; [ ) , 
type_specifier -> FLOAT 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; [ ) , 
storage_class_specifier -> STATIC 	0
INT IDENTIFIER SHORT CHAR * ( [ ; ) , STRUCT REGISTER SIGNED TYPE_NAME VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
type_specifier -> TYPE_NAME 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; [ ) , 
type_specifier -> SHORT 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; [ ) , 
storage_class_specifier -> EXTERN 	0
INT IDENTIFIER SHORT CHAR * ( [ ; ) , STRUCT REGISTER SIGNED TYPE_NAME VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
type_specifier -> VOID 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; [ ) , 
type_specifier -> LONG 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; [ ) , 
type_specifier -> INT 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; [ ) , 
type_specifier -> UNSIGNED 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; [ ) , 
type_specifier -> enum_specifier 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; [ ) , 
storage_class_specifier -> AUTO 	0
INT IDENTIFIER SHORT CHAR * ( [ ; ) , STRUCT REGISTER SIGNED TYPE_NAME VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
type_qualifier -> CONST 	0
INT IDENTIFIER SHORT CHAR * ( [ ; ) , STRUCT REGISTER SIGNED TYPE_NAME VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
storage_class_specifier -> TYPEDEF 	0
INT IDENTIFIER SHORT CHAR * ( [ ; ) , STRUCT REGISTER SIGNED TYPE_NAME VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
enum_specifier -> ENUM { enumerator_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; [ ) , 
storage_class_specifier -> REGISTER 	0
INT IDENTIFIER SHORT CHAR * ( [ ; ) , STRUCT REGISTER SIGNED TYPE_NAME VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
type_qualifier -> VOLATILE 	0
INT IDENTIFIER SHORT CHAR * ( [ ; ) , STRUCT REGISTER SIGNED TYPE_NAME VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
struct_or_union_specifier -> struct_or_union { struct_declaration_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; [ ) , 
struct_or_union_specifier -> struct_or_union IDENTIFIER { struct_declaration_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; [ ) , 
enum_specifier -> ENUM IDENTIFIER { enumerator_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; [ ) , 
struct_or_union_specifier -> struct_or_union IDENTIFIER 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; [ ) , 
enum_specifier -> ENUM IDENTIFIER 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; [ ) , 
struct_or_union -> STRUCT 	0
{ IDENTIFIER 
struct_or_union -> UNION 	0
{ IDENTIFIER 

33 43
compound_statement -> { statement_list } 	0
LONG $ STATIC INT IDENTIFIER SHORT SIGNED TYPE_NAME VOLATILE FLOAT REGISTER STRUCT CONST UNION * CHAR UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID ENUM 
function_definition -> declarator compound_statement 	1
STATIC LONG $ INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT FLOAT STRUCT REGISTER UNION CONST CHAR * UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID ENUM 
type_specifier -> enum_specifier 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
declaration_list -> declaration_list declaration 	0
{ STRUCT REGISTER VOLATILE SIGNED TYPE_NAME SHORT STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM 
function_definition -> declarator declaration_list compound_statement 	1
STATIC LONG $ INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT FLOAT STRUCT REGISTER UNION CONST CHAR * UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID ENUM 
compound_statement -> { declaration_list } 	0
LONG $ STATIC INT IDENTIFIER SHORT SIGNED TYPE_NAME VOLATILE FLOAT REGISTER STRUCT CONST UNION * CHAR UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID ENUM 
compound_statement -> { } 	0
LONG $ STATIC INT IDENTIFIER SHORT SIGNED TYPE_NAME VOLATILE FLOAT REGISTER STRUCT CONST UNION * CHAR UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID ENUM 
declaration_specifiers -> storage_class_specifier 	0
IDENTIFIER * ( ; 
type_specifier -> struct_or_union_specifier 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
declaration -> declaration_specifiers init_declarator_list ; 	0
{ 
storage_class_specifier -> REGISTER 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
compound_statement -> { declaration_list statement_list } 	0
LONG $ STATIC INT IDENTIFIER SHORT SIGNED TYPE_NAME VOLATILE FLOAT REGISTER STRUCT CONST UNION * CHAR UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID ENUM 
declaration_list -> declaration 	0
{ STRUCT REGISTER VOLATILE SIGNED TYPE_NAME SHORT STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM 
struct_or_union_specifier -> struct_or_union IDENTIFIER { struct_declaration_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; 
enum_specifier -> ENUM IDENTIFIER { enumerator_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; 
declaration -> declaration_specifiers ; 	0
{ 
declaration_specifiers -> type_specifier declaration_specifiers 	0
IDENTIFIER * ( ; 
declaration_specifiers -> type_specifier 	0
IDENTIFIER * ( ; 
declaration_specifiers -> storage_class_specifier declaration_specifiers 	0
IDENTIFIER * ( ; 
declaration_specifiers -> type_qualifier 	0
IDENTIFIER * ( ; 
type_specifier -> SIGNED 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
declaration_specifiers -> type_qualifier declaration_specifiers 	0
IDENTIFIER * ( ; 
type_specifier -> CHAR 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_specifier -> FLOAT 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
storage_class_specifier -> STATIC 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
type_specifier -> TYPE_NAME 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_specifier -> SHORT 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
storage_class_specifier -> EXTERN 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
type_specifier -> VOID 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_specifier -> LONG 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_specifier -> INT 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_specifier -> DOUBLE 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_specifier -> UNSIGNED 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
storage_class_specifier -> AUTO 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
type_qualifier -> CONST 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
storage_class_specifier -> TYPEDEF 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
enum_specifier -> ENUM { enumerator_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; 
type_qualifier -> VOLATILE 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
struct_or_union_specifier -> struct_or_union { struct_declaration_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; 
struct_or_union_specifier -> struct_or_union IDENTIFIER 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; 
enum_specifier -> ENUM IDENTIFIER 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; 
struct_or_union -> STRUCT 	0
{ IDENTIFIER 
struct_or_union -> UNION 	0
{ IDENTIFIER 

34 1
type_specifier -> struct_or_union_specifier 	1
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; : [ ) , 

35 1
type_specifier -> enum_specifier 	1
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; : [ ) , 

36 8
declarator -> pointer direct_declarator 	1
; { SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC TYPEDEF CONST UNION EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ) = , : 
direct_declarator -> direct_declarator ( parameter_type_list ) 	0
; { VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ) = , : ( [ 
direct_declarator -> ( declarator ) 	0
; { VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ) = , : ( [ 
direct_declarator -> IDENTIFIER 	0
; { VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ) = , : ( [ 
direct_declarator -> direct_declarator [ ] 	0
; { VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ) = , : ( [ 
direct_declarator -> direct_declarator [ constant_expression ] 	0
; { VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ) = , : ( [ 
direct_declarator -> direct_declarator ( identifier_list ) 	0
; { VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ) = , : ( [ 
direct_declarator -> direct_declarator ( ) 	0
; { VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ) = , : ( [ 

37 1
translation_unit -> external_declaration 	1
STATIC INT IDENTIFIER FLOAT SHORT SIGNED TYPE_NAME VOLATILE REGISTER STRUCT CONST UNION * CHAR UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID $ LONG ENUM 

38 1
direct_declarator -> ( declarator ) 	2
; { SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC TYPEDEF CONST UNION EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ ) = , : 

39 1
type_qualifier_list -> type_qualifier 	1
* VOLATILE ) CONST IDENTIFIER ( [ , 

40 1
pointer -> * pointer 	2
IDENTIFIER ( [ ) , 

41 9
type_qualifier -> VOLATILE 	0
VOLATILE * CONST ) IDENTIFIER ( [ , 
pointer -> * type_qualifier_list 	2
IDENTIFIER ( [ ) , 
type_qualifier_list -> type_qualifier_list type_qualifier 	1
* VOLATILE ) CONST IDENTIFIER ( [ , 
pointer -> * type_qualifier_list pointer 	2
IDENTIFIER ( [ ) , 
type_qualifier -> CONST 	0
VOLATILE * CONST ) IDENTIFIER ( [ , 
pointer -> * type_qualifier_list 	0
IDENTIFIER ( [ ) , 
pointer -> * 	0
IDENTIFIER ( [ ) , 
pointer -> * type_qualifier_list pointer 	0
IDENTIFIER ( [ ) , 
pointer -> * pointer 	0
IDENTIFIER ( [ ) , 

42 2
enum_specifier -> ENUM IDENTIFIER { enumerator_list } 	2
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; : [ ) , 
enum_specifier -> ENUM IDENTIFIER 	2
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; : [ ) , 

43 5
enumerator_list -> enumerator_list , enumerator 	0
} , 
enum_specifier -> ENUM { enumerator_list } 	2
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; : [ ) , 
enumerator -> IDENTIFIER = constant_expression 	0
} 
enumerator_list -> enumerator 	0
} , 
enumerator -> IDENTIFIER 	0
} 

44 2
struct_or_union_specifier -> struct_or_union IDENTIFIER 	2
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; : [ ) , 
struct_or_union_specifier -> struct_or_union IDENTIFIER { struct_declaration_list } 	2
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; : [ ) , 

45 30
struct_or_union_specifier -> struct_or_union { struct_declaration_list } 	2
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; : [ ) , 
type_specifier -> CHAR 	0
* CHAR SHORT SIGNED TYPE_NAME : INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
struct_declaration_list -> struct_declaration 	0
DOUBLE } FLOAT CHAR SIGNED TYPE_NAME SHORT VOID INT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
specifier_qualifier_list -> type_specifier specifier_qualifier_list 	0
* : IDENTIFIER ( 
specifier_qualifier_list -> type_qualifier 	0
* : IDENTIFIER ( 
struct_declaration_list -> struct_declaration_list struct_declaration 	0
DOUBLE } FLOAT CHAR SIGNED TYPE_NAME SHORT VOID INT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_qualifier -> VOLATILE 	0
TYPE_NAME SIGNED FLOAT * CHAR SHORT VOID DOUBLE IDENTIFIER INT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT : ( 
specifier_qualifier_list -> type_specifier 	0
* : IDENTIFIER ( 
specifier_qualifier_list -> type_qualifier specifier_qualifier_list 	0
* : IDENTIFIER ( 
struct_declaration -> specifier_qualifier_list struct_declarator_list ; 	0
} 
type_qualifier -> CONST 	0
TYPE_NAME SIGNED FLOAT * CHAR SHORT VOID DOUBLE IDENTIFIER INT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT : ( 
type_specifier -> FLOAT 	0
* CHAR SHORT SIGNED TYPE_NAME : INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> TYPE_NAME 	0
* CHAR SHORT SIGNED TYPE_NAME : INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> SHORT 	0
* CHAR SHORT SIGNED TYPE_NAME : INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> LONG 	0
* CHAR SHORT SIGNED TYPE_NAME : INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> VOID 	0
* CHAR SHORT SIGNED TYPE_NAME : INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> INT 	0
* CHAR SHORT SIGNED TYPE_NAME : INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> DOUBLE 	0
* CHAR SHORT SIGNED TYPE_NAME : INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> SIGNED 	0
* CHAR SHORT SIGNED TYPE_NAME : INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> UNSIGNED 	0
* CHAR SHORT SIGNED TYPE_NAME : INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> struct_or_union_specifier 	0
* CHAR SHORT SIGNED TYPE_NAME : INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> enum_specifier 	0
* CHAR SHORT SIGNED TYPE_NAME : INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
struct_or_union_specifier -> struct_or_union { struct_declaration_list } 	0
: SIGNED TYPE_NAME SHORT * CHAR INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 
enum_specifier -> ENUM IDENTIFIER { enumerator_list } 	0
: SIGNED TYPE_NAME SHORT * CHAR INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 
struct_or_union_specifier -> struct_or_union IDENTIFIER { struct_declaration_list } 	0
: SIGNED TYPE_NAME SHORT * CHAR INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 
struct_or_union_specifier -> struct_or_union IDENTIFIER 	0
: SIGNED TYPE_NAME SHORT * CHAR INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 
enum_specifier -> ENUM { enumerator_list } 	0
: SIGNED TYPE_NAME SHORT * CHAR INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 
enum_specifier -> ENUM IDENTIFIER 	0
: SIGNED TYPE_NAME SHORT * CHAR INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 
struct_or_union -> STRUCT 	0
{ IDENTIFIER 
struct_or_union -> UNION 	0
{ IDENTIFIER 

46 1
translation_unit -> translation_unit external_declaration 	2
STATIC INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT FLOAT STRUCT REGISTER UNION CONST CHAR * UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID LONG $ ENUM 

47 1
declaration_specifiers -> storage_class_specifier declaration_specifiers 	2
IDENTIFIER * ( ; [ ) , 

48 45
declaration_specifiers -> storage_class_specifier declaration_specifiers 	0
IDENTIFIER * ( [ ) , 
parameter_type_list -> parameter_list 	0
) 
type_qualifier -> VOLATILE 	0
INT IDENTIFIER SIGNED TYPE_NAME SHORT CHAR * ( [ ) , STRUCT REGISTER VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
direct_declarator -> direct_declarator ( ) 	2
; { SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC TYPEDEF CONST UNION EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ ) = , : 
identifier_list -> identifier_list , IDENTIFIER 	0
) , 
type_specifier -> TYPE_NAME 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
direct_declarator -> direct_declarator ( identifier_list ) 	2
; { SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC TYPEDEF CONST UNION EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ ) = , : 
direct_declarator -> direct_declarator ( parameter_type_list ) 	2
; { SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC TYPEDEF CONST UNION EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ ) = , : 
parameter_list -> parameter_declaration 	0
) , 
identifier_list -> IDENTIFIER 	0
) , 
parameter_type_list -> parameter_list , ELLIPSIS 	0
) 
parameter_list -> parameter_list , parameter_declaration 	0
) , 
type_specifier -> LONG 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
type_specifier -> VOID 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
parameter_declaration -> declaration_specifiers declarator 	0
) , 
enum_specifier -> ENUM { enumerator_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( [ ) , 
storage_class_specifier -> TYPEDEF 	0
INT IDENTIFIER SIGNED TYPE_NAME SHORT CHAR * ( [ ) , STRUCT REGISTER VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
parameter_declaration -> declaration_specifiers abstract_declarator 	0
) , 
parameter_declaration -> declaration_specifiers 	0
) , 
declaration_specifiers -> type_specifier declaration_specifiers 	0
IDENTIFIER * ( [ ) , 
declaration_specifiers -> type_specifier 	0
IDENTIFIER * ( [ ) , 
type_specifier -> struct_or_union_specifier 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
declaration_specifiers -> storage_class_specifier 	0
IDENTIFIER * ( [ ) , 
type_specifier -> SIGNED 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
declaration_specifiers -> type_qualifier 	0
IDENTIFIER * ( [ ) , 
declaration_specifiers -> type_qualifier declaration_specifiers 	0
IDENTIFIER * ( [ ) , 
type_specifier -> CHAR 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
storage_class_specifier -> STATIC 	0
INT IDENTIFIER SIGNED TYPE_NAME SHORT CHAR * ( [ ) , STRUCT REGISTER VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
type_specifier -> FLOAT 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
storage_class_specifier -> EXTERN 	0
INT IDENTIFIER SIGNED TYPE_NAME SHORT CHAR * ( [ ) , STRUCT REGISTER VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
type_specifier -> SHORT 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
type_specifier -> INT 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
type_specifier -> DOUBLE 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
type_specifier -> UNSIGNED 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
type_specifier -> enum_specifier 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
type_qualifier -> CONST 	0
INT IDENTIFIER SIGNED TYPE_NAME SHORT CHAR * ( [ ) , STRUCT REGISTER VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
storage_class_specifier -> AUTO 	0
INT IDENTIFIER SIGNED TYPE_NAME SHORT CHAR * ( [ ) , STRUCT REGISTER VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
storage_class_specifier -> REGISTER 	0
INT IDENTIFIER SIGNED TYPE_NAME SHORT CHAR * ( [ ) , STRUCT REGISTER VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
struct_or_union_specifier -> struct_or_union { struct_declaration_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( [ ) , 
enum_specifier -> ENUM IDENTIFIER { enumerator_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( [ ) , 
struct_or_union_specifier -> struct_or_union IDENTIFIER { struct_declaration_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( [ ) , 
struct_or_union_specifier -> struct_or_union IDENTIFIER 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( [ ) , 
enum_specifier -> ENUM IDENTIFIER 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( [ ) , 
struct_or_union -> STRUCT 	0
{ IDENTIFIER 
struct_or_union -> UNION 	0
{ IDENTIFIER 

49 59
unary_expression -> SIZEOF unary_expression 	0
? OR_OP ] EQ_OP < * 
logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression 	0
? OR_OP ] AND_OP 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
additive_expression -> additive_expression + multiplicative_expression 	0
OR_OP ? - ] < EQ_OP + 
direct_declarator -> direct_declarator [ ] 	2
; { SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC TYPEDEF CONST UNION EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ ) = , : 
unary_expression -> SIZEOF ( type_name ) 	0
? OR_OP ] EQ_OP < * 
and_expression -> equality_expression 	0
OR_OP ? ] & 
direct_declarator -> direct_declarator [ constant_expression ] 	2
; { SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC TYPEDEF CONST UNION EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ ) = , : 
constant_expression -> conditional_expression 	0
] 
postfix_expression -> postfix_expression . IDENTIFIER 	0
? OR_OP ] < EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
conditional_expression -> logical_or_expression 	0
] 
conditional_expression -> logical_or_expression ? expression : conditional_expression 	0
] 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
/ ? OR_OP % ] EQ_OP < * 
logical_and_expression -> inclusive_or_expression 	0
? OR_OP ] AND_OP 
logical_or_expression -> logical_or_expression OR_OP logical_and_expression 	0
OR_OP ? ] 
cast_expression -> unary_expression 	0
OR_OP ? ] < EQ_OP * 
logical_or_expression -> logical_and_expression 	0
OR_OP ? ] 
inclusive_or_expression -> exclusive_or_expression 	0
OR_OP ? ] | 
and_expression -> and_expression & equality_expression 	0
OR_OP ? ] & 
inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression 	0
OR_OP ? ] | 
exclusive_or_expression -> and_expression 	0
? OR_OP ] ^ 
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	0
? OR_OP ] ^ 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
? OR_OP ] < EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
unary_expression -> INC_OP unary_expression 	0
? OR_OP ] EQ_OP < * 
equality_expression -> equality_expression EQ_OP relational_expression 	0
NE_OP ? OR_OP ] EQ_OP 
equality_expression -> relational_expression 	0
NE_OP ? OR_OP ] EQ_OP 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
equality_expression -> equality_expression NE_OP relational_expression 	0
NE_OP ? OR_OP ] EQ_OP 
multiplicative_expression -> cast_expression 	0
/ ? OR_OP % ] EQ_OP < * 
relational_expression -> shift_expression 	0
OR_OP ? LE_OP ] < EQ_OP > GE_OP 
relational_expression -> relational_expression < shift_expression 	0
OR_OP ? LE_OP ] < EQ_OP > GE_OP 
relational_expression -> relational_expression > shift_expression 	0
OR_OP ? LE_OP ] < EQ_OP > GE_OP 
unary_expression -> unary_operator cast_expression 	0
? OR_OP ] EQ_OP < * 
relational_expression -> relational_expression LE_OP shift_expression 	0
OR_OP ? LE_OP ] < EQ_OP > GE_OP 
relational_expression -> relational_expression GE_OP shift_expression 	0
OR_OP ? LE_OP ] < EQ_OP > GE_OP 
shift_expression -> additive_expression 	0
? OR_OP ] EQ_OP < LEFT_OP RIGHT_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	0
? OR_OP ] EQ_OP < LEFT_OP RIGHT_OP 
primary_expression -> CONSTANT 	0
? OR_OP ] EQ_OP < * . ( 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
? OR_OP ] EQ_OP < LEFT_OP RIGHT_OP 
additive_expression -> multiplicative_expression 	0
OR_OP ? - ] < EQ_OP + 
additive_expression -> additive_expression - multiplicative_expression 	0
OR_OP ? - ] < EQ_OP + 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
/ ? OR_OP % ] EQ_OP < * 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
/ ? OR_OP % ] EQ_OP < * 
cast_expression -> ( type_name ) cast_expression 	0
OR_OP ? ] < EQ_OP * 
primary_expression -> IDENTIFIER 	0
? OR_OP ] EQ_OP < * . ( 
unary_expression -> DEC_OP unary_expression 	0
? OR_OP ] EQ_OP < * 
unary_expression -> postfix_expression 	0
? OR_OP ] EQ_OP < * 
postfix_expression -> primary_expression 	0
? OR_OP ] < EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression ( ) 	0
? OR_OP ] < EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression INC_OP 	0
? OR_OP ] < EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
? OR_OP ] < EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
? OR_OP ] < EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
? OR_OP ] < EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
primary_expression -> ( expression ) 	0
? OR_OP ] EQ_OP < * . ( 
primary_expression -> STRING_LITERAL 	0
? OR_OP ] EQ_OP < * . ( 

50 1
declaration -> declaration_specifiers ; 	2
DEC_OP LONG $ STATIC DEFAULT INT IDENTIFIER SHORT SIGNED TYPE_NAME VOLATILE FLOAT REGISTER STRUCT DO CONST UNION * CHAR IF UNSIGNED ( STRING_LITERAL TYPEDEF EXTERN AUTO DOUBLE RETURN VOID ENUM ; { - BREAK } WHILE GOTO CASE FOR CONTINUE SIZEOF INC_OP SWITCH CONSTANT & ~ + ! 

51 1
init_declarator_list -> init_declarator 	1
; , 

52 2
declaration -> declaration_specifiers init_declarator_list ; 	2
DEC_OP LONG $ STATIC DEFAULT INT IDENTIFIER SHORT SIGNED TYPE_NAME VOLATILE FLOAT REGISTER STRUCT DO CONST UNION * CHAR IF UNSIGNED ( STRING_LITERAL TYPEDEF EXTERN AUTO DOUBLE RETURN VOID ENUM ; { - BREAK } WHILE GOTO CASE FOR CONTINUE SIZEOF INC_OP SWITCH CONSTANT & ~ + ! 
init_declarator_list -> init_declarator_list , init_declarator 	1
; , 

53 45
function_definition -> declaration_specifiers declarator compound_statement 	2
LONG $ STATIC INT IDENTIFIER SHORT SIGNED TYPE_NAME VOLATILE FLOAT REGISTER STRUCT CONST UNION * CHAR UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID ENUM 
compound_statement -> { declaration_list } 	0
STATIC LONG $ INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT FLOAT STRUCT REGISTER UNION CONST CHAR * UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID ENUM 
init_declarator -> declarator 	1
; 
enum_specifier -> ENUM IDENTIFIER { enumerator_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; 
struct_or_union_specifier -> struct_or_union IDENTIFIER { struct_declaration_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; 
declaration_list -> declaration 	0
{ STRUCT REGISTER VOLATILE SIGNED TYPE_NAME SHORT STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM 
storage_class_specifier -> STATIC 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
type_specifier -> FLOAT 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
function_definition -> declaration_specifiers declarator declaration_list compound_statement 	2
LONG $ STATIC INT IDENTIFIER SHORT SIGNED TYPE_NAME VOLATILE FLOAT REGISTER STRUCT CONST UNION * CHAR UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID ENUM 
type_specifier -> struct_or_union_specifier 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
declaration_specifiers -> storage_class_specifier 	0
IDENTIFIER * ( ; 
compound_statement -> { } 	0
STATIC LONG $ INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT FLOAT STRUCT REGISTER UNION CONST CHAR * UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID ENUM 
declaration_specifiers -> type_specifier declaration_specifiers 	0
IDENTIFIER * ( ; 
init_declarator -> declarator = initializer 	1
; 
compound_statement -> { statement_list } 	0
STATIC LONG $ INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT FLOAT STRUCT REGISTER UNION CONST CHAR * UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID ENUM 
compound_statement -> { declaration_list statement_list } 	0
STATIC LONG $ INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT FLOAT STRUCT REGISTER UNION CONST CHAR * UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID ENUM 
declaration_list -> declaration_list declaration 	0
{ STRUCT REGISTER VOLATILE SIGNED TYPE_NAME SHORT STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM 
storage_class_specifier -> REGISTER 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
declaration -> declaration_specifiers init_declarator_list ; 	0
{ 
declaration -> declaration_specifiers ; 	0
{ 
declaration_specifiers -> type_specifier 	0
IDENTIFIER * ( ; 
declaration_specifiers -> storage_class_specifier declaration_specifiers 	0
IDENTIFIER * ( ; 
type_specifier -> SIGNED 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
declaration_specifiers -> type_qualifier 	0
IDENTIFIER * ( ; 
declaration_specifiers -> type_qualifier declaration_specifiers 	0
IDENTIFIER * ( ; 
type_specifier -> CHAR 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_specifier -> TYPE_NAME 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
storage_class_specifier -> EXTERN 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
type_specifier -> SHORT 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_specifier -> LONG 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_specifier -> VOID 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_specifier -> INT 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_specifier -> DOUBLE 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_specifier -> UNSIGNED 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_specifier -> enum_specifier 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_qualifier -> CONST 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
storage_class_specifier -> AUTO 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
enum_specifier -> ENUM { enumerator_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; 
storage_class_specifier -> TYPEDEF 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
type_qualifier -> VOLATILE 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
struct_or_union_specifier -> struct_or_union { struct_declaration_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; 
struct_or_union_specifier -> struct_or_union IDENTIFIER 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; 
enum_specifier -> ENUM IDENTIFIER 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; 
struct_or_union -> STRUCT 	0
{ IDENTIFIER 
struct_or_union -> UNION 	0
{ IDENTIFIER 

54 1
declaration_specifiers -> type_specifier declaration_specifiers 	2
IDENTIFIER * ( ; [ ) , 

55 1
declaration_specifiers -> type_qualifier declaration_specifiers 	2
IDENTIFIER * ( ; [ ) , 

56 130
compound_statement -> { declaration_list } 	0
} 
compound_statement -> { statement_list } 	1
FOR ELSE } DEFAULT INT IDENTIFIER WHILE DEC_OP LONG $ STATIC VOLATILE TYPE_NAME SIGNED SHORT FLOAT REGISTER STRUCT DO CONST UNION * CHAR IF UNSIGNED ( STRING_LITERAL TYPEDEF EXTERN AUTO DOUBLE RETURN VOID ENUM GOTO CASE { ; CONTINUE - BREAK SIZEOF INC_OP SWITCH CONSTANT & ~ + ! 
compound_statement -> { declaration_list } 	1
FOR ELSE } DEFAULT INT IDENTIFIER WHILE DEC_OP LONG $ STATIC VOLATILE TYPE_NAME SIGNED SHORT FLOAT REGISTER STRUCT DO CONST UNION * CHAR IF UNSIGNED ( STRING_LITERAL TYPEDEF EXTERN AUTO DOUBLE RETURN VOID ENUM GOTO CASE { ; CONTINUE - BREAK SIZEOF INC_OP SWITCH CONSTANT & ~ + ! 
expression_statement -> ; 	0
} 
jump_statement -> BREAK ; 	0
} 
compound_statement -> { } 	1
FOR ELSE } DEFAULT INT IDENTIFIER WHILE DEC_OP LONG $ STATIC VOLATILE TYPE_NAME SIGNED SHORT FLOAT REGISTER STRUCT DO CONST UNION * CHAR IF UNSIGNED ( STRING_LITERAL TYPEDEF EXTERN AUTO DOUBLE RETURN VOID ENUM GOTO CASE { ; CONTINUE - BREAK SIZEOF INC_OP SWITCH CONSTANT & ~ + ! 
compound_statement -> { declaration_list statement_list } 	1
FOR ELSE } DEFAULT INT IDENTIFIER WHILE DEC_OP LONG $ STATIC VOLATILE TYPE_NAME SIGNED SHORT FLOAT REGISTER STRUCT DO CONST UNION * CHAR IF UNSIGNED ( STRING_LITERAL TYPEDEF EXTERN AUTO DOUBLE RETURN VOID ENUM GOTO CASE { ; CONTINUE - BREAK SIZEOF INC_OP SWITCH CONSTANT & ~ + ! 
storage_class_specifier -> EXTERN 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
type_specifier -> SHORT 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
jump_statement -> GOTO IDENTIFIER ; 	0
} 
enum_specifier -> ENUM IDENTIFIER { enumerator_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; 
declaration_list -> declaration 	0
- BREAK FOR } INT IDENTIFIER DEFAULT WHILE GOTO CASE ; { VOID RETURN CONTINUE UNION CONST DO SIZEOF INC_OP LONG DEC_OP TYPEDEF STRING_LITERAL UNSIGNED IF SWITCH CONSTANT ( & CHAR * ~ + ! STRUCT REGISTER SHORT SIGNED TYPE_NAME VOLATILE STATIC EXTERN AUTO DOUBLE FLOAT ENUM 
statement -> jump_statement 	0
} 
statement_list -> statement 	0
FOR } IDENTIFIER DEFAULT WHILE GOTO CASE ; { RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
declaration_specifiers -> storage_class_specifier declaration_specifiers 	0
IDENTIFIER * ( ; 
statement_list -> statement_list statement 	0
FOR } IDENTIFIER DEFAULT WHILE GOTO CASE ; { RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
declaration_list -> declaration_list declaration 	0
- BREAK FOR } INT IDENTIFIER DEFAULT WHILE GOTO CASE ; { VOID RETURN CONTINUE UNION CONST DO SIZEOF INC_OP LONG DEC_OP TYPEDEF STRING_LITERAL UNSIGNED IF SWITCH CONSTANT ( & CHAR * ~ + ! STRUCT REGISTER SHORT SIGNED TYPE_NAME VOLATILE STATIC EXTERN AUTO DOUBLE FLOAT ENUM 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
statement -> iteration_statement 	0
} 
additive_expression -> additive_expression + multiplicative_expression 	0
OR_OP ? + ; < EQ_OP - 
statement -> compound_statement 	0
} 
statement -> labeled_statement 	0
} 
statement -> expression_statement 	0
} 
statement -> selection_statement 	0
} 
storage_class_specifier -> REGISTER 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
declaration -> declaration_specifiers init_declarator_list ; 	0
} FOR - BREAK GOTO WHILE IDENTIFIER DEFAULT CASE { ; RETURN CONTINUE DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
declaration -> declaration_specifiers ; 	0
} FOR - BREAK GOTO WHILE IDENTIFIER DEFAULT CASE { ; RETURN CONTINUE DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
iteration_statement -> DO statement WHILE ( expression ) ; 	0
} 
iteration_statement -> FOR ( expression_statement expression_statement ) statement 	0
} 
iteration_statement -> WHILE ( expression ) statement 	0
} 
iteration_statement -> FOR ( expression_statement expression_statement expression ) statement 	0
} 
compound_statement -> { statement_list } 	0
} 
labeled_statement -> DEFAULT : statement 	0
} 
type_specifier -> struct_or_union_specifier 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
declaration_specifiers -> storage_class_specifier 	0
IDENTIFIER * ( ; 
compound_statement -> { } 	0
} 
compound_statement -> { declaration_list statement_list } 	0
} 
jump_statement -> RETURN ; 	0
} 
declaration_specifiers -> type_specifier declaration_specifiers 	0
IDENTIFIER * ( ; 
labeled_statement -> IDENTIFIER : statement 	0
} 
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	0
? OR_OP ; ^ 
jump_statement -> CONTINUE ; 	0
} 
jump_statement -> RETURN expression ; 	0
} 
declaration_specifiers -> type_qualifier declaration_specifiers 	0
IDENTIFIER * ( ; 
labeled_statement -> CASE constant_expression : statement 	0
} 
and_expression -> and_expression & equality_expression 	0
OR_OP ? ; & 
expression_statement -> expression ; 	0
} 
selection_statement -> IF ( expression ) statement ELSE statement 	0
} 
selection_statement -> IF ( expression ) statement 	0
} 
selection_statement -> SWITCH ( expression ) statement 	0
} 
declaration_specifiers -> type_specifier 	0
IDENTIFIER * ( ; 
type_specifier -> SIGNED 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
declaration_specifiers -> type_qualifier 	0
IDENTIFIER * ( ; 
storage_class_specifier -> TYPEDEF 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
expression -> assignment_expression 	0
; , 
expression -> expression , assignment_expression 	0
; , 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
type_specifier -> CHAR 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
assignment_expression -> conditional_expression 	0
; 
storage_class_specifier -> STATIC 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
type_specifier -> FLOAT 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_specifier -> TYPE_NAME 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_specifier -> LONG 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_specifier -> VOID 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_specifier -> INT 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_specifier -> DOUBLE 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_specifier -> UNSIGNED 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_specifier -> enum_specifier 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_qualifier -> CONST 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
inclusive_or_expression -> exclusive_or_expression 	0
OR_OP ? ; | 
storage_class_specifier -> AUTO 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
type_qualifier -> VOLATILE 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
assignment_expression -> unary_expression assignment_operator assignment_expression 	0
; 
struct_or_union_specifier -> struct_or_union { struct_declaration_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; 
struct_or_union_specifier -> struct_or_union IDENTIFIER { struct_declaration_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; 
struct_or_union_specifier -> struct_or_union IDENTIFIER 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; 
enum_specifier -> ENUM { enumerator_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; 
enum_specifier -> ENUM IDENTIFIER 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; 
conditional_expression -> logical_or_expression ? expression : conditional_expression 	0
; 
conditional_expression -> logical_or_expression 	0
; 
primary_expression -> IDENTIFIER 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
unary_expression -> DEC_OP unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
unary_expression -> SIZEOF ( type_name ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
unary_expression -> postfix_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
unary_expression -> INC_OP unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
unary_expression -> unary_operator cast_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
unary_expression -> SIZEOF unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
struct_or_union -> STRUCT 	0
{ IDENTIFIER 
struct_or_union -> UNION 	0
{ IDENTIFIER 
logical_or_expression -> logical_or_expression OR_OP logical_and_expression 	0
OR_OP ? ; 
logical_or_expression -> logical_and_expression 	0
OR_OP ? ; 
postfix_expression -> postfix_expression . IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> primary_expression 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression ( ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression INC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
logical_and_expression -> inclusive_or_expression 	0
? OR_OP ; AND_OP 
logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression 	0
? OR_OP ; AND_OP 
primary_expression -> CONSTANT 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
primary_expression -> ( expression ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
primary_expression -> STRING_LITERAL 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression 	0
OR_OP ? ; | 
exclusive_or_expression -> and_expression 	0
? OR_OP ; ^ 
and_expression -> equality_expression 	0
OR_OP ? ; & 
equality_expression -> equality_expression EQ_OP relational_expression 	0
NE_OP ? OR_OP ; EQ_OP 
equality_expression -> relational_expression 	0
NE_OP ? OR_OP ; EQ_OP 
equality_expression -> equality_expression NE_OP relational_expression 	0
NE_OP ? OR_OP ; EQ_OP 
relational_expression -> shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression < shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression > shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression LE_OP shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression GE_OP shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
shift_expression -> additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP < RIGHT_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP < RIGHT_OP 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP < RIGHT_OP 
additive_expression -> multiplicative_expression 	0
OR_OP ? + ; < EQ_OP - 
additive_expression -> additive_expression - multiplicative_expression 	0
OR_OP ? + ; < EQ_OP - 
multiplicative_expression -> cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
cast_expression -> ( type_name ) cast_expression 	0
OR_OP ? ; < EQ_OP * 
cast_expression -> unary_expression 	0
OR_OP ? ; < EQ_OP * 

57 1
function_definition -> declarator compound_statement 	2
LONG $ STATIC INT IDENTIFIER SHORT SIGNED TYPE_NAME VOLATILE FLOAT REGISTER STRUCT CONST UNION * CHAR UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID ENUM 

58 1
declaration_list -> declaration 	1
; { STRUCT REGISTER SHORT SIGNED TYPE_NAME VOLATILE STATIC STRING_LITERAL TYPEDEF DO CONST UNION EXTERN AUTO DOUBLE RETURN VOID * CHAR FLOAT DEFAULT IDENTIFIER INT DEC_OP LONG IF UNSIGNED ENUM } WHILE GOTO CASE BREAK - FOR CONTINUE SIZEOF INC_OP SWITCH CONSTANT ( & ~ + ! 

59 19
declaration -> declaration_specifiers init_declarator_list ; 	1
{ ; BREAK - } INT IDENTIFIER DEFAULT WHILE GOTO CASE FOR VOID RETURN CONTINUE UNION CONST DO SIZEOF INC_OP LONG DEC_OP TYPEDEF STRING_LITERAL UNSIGNED IF SWITCH CONSTANT ( & CHAR * ~ + ! REGISTER STRUCT SHORT TYPE_NAME SIGNED VOLATILE STATIC EXTERN AUTO DOUBLE FLOAT ENUM 
declarator -> pointer direct_declarator 	0
; = 
init_declarator_list -> init_declarator 	0
; , 
init_declarator -> declarator 	0
; 
pointer -> * pointer 	0
IDENTIFIER ( 
init_declarator -> declarator = initializer 	0
; 
declaration -> declaration_specifiers ; 	1
{ ; BREAK - } INT IDENTIFIER DEFAULT WHILE GOTO CASE FOR VOID RETURN CONTINUE UNION CONST DO SIZEOF INC_OP LONG DEC_OP TYPEDEF STRING_LITERAL UNSIGNED IF SWITCH CONSTANT ( & CHAR * ~ + ! REGISTER STRUCT SHORT TYPE_NAME SIGNED VOLATILE STATIC EXTERN AUTO DOUBLE FLOAT ENUM 
direct_declarator -> direct_declarator ( parameter_type_list ) 	0
[ ; = ( 
init_declarator_list -> init_declarator_list , init_declarator 	0
; , 
declarator -> direct_declarator 	0
; = 
direct_declarator -> direct_declarator ( ) 	0
[ ; = ( 
pointer -> * 	0
IDENTIFIER ( 
pointer -> * type_qualifier_list 	0
IDENTIFIER ( 
pointer -> * type_qualifier_list pointer 	0
IDENTIFIER ( 
direct_declarator -> ( declarator ) 	0
[ ; = ( 
direct_declarator -> IDENTIFIER 	0
[ ; = ( 
direct_declarator -> direct_declarator [ ] 	0
[ ; = ( 
direct_declarator -> direct_declarator [ constant_expression ] 	0
[ ; = ( 
direct_declarator -> direct_declarator ( identifier_list ) 	0
[ ; = ( 

60 41
declaration -> declaration_specifiers ; 	0
{ STRUCT REGISTER VOLATILE SIGNED TYPE_NAME SHORT STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM 
declaration_list -> declaration_list declaration 	1
{ STRUCT REGISTER SHORT SIGNED TYPE_NAME VOLATILE STATIC TYPEDEF CONST UNION EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM 
function_definition -> declarator declaration_list compound_statement 	2
LONG $ STATIC INT IDENTIFIER SHORT SIGNED TYPE_NAME VOLATILE FLOAT REGISTER STRUCT CONST UNION * CHAR UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID ENUM 
compound_statement -> { declaration_list statement_list } 	0
STATIC LONG $ INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT FLOAT STRUCT REGISTER UNION CONST CHAR * UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID ENUM 
storage_class_specifier -> REGISTER 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
declaration -> declaration_specifiers init_declarator_list ; 	0
{ STRUCT REGISTER VOLATILE SIGNED TYPE_NAME SHORT STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM 
compound_statement -> { declaration_list } 	0
STATIC LONG $ INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT FLOAT STRUCT REGISTER UNION CONST CHAR * UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID ENUM 
compound_statement -> { statement_list } 	0
STATIC LONG $ INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT FLOAT STRUCT REGISTER UNION CONST CHAR * UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID ENUM 
declaration_specifiers -> type_specifier declaration_specifiers 	0
IDENTIFIER * ( ; 
type_specifier -> struct_or_union_specifier 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
declaration_specifiers -> storage_class_specifier 	0
IDENTIFIER * ( ; 
compound_statement -> { } 	0
STATIC LONG $ INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT FLOAT STRUCT REGISTER UNION CONST CHAR * UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID ENUM 
declaration_specifiers -> type_specifier 	0
IDENTIFIER * ( ; 
declaration_specifiers -> storage_class_specifier declaration_specifiers 	0
IDENTIFIER * ( ; 
type_specifier -> SIGNED 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
declaration_specifiers -> type_qualifier 	0
IDENTIFIER * ( ; 
declaration_specifiers -> type_qualifier declaration_specifiers 	0
IDENTIFIER * ( ; 
type_specifier -> CHAR 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
storage_class_specifier -> STATIC 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
type_specifier -> FLOAT 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_specifier -> TYPE_NAME 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
storage_class_specifier -> EXTERN 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
type_specifier -> SHORT 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_specifier -> LONG 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_specifier -> VOID 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_specifier -> INT 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_specifier -> DOUBLE 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_specifier -> UNSIGNED 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_specifier -> enum_specifier 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_qualifier -> CONST 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
storage_class_specifier -> AUTO 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
enum_specifier -> ENUM { enumerator_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; 
storage_class_specifier -> TYPEDEF 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
type_qualifier -> VOLATILE 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
struct_or_union_specifier -> struct_or_union { struct_declaration_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; 
enum_specifier -> ENUM IDENTIFIER { enumerator_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; 
struct_or_union_specifier -> struct_or_union IDENTIFIER { struct_declaration_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; 
struct_or_union_specifier -> struct_or_union IDENTIFIER 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; 
enum_specifier -> ENUM IDENTIFIER 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; 
struct_or_union -> STRUCT 	0
{ IDENTIFIER 
struct_or_union -> UNION 	0
{ IDENTIFIER 

61 6
direct_declarator -> direct_declarator ( parameter_type_list ) 	1
( ; { [ VOLATILE SIGNED TYPE_NAME SHORT REGISTER STRUCT STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ) = , : 
declarator -> pointer direct_declarator 	2
; { VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ) = , : 
direct_declarator -> direct_declarator [ ] 	1
( ; { [ VOLATILE SIGNED TYPE_NAME SHORT REGISTER STRUCT STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ) = , : 
direct_declarator -> direct_declarator [ constant_expression ] 	1
( ; { [ VOLATILE SIGNED TYPE_NAME SHORT REGISTER STRUCT STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ) = , : 
direct_declarator -> direct_declarator ( identifier_list ) 	1
( ; { [ VOLATILE SIGNED TYPE_NAME SHORT REGISTER STRUCT STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ) = , : 
direct_declarator -> direct_declarator ( ) 	1
( ; { [ VOLATILE SIGNED TYPE_NAME SHORT REGISTER STRUCT STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ) = , : 

62 1
direct_declarator -> ( declarator ) 	3
; { VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ ) = , : 

63 1
type_qualifier_list -> type_qualifier_list type_qualifier 	2
VOLATILE * CONST ) IDENTIFIER ( [ , 

64 1
pointer -> * type_qualifier_list pointer 	3
IDENTIFIER ( [ ) , 

65 5
enum_specifier -> ENUM IDENTIFIER { enumerator_list } 	3
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; : [ ) , 
enumerator_list -> enumerator_list , enumerator 	0
} , 
enumerator_list -> enumerator 	0
} , 
enumerator -> IDENTIFIER = constant_expression 	0
} 
enumerator -> IDENTIFIER 	0
} 

66 2
enumerator -> IDENTIFIER = constant_expression 	1
} , 
enumerator -> IDENTIFIER 	1
} , 

67 2
enumerator_list -> enumerator_list , enumerator 	1
} , 
enum_specifier -> ENUM { enumerator_list } 	3
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; : [ ) , 

68 1
enumerator_list -> enumerator 	1
} , 

69 30
struct_or_union_specifier -> struct_or_union IDENTIFIER { struct_declaration_list } 	3
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; : [ ) , 
specifier_qualifier_list -> type_specifier specifier_qualifier_list 	0
* : IDENTIFIER ( 
struct_declaration_list -> struct_declaration 	0
DOUBLE } FLOAT CHAR SIGNED TYPE_NAME SHORT VOID INT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> CHAR 	0
* CHAR SHORT SIGNED TYPE_NAME : INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
specifier_qualifier_list -> type_qualifier 	0
* : IDENTIFIER ( 
struct_declaration_list -> struct_declaration_list struct_declaration 	0
DOUBLE } FLOAT CHAR SIGNED TYPE_NAME SHORT VOID INT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_qualifier -> VOLATILE 	0
TYPE_NAME SIGNED FLOAT * CHAR SHORT VOID DOUBLE IDENTIFIER INT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT : ( 
specifier_qualifier_list -> type_specifier 	0
* : IDENTIFIER ( 
specifier_qualifier_list -> type_qualifier specifier_qualifier_list 	0
* : IDENTIFIER ( 
struct_declaration -> specifier_qualifier_list struct_declarator_list ; 	0
} 
type_qualifier -> CONST 	0
TYPE_NAME SIGNED FLOAT * CHAR SHORT VOID DOUBLE IDENTIFIER INT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT : ( 
type_specifier -> FLOAT 	0
* CHAR SHORT SIGNED TYPE_NAME : INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> TYPE_NAME 	0
* CHAR SHORT SIGNED TYPE_NAME : INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> SHORT 	0
* CHAR SHORT SIGNED TYPE_NAME : INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> VOID 	0
* CHAR SHORT SIGNED TYPE_NAME : INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> LONG 	0
* CHAR SHORT SIGNED TYPE_NAME : INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> INT 	0
* CHAR SHORT SIGNED TYPE_NAME : INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> DOUBLE 	0
* CHAR SHORT SIGNED TYPE_NAME : INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> SIGNED 	0
* CHAR SHORT SIGNED TYPE_NAME : INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> UNSIGNED 	0
* CHAR SHORT SIGNED TYPE_NAME : INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> struct_or_union_specifier 	0
* CHAR SHORT SIGNED TYPE_NAME : INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> enum_specifier 	0
* CHAR SHORT SIGNED TYPE_NAME : INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
struct_or_union_specifier -> struct_or_union { struct_declaration_list } 	0
: SIGNED TYPE_NAME SHORT * CHAR INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 
struct_or_union_specifier -> struct_or_union IDENTIFIER { struct_declaration_list } 	0
: SIGNED TYPE_NAME SHORT * CHAR INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 
enum_specifier -> ENUM IDENTIFIER { enumerator_list } 	0
: SIGNED TYPE_NAME SHORT * CHAR INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 
struct_or_union_specifier -> struct_or_union IDENTIFIER 	0
: SIGNED TYPE_NAME SHORT * CHAR INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 
enum_specifier -> ENUM { enumerator_list } 	0
: SIGNED TYPE_NAME SHORT * CHAR INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 
enum_specifier -> ENUM IDENTIFIER 	0
: SIGNED TYPE_NAME SHORT * CHAR INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 
struct_or_union -> STRUCT 	0
{ IDENTIFIER 
struct_or_union -> UNION 	0
{ IDENTIFIER 

70 1
struct_declaration_list -> struct_declaration 	1
} DOUBLE SHORT SIGNED TYPE_NAME CHAR FLOAT VOID INT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 

71 28
specifier_qualifier_list -> type_specifier specifier_qualifier_list 	1
: * IDENTIFIER ( [ ) 
struct_or_union -> UNION 	0
{ IDENTIFIER 
specifier_qualifier_list -> type_specifier 	1
: * IDENTIFIER ( [ ) 
type_qualifier -> VOLATILE 	0
TYPE_NAME SIGNED FLOAT * CHAR SHORT VOID DOUBLE IDENTIFIER INT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT : ( [ ) 
specifier_qualifier_list -> type_specifier 	0
* : IDENTIFIER ( [ ) 
specifier_qualifier_list -> type_qualifier specifier_qualifier_list 	0
* : IDENTIFIER ( [ ) 
type_specifier -> CHAR 	0
SHORT SIGNED TYPE_NAME : CHAR * INT IDENTIFIER VOID ( [ ) DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
specifier_qualifier_list -> type_specifier specifier_qualifier_list 	0
* : IDENTIFIER ( [ ) 
specifier_qualifier_list -> type_qualifier 	0
* : IDENTIFIER ( [ ) 
type_qualifier -> CONST 	0
TYPE_NAME SIGNED FLOAT * CHAR SHORT VOID DOUBLE IDENTIFIER INT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT : ( [ ) 
type_specifier -> FLOAT 	0
SHORT SIGNED TYPE_NAME : CHAR * INT IDENTIFIER VOID ( [ ) DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> TYPE_NAME 	0
SHORT SIGNED TYPE_NAME : CHAR * INT IDENTIFIER VOID ( [ ) DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> SHORT 	0
SHORT SIGNED TYPE_NAME : CHAR * INT IDENTIFIER VOID ( [ ) DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> VOID 	0
SHORT SIGNED TYPE_NAME : CHAR * INT IDENTIFIER VOID ( [ ) DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> LONG 	0
SHORT SIGNED TYPE_NAME : CHAR * INT IDENTIFIER VOID ( [ ) DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> INT 	0
SHORT SIGNED TYPE_NAME : CHAR * INT IDENTIFIER VOID ( [ ) DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> DOUBLE 	0
SHORT SIGNED TYPE_NAME : CHAR * INT IDENTIFIER VOID ( [ ) DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> SIGNED 	0
SHORT SIGNED TYPE_NAME : CHAR * INT IDENTIFIER VOID ( [ ) DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> UNSIGNED 	0
SHORT SIGNED TYPE_NAME : CHAR * INT IDENTIFIER VOID ( [ ) DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> struct_or_union_specifier 	0
SHORT SIGNED TYPE_NAME : CHAR * INT IDENTIFIER VOID ( [ ) DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> enum_specifier 	0
SHORT SIGNED TYPE_NAME : CHAR * INT IDENTIFIER VOID ( [ ) DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
struct_or_union_specifier -> struct_or_union { struct_declaration_list } 	0
CHAR * : SIGNED TYPE_NAME SHORT INT IDENTIFIER VOID ( [ ) DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 
struct_or_union_specifier -> struct_or_union IDENTIFIER { struct_declaration_list } 	0
CHAR * : SIGNED TYPE_NAME SHORT INT IDENTIFIER VOID ( [ ) DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 
enum_specifier -> ENUM IDENTIFIER { enumerator_list } 	0
CHAR * : SIGNED TYPE_NAME SHORT INT IDENTIFIER VOID ( [ ) DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 
struct_or_union_specifier -> struct_or_union IDENTIFIER 	0
CHAR * : SIGNED TYPE_NAME SHORT INT IDENTIFIER VOID ( [ ) DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 
enum_specifier -> ENUM { enumerator_list } 	0
CHAR * : SIGNED TYPE_NAME SHORT INT IDENTIFIER VOID ( [ ) DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 
enum_specifier -> ENUM IDENTIFIER 	0
CHAR * : SIGNED TYPE_NAME SHORT INT IDENTIFIER VOID ( [ ) DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 
struct_or_union -> STRUCT 	0
{ IDENTIFIER 

72 28
specifier_qualifier_list -> type_qualifier 	1
: * IDENTIFIER ( [ ) 
specifier_qualifier_list -> type_qualifier specifier_qualifier_list 	1
: * IDENTIFIER ( [ ) 
type_qualifier -> VOLATILE 	0
TYPE_NAME SIGNED FLOAT * CHAR SHORT VOID DOUBLE IDENTIFIER INT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT : ( [ ) 
specifier_qualifier_list -> type_specifier 	0
* : IDENTIFIER ( [ ) 
specifier_qualifier_list -> type_qualifier specifier_qualifier_list 	0
* : IDENTIFIER ( [ ) 
type_specifier -> CHAR 	0
SHORT SIGNED TYPE_NAME : CHAR * INT IDENTIFIER VOID ( [ ) DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
specifier_qualifier_list -> type_specifier specifier_qualifier_list 	0
* : IDENTIFIER ( [ ) 
specifier_qualifier_list -> type_qualifier 	0
* : IDENTIFIER ( [ ) 
type_qualifier -> CONST 	0
TYPE_NAME SIGNED FLOAT * CHAR SHORT VOID DOUBLE IDENTIFIER INT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT : ( [ ) 
type_specifier -> FLOAT 	0
SHORT SIGNED TYPE_NAME : CHAR * INT IDENTIFIER VOID ( [ ) DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> TYPE_NAME 	0
SHORT SIGNED TYPE_NAME : CHAR * INT IDENTIFIER VOID ( [ ) DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> SHORT 	0
SHORT SIGNED TYPE_NAME : CHAR * INT IDENTIFIER VOID ( [ ) DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> VOID 	0
SHORT SIGNED TYPE_NAME : CHAR * INT IDENTIFIER VOID ( [ ) DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> LONG 	0
SHORT SIGNED TYPE_NAME : CHAR * INT IDENTIFIER VOID ( [ ) DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> INT 	0
SHORT SIGNED TYPE_NAME : CHAR * INT IDENTIFIER VOID ( [ ) DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> DOUBLE 	0
SHORT SIGNED TYPE_NAME : CHAR * INT IDENTIFIER VOID ( [ ) DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> SIGNED 	0
SHORT SIGNED TYPE_NAME : CHAR * INT IDENTIFIER VOID ( [ ) DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> UNSIGNED 	0
SHORT SIGNED TYPE_NAME : CHAR * INT IDENTIFIER VOID ( [ ) DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> struct_or_union_specifier 	0
SHORT SIGNED TYPE_NAME : CHAR * INT IDENTIFIER VOID ( [ ) DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> enum_specifier 	0
SHORT SIGNED TYPE_NAME : CHAR * INT IDENTIFIER VOID ( [ ) DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
struct_or_union_specifier -> struct_or_union { struct_declaration_list } 	0
CHAR * : SIGNED TYPE_NAME SHORT INT IDENTIFIER VOID ( [ ) DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 
struct_or_union_specifier -> struct_or_union IDENTIFIER { struct_declaration_list } 	0
CHAR * : SIGNED TYPE_NAME SHORT INT IDENTIFIER VOID ( [ ) DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 
enum_specifier -> ENUM IDENTIFIER { enumerator_list } 	0
CHAR * : SIGNED TYPE_NAME SHORT INT IDENTIFIER VOID ( [ ) DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 
struct_or_union_specifier -> struct_or_union IDENTIFIER 	0
CHAR * : SIGNED TYPE_NAME SHORT INT IDENTIFIER VOID ( [ ) DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 
enum_specifier -> ENUM { enumerator_list } 	0
CHAR * : SIGNED TYPE_NAME SHORT INT IDENTIFIER VOID ( [ ) DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 
enum_specifier -> ENUM IDENTIFIER 	0
CHAR * : SIGNED TYPE_NAME SHORT INT IDENTIFIER VOID ( [ ) DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 
struct_or_union -> STRUCT 	0
{ IDENTIFIER 
struct_or_union -> UNION 	0
{ IDENTIFIER 

73 29
struct_or_union_specifier -> struct_or_union { struct_declaration_list } 	3
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; : [ ) , 
type_qualifier -> VOLATILE 	0
TYPE_NAME SIGNED FLOAT * CHAR SHORT VOID DOUBLE IDENTIFIER INT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT : ( 
specifier_qualifier_list -> type_specifier 	0
* : IDENTIFIER ( 
specifier_qualifier_list -> type_qualifier specifier_qualifier_list 	0
* : IDENTIFIER ( 
struct_declaration -> specifier_qualifier_list struct_declarator_list ; 	0
DOUBLE } FLOAT CHAR SIGNED TYPE_NAME SHORT VOID INT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
struct_declaration_list -> struct_declaration_list struct_declaration 	1
} DOUBLE SHORT SIGNED TYPE_NAME CHAR FLOAT VOID INT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 
type_specifier -> struct_or_union_specifier 	0
* CHAR SHORT SIGNED TYPE_NAME : INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
specifier_qualifier_list -> type_specifier specifier_qualifier_list 	0
* : IDENTIFIER ( 
type_specifier -> CHAR 	0
* CHAR SHORT SIGNED TYPE_NAME : INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
specifier_qualifier_list -> type_qualifier 	0
* : IDENTIFIER ( 
type_qualifier -> CONST 	0
TYPE_NAME SIGNED FLOAT * CHAR SHORT VOID DOUBLE IDENTIFIER INT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT : ( 
type_specifier -> FLOAT 	0
* CHAR SHORT SIGNED TYPE_NAME : INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> TYPE_NAME 	0
* CHAR SHORT SIGNED TYPE_NAME : INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> SHORT 	0
* CHAR SHORT SIGNED TYPE_NAME : INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> VOID 	0
* CHAR SHORT SIGNED TYPE_NAME : INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> LONG 	0
* CHAR SHORT SIGNED TYPE_NAME : INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> INT 	0
* CHAR SHORT SIGNED TYPE_NAME : INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> DOUBLE 	0
* CHAR SHORT SIGNED TYPE_NAME : INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> SIGNED 	0
* CHAR SHORT SIGNED TYPE_NAME : INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> UNSIGNED 	0
* CHAR SHORT SIGNED TYPE_NAME : INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> enum_specifier 	0
* CHAR SHORT SIGNED TYPE_NAME : INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
struct_or_union_specifier -> struct_or_union { struct_declaration_list } 	0
: SIGNED TYPE_NAME SHORT * CHAR INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 
struct_or_union_specifier -> struct_or_union IDENTIFIER { struct_declaration_list } 	0
: SIGNED TYPE_NAME SHORT * CHAR INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 
enum_specifier -> ENUM IDENTIFIER { enumerator_list } 	0
: SIGNED TYPE_NAME SHORT * CHAR INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 
struct_or_union_specifier -> struct_or_union IDENTIFIER 	0
: SIGNED TYPE_NAME SHORT * CHAR INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 
enum_specifier -> ENUM { enumerator_list } 	0
: SIGNED TYPE_NAME SHORT * CHAR INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 
enum_specifier -> ENUM IDENTIFIER 	0
: SIGNED TYPE_NAME SHORT * CHAR INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 
struct_or_union -> STRUCT 	0
{ IDENTIFIER 
struct_or_union -> UNION 	0
{ IDENTIFIER 

74 19
struct_declarator -> : constant_expression 	0
; , 
struct_declaration -> specifier_qualifier_list struct_declarator_list ; 	1
DOUBLE } FLOAT CHAR SIGNED TYPE_NAME SHORT VOID INT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
declarator -> pointer direct_declarator 	0
; , : 
struct_declarator_list -> struct_declarator_list , struct_declarator 	0
; , 
struct_declarator -> declarator : constant_expression 	0
; , 
pointer -> * 	0
IDENTIFIER ( 
struct_declarator_list -> struct_declarator 	0
; , 
direct_declarator -> direct_declarator ( ) 	0
[ ; , : ( 
struct_declarator -> declarator 	0
; , 
declarator -> direct_declarator 	0
; , : 
pointer -> * type_qualifier_list 	0
IDENTIFIER ( 
pointer -> * pointer 	0
IDENTIFIER ( 
pointer -> * type_qualifier_list pointer 	0
IDENTIFIER ( 
direct_declarator -> ( declarator ) 	0
[ ; , : ( 
direct_declarator -> IDENTIFIER 	0
[ ; , : ( 
direct_declarator -> direct_declarator ( parameter_type_list ) 	0
[ ; , : ( 
direct_declarator -> direct_declarator [ ] 	0
[ ; , : ( 
direct_declarator -> direct_declarator [ constant_expression ] 	0
[ ; , : ( 
direct_declarator -> direct_declarator ( identifier_list ) 	0
[ ; , : ( 

75 1
identifier_list -> IDENTIFIER 	1
) , 

76 1
direct_declarator -> direct_declarator ( ) 	3
; { VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ ) = , : 

77 28
abstract_declarator -> direct_abstract_declarator 	0
) , 
parameter_declaration -> declaration_specifiers declarator 	1
) , 
parameter_declaration -> declaration_specifiers abstract_declarator 	1
) , 
declarator -> pointer direct_declarator 	0
) , 
parameter_declaration -> declaration_specifiers 	1
) , 
direct_declarator -> ( declarator ) 	0
) , ( [ 
direct_abstract_declarator -> ( ) 	0
) , ( [ 
declarator -> direct_declarator 	0
) , 
abstract_declarator -> pointer direct_abstract_declarator 	0
) , 
pointer -> * 	0
IDENTIFIER ( [ ) , 
direct_declarator -> direct_declarator ( ) 	0
) , ( [ 
direct_abstract_declarator -> direct_abstract_declarator [ constant_expression ] 	0
) , ( [ 
abstract_declarator -> pointer 	0
) , 
pointer -> * type_qualifier_list 	0
IDENTIFIER ( [ ) , 
pointer -> * pointer 	0
IDENTIFIER ( [ ) , 
pointer -> * type_qualifier_list pointer 	0
IDENTIFIER ( [ ) , 
direct_abstract_declarator -> ( parameter_type_list ) 	0
) , ( [ 
direct_declarator -> IDENTIFIER 	0
) , ( [ 
direct_abstract_declarator -> direct_abstract_declarator [ ] 	0
) , ( [ 
direct_declarator -> direct_declarator ( parameter_type_list ) 	0
) , ( [ 
direct_declarator -> direct_declarator [ ] 	0
) , ( [ 
direct_declarator -> direct_declarator [ constant_expression ] 	0
) , ( [ 
direct_abstract_declarator -> ( abstract_declarator ) 	0
) , ( [ 
direct_declarator -> direct_declarator ( identifier_list ) 	0
) , ( [ 
direct_abstract_declarator -> direct_abstract_declarator ( parameter_type_list ) 	0
) , ( [ 
direct_abstract_declarator -> [ ] 	0
) , ( [ 
direct_abstract_declarator -> [ constant_expression ] 	0
) , ( [ 
direct_abstract_declarator -> direct_abstract_declarator ( ) 	0
) , ( [ 

78 2
identifier_list -> identifier_list , IDENTIFIER 	1
) , 
direct_declarator -> direct_declarator ( identifier_list ) 	3
; { VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ ) = , : 

79 1
direct_declarator -> direct_declarator ( parameter_type_list ) 	3
; { VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ ) = , : 

80 3
parameter_type_list -> parameter_list 	1
) 
parameter_type_list -> parameter_list , ELLIPSIS 	1
) 
parameter_list -> parameter_list , parameter_declaration 	1
) , 

81 1
parameter_list -> parameter_declaration 	1
) , 

82 25
unary_expression -> DEC_OP unary_expression 	1
? OR_OP ] | < MUL_ASSIGN EQ_OP GE_OP MOD_ASSIGN * ) LEFT_ASSIGN DIV_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
postfix_expression -> primary_expression 	0
? OR_OP ] | < MUL_ASSIGN EQ_OP GE_OP MOD_ASSIGN * ) LEFT_ASSIGN DIV_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
? OR_OP ] | < MUL_ASSIGN EQ_OP GE_OP MOD_ASSIGN * ) LEFT_ASSIGN DIV_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
unary_expression -> INC_OP unary_expression 	0
? OR_OP ] MUL_ASSIGN EQ_OP | < GE_OP MOD_ASSIGN * LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
unary_expression -> unary_operator cast_expression 	0
? OR_OP ] MUL_ASSIGN EQ_OP | < GE_OP MOD_ASSIGN * LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
unary_expression -> postfix_expression 	0
? OR_OP ] MUL_ASSIGN EQ_OP | < GE_OP MOD_ASSIGN * LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
unary_expression -> DEC_OP unary_expression 	0
? OR_OP ] MUL_ASSIGN EQ_OP | < GE_OP MOD_ASSIGN * LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
primary_expression -> IDENTIFIER 	0
? OR_OP ] MUL_ASSIGN EQ_OP | < GE_OP MOD_ASSIGN * LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( 
unary_expression -> SIZEOF ( type_name ) 	0
? OR_OP ] MUL_ASSIGN EQ_OP | < GE_OP MOD_ASSIGN * LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
unary_expression -> SIZEOF unary_expression 	0
? OR_OP ] MUL_ASSIGN EQ_OP | < GE_OP MOD_ASSIGN * LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
postfix_expression -> postfix_expression . IDENTIFIER 	0
? OR_OP ] | < MUL_ASSIGN EQ_OP GE_OP MOD_ASSIGN * ) LEFT_ASSIGN DIV_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression ( ) 	0
? OR_OP ] | < MUL_ASSIGN EQ_OP GE_OP MOD_ASSIGN * ) LEFT_ASSIGN DIV_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
? OR_OP ] | < MUL_ASSIGN EQ_OP GE_OP MOD_ASSIGN * ) LEFT_ASSIGN DIV_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression INC_OP 	0
? OR_OP ] | < MUL_ASSIGN EQ_OP GE_OP MOD_ASSIGN * ) LEFT_ASSIGN DIV_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
? OR_OP ] | < MUL_ASSIGN EQ_OP GE_OP MOD_ASSIGN * ) LEFT_ASSIGN DIV_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
? OR_OP ] | < MUL_ASSIGN EQ_OP GE_OP MOD_ASSIGN * ) LEFT_ASSIGN DIV_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
primary_expression -> CONSTANT 	0
? OR_OP ] MUL_ASSIGN EQ_OP | < GE_OP MOD_ASSIGN * LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( 
primary_expression -> ( expression ) 	0
? OR_OP ] MUL_ASSIGN EQ_OP | < GE_OP MOD_ASSIGN * LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( 
primary_expression -> STRING_LITERAL 	0
? OR_OP ] MUL_ASSIGN EQ_OP | < GE_OP MOD_ASSIGN * LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( 

83 1
primary_expression -> IDENTIFIER 	1
? OR_OP ] | < MUL_ASSIGN EQ_OP * . ( DIV_ASSIGN ) LEFT_ASSIGN GE_OP MOD_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 

84 1
primary_expression -> CONSTANT 	1
? OR_OP ] | < MUL_ASSIGN EQ_OP * . ( DIV_ASSIGN ) LEFT_ASSIGN GE_OP MOD_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 

85 1
primary_expression -> STRING_LITERAL 	1
? OR_OP ] | < MUL_ASSIGN EQ_OP * . ( DIV_ASSIGN ) LEFT_ASSIGN GE_OP MOD_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 

86 90
struct_or_union_specifier -> struct_or_union { struct_declaration_list } 	0
SIGNED TYPE_NAME SHORT * CHAR ( VOID [ ) DOUBLE INT FLOAT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 
type_name -> specifier_qualifier_list 	0
) 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
cast_expression -> ( type_name ) cast_expression 	1
OR_OP ? ] MUL_ASSIGN EQ_OP | < : * XOR_ASSIGN ; LEFT_ASSIGN ) = ADD_ASSIGN } , GE_OP MOD_ASSIGN DIV_ASSIGN RIGHT_ASSIGN SUB_ASSIGN AND_ASSIGN OR_ASSIGN / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
specifier_qualifier_list -> type_specifier 	0
* ( [ ) 
postfix_expression -> postfix_expression ( ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
specifier_qualifier_list -> type_qualifier specifier_qualifier_list 	0
* ( [ ) 
conditional_expression -> logical_or_expression ? expression : conditional_expression 	0
) 
primary_expression -> ( expression ) 	1
? OR_OP ] | < MUL_ASSIGN EQ_OP * . ( DIV_ASSIGN ) LEFT_ASSIGN GE_OP MOD_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
type_name -> specifier_qualifier_list abstract_declarator 	0
) 
unary_expression -> INC_OP unary_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
primary_expression -> STRING_LITERAL 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
expression -> expression , assignment_expression 	0
) , 
primary_expression -> ( expression ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
enum_specifier -> ENUM { enumerator_list } 	0
SIGNED TYPE_NAME SHORT * CHAR ( VOID [ ) DOUBLE INT FLOAT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 
expression -> assignment_expression 	0
) , 
specifier_qualifier_list -> type_qualifier 	0
* ( [ ) 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
type_specifier -> CHAR 	0
* CHAR SHORT SIGNED TYPE_NAME VOID ( [ ) DOUBLE INT FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
specifier_qualifier_list -> type_specifier specifier_qualifier_list 	0
* ( [ ) 
type_specifier -> FLOAT 	0
* CHAR SHORT SIGNED TYPE_NAME VOID ( [ ) DOUBLE INT FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
assignment_expression -> conditional_expression 	0
) 
assignment_expression -> unary_expression assignment_operator assignment_expression 	0
) 
postfix_expression -> postfix_expression . IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
conditional_expression -> logical_or_expression 	0
) 
type_qualifier -> VOLATILE 	0
TYPE_NAME SIGNED FLOAT * CHAR SHORT VOID DOUBLE INT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT ( [ ) 
inclusive_or_expression -> exclusive_or_expression 	0
OR_OP ? ) | 
type_qualifier -> CONST 	0
TYPE_NAME SIGNED FLOAT * CHAR SHORT VOID DOUBLE INT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT ( [ ) 
type_specifier -> TYPE_NAME 	0
* CHAR SHORT SIGNED TYPE_NAME VOID ( [ ) DOUBLE INT FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
postfix_expression -> primary_expression 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
type_specifier -> SHORT 	0
* CHAR SHORT SIGNED TYPE_NAME VOID ( [ ) DOUBLE INT FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
type_specifier -> LONG 	0
* CHAR SHORT SIGNED TYPE_NAME VOID ( [ ) DOUBLE INT FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> VOID 	0
* CHAR SHORT SIGNED TYPE_NAME VOID ( [ ) DOUBLE INT FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
unary_expression -> postfix_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
type_specifier -> INT 	0
* CHAR SHORT SIGNED TYPE_NAME VOID ( [ ) DOUBLE INT FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> DOUBLE 	0
* CHAR SHORT SIGNED TYPE_NAME VOID ( [ ) DOUBLE INT FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
logical_or_expression -> logical_or_expression OR_OP logical_and_expression 	0
OR_OP ? ) 
type_specifier -> SIGNED 	0
* CHAR SHORT SIGNED TYPE_NAME VOID ( [ ) DOUBLE INT FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> UNSIGNED 	0
* CHAR SHORT SIGNED TYPE_NAME VOID ( [ ) DOUBLE INT FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> struct_or_union_specifier 	0
* CHAR SHORT SIGNED TYPE_NAME VOID ( [ ) DOUBLE INT FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> enum_specifier 	0
* CHAR SHORT SIGNED TYPE_NAME VOID ( [ ) DOUBLE INT FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
primary_expression -> IDENTIFIER 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
unary_expression -> DEC_OP unary_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
unary_expression -> SIZEOF ( type_name ) 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
unary_expression -> unary_operator cast_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression 	0
? OR_OP AND_OP ) 
unary_expression -> SIZEOF unary_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
enum_specifier -> ENUM IDENTIFIER { enumerator_list } 	0
SIGNED TYPE_NAME SHORT * CHAR ( VOID [ ) DOUBLE INT FLOAT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 
struct_or_union_specifier -> struct_or_union IDENTIFIER { struct_declaration_list } 	0
SIGNED TYPE_NAME SHORT * CHAR ( VOID [ ) DOUBLE INT FLOAT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 
struct_or_union_specifier -> struct_or_union IDENTIFIER 	0
SIGNED TYPE_NAME SHORT * CHAR ( VOID [ ) DOUBLE INT FLOAT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 
enum_specifier -> ENUM IDENTIFIER 	0
SIGNED TYPE_NAME SHORT * CHAR ( VOID [ ) DOUBLE INT FLOAT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 
logical_or_expression -> logical_and_expression 	0
OR_OP ? ) 
postfix_expression -> postfix_expression INC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
struct_or_union -> STRUCT 	0
{ IDENTIFIER 
struct_or_union -> UNION 	0
{ IDENTIFIER 
logical_and_expression -> inclusive_or_expression 	0
? OR_OP AND_OP ) 
primary_expression -> CONSTANT 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression 	0
OR_OP ? ) | 
exclusive_or_expression -> and_expression 	0
? OR_OP ) ^ 
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	0
? OR_OP ) ^ 
and_expression -> equality_expression 	0
OR_OP ? ) & 
and_expression -> and_expression & equality_expression 	0
OR_OP ? ) & 
equality_expression -> equality_expression EQ_OP relational_expression 	0
NE_OP ? OR_OP ) EQ_OP 
equality_expression -> relational_expression 	0
NE_OP ? OR_OP ) EQ_OP 
equality_expression -> equality_expression NE_OP relational_expression 	0
NE_OP ? OR_OP ) EQ_OP 
relational_expression -> relational_expression < shift_expression 	0
OR_OP ? ) < EQ_OP > LE_OP GE_OP 
relational_expression -> shift_expression 	0
OR_OP ? ) < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression > shift_expression 	0
OR_OP ? ) < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression LE_OP shift_expression 	0
OR_OP ? ) < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression GE_OP shift_expression 	0
OR_OP ? ) < EQ_OP > LE_OP GE_OP 
shift_expression -> additive_expression 	0
? OR_OP ) EQ_OP < LEFT_OP RIGHT_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	0
? OR_OP ) EQ_OP < LEFT_OP RIGHT_OP 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
? OR_OP ) EQ_OP < LEFT_OP RIGHT_OP 
additive_expression -> multiplicative_expression 	0
OR_OP ? ) < EQ_OP + - 
additive_expression -> additive_expression + multiplicative_expression 	0
OR_OP ? ) < EQ_OP + - 
additive_expression -> additive_expression - multiplicative_expression 	0
OR_OP ? ) < EQ_OP + - 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
/ ? OR_OP ) EQ_OP < * % 
multiplicative_expression -> cast_expression 	0
/ ? OR_OP ) EQ_OP < * % 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
/ ? OR_OP ) EQ_OP < * % 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
/ ? OR_OP ) EQ_OP < * % 
cast_expression -> ( type_name ) cast_expression 	0
OR_OP ? ) < EQ_OP * 
cast_expression -> unary_expression 	0
OR_OP ? ) < EQ_OP * 

87 1
direct_declarator -> direct_declarator [ ] 	3
; { VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ ) = , : 

88 25
unary_expression -> INC_OP unary_expression 	1
? OR_OP ] | < MUL_ASSIGN EQ_OP GE_OP MOD_ASSIGN * ) LEFT_ASSIGN DIV_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
? OR_OP ] | < MUL_ASSIGN EQ_OP GE_OP MOD_ASSIGN * ) LEFT_ASSIGN DIV_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
unary_expression -> INC_OP unary_expression 	0
? OR_OP ] MUL_ASSIGN EQ_OP | < GE_OP MOD_ASSIGN * LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
unary_expression -> unary_operator cast_expression 	0
? OR_OP ] MUL_ASSIGN EQ_OP | < GE_OP MOD_ASSIGN * LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
unary_expression -> postfix_expression 	0
? OR_OP ] MUL_ASSIGN EQ_OP | < GE_OP MOD_ASSIGN * LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
unary_expression -> DEC_OP unary_expression 	0
? OR_OP ] MUL_ASSIGN EQ_OP | < GE_OP MOD_ASSIGN * LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
primary_expression -> IDENTIFIER 	0
? OR_OP ] MUL_ASSIGN EQ_OP | < GE_OP MOD_ASSIGN * LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( 
unary_expression -> SIZEOF ( type_name ) 	0
? OR_OP ] MUL_ASSIGN EQ_OP | < GE_OP MOD_ASSIGN * LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
unary_expression -> SIZEOF unary_expression 	0
? OR_OP ] MUL_ASSIGN EQ_OP | < GE_OP MOD_ASSIGN * LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
postfix_expression -> postfix_expression . IDENTIFIER 	0
? OR_OP ] | < MUL_ASSIGN EQ_OP GE_OP MOD_ASSIGN * ) LEFT_ASSIGN DIV_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> primary_expression 	0
? OR_OP ] | < MUL_ASSIGN EQ_OP GE_OP MOD_ASSIGN * ) LEFT_ASSIGN DIV_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression ( ) 	0
? OR_OP ] | < MUL_ASSIGN EQ_OP GE_OP MOD_ASSIGN * ) LEFT_ASSIGN DIV_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
? OR_OP ] | < MUL_ASSIGN EQ_OP GE_OP MOD_ASSIGN * ) LEFT_ASSIGN DIV_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression INC_OP 	0
? OR_OP ] | < MUL_ASSIGN EQ_OP GE_OP MOD_ASSIGN * ) LEFT_ASSIGN DIV_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
? OR_OP ] | < MUL_ASSIGN EQ_OP GE_OP MOD_ASSIGN * ) LEFT_ASSIGN DIV_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
? OR_OP ] | < MUL_ASSIGN EQ_OP GE_OP MOD_ASSIGN * ) LEFT_ASSIGN DIV_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
primary_expression -> CONSTANT 	0
? OR_OP ] MUL_ASSIGN EQ_OP | < GE_OP MOD_ASSIGN * LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( 
primary_expression -> ( expression ) 	0
? OR_OP ] MUL_ASSIGN EQ_OP | < GE_OP MOD_ASSIGN * LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( 
primary_expression -> STRING_LITERAL 	0
? OR_OP ] MUL_ASSIGN EQ_OP | < GE_OP MOD_ASSIGN * LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( 

89 26
postfix_expression -> postfix_expression . IDENTIFIER 	0
? OR_OP ] | < MUL_ASSIGN EQ_OP GE_OP MOD_ASSIGN * ) LEFT_ASSIGN DIV_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
unary_expression -> SIZEOF unary_expression 	1
? OR_OP ] | < MUL_ASSIGN EQ_OP GE_OP MOD_ASSIGN * ) LEFT_ASSIGN DIV_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
unary_expression -> SIZEOF unary_expression 	0
? OR_OP ] MUL_ASSIGN EQ_OP | < GE_OP MOD_ASSIGN * LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
unary_expression -> SIZEOF ( type_name ) 	1
? OR_OP ] | < MUL_ASSIGN EQ_OP GE_OP MOD_ASSIGN * ) LEFT_ASSIGN DIV_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_expression -> unary_operator cast_expression 	0
? OR_OP ] MUL_ASSIGN EQ_OP | < GE_OP MOD_ASSIGN * LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
unary_expression -> INC_OP unary_expression 	0
? OR_OP ] MUL_ASSIGN EQ_OP | < GE_OP MOD_ASSIGN * LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
? OR_OP ] | < MUL_ASSIGN EQ_OP GE_OP MOD_ASSIGN * ) LEFT_ASSIGN DIV_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
unary_expression -> postfix_expression 	0
? OR_OP ] MUL_ASSIGN EQ_OP | < GE_OP MOD_ASSIGN * LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
unary_expression -> DEC_OP unary_expression 	0
? OR_OP ] MUL_ASSIGN EQ_OP | < GE_OP MOD_ASSIGN * LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
primary_expression -> IDENTIFIER 	0
? OR_OP ] MUL_ASSIGN EQ_OP | < GE_OP MOD_ASSIGN * LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( 
unary_expression -> SIZEOF ( type_name ) 	0
? OR_OP ] MUL_ASSIGN EQ_OP | < GE_OP MOD_ASSIGN * LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
postfix_expression -> primary_expression 	0
? OR_OP ] | < MUL_ASSIGN EQ_OP GE_OP MOD_ASSIGN * ) LEFT_ASSIGN DIV_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression ( ) 	0
? OR_OP ] | < MUL_ASSIGN EQ_OP GE_OP MOD_ASSIGN * ) LEFT_ASSIGN DIV_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
? OR_OP ] | < MUL_ASSIGN EQ_OP GE_OP MOD_ASSIGN * ) LEFT_ASSIGN DIV_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression INC_OP 	0
? OR_OP ] | < MUL_ASSIGN EQ_OP GE_OP MOD_ASSIGN * ) LEFT_ASSIGN DIV_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
? OR_OP ] | < MUL_ASSIGN EQ_OP GE_OP MOD_ASSIGN * ) LEFT_ASSIGN DIV_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
? OR_OP ] | < MUL_ASSIGN EQ_OP GE_OP MOD_ASSIGN * ) LEFT_ASSIGN DIV_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
primary_expression -> CONSTANT 	0
? OR_OP ] MUL_ASSIGN EQ_OP | < GE_OP MOD_ASSIGN * LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( 
primary_expression -> ( expression ) 	0
? OR_OP ] MUL_ASSIGN EQ_OP | < GE_OP MOD_ASSIGN * LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( 
primary_expression -> STRING_LITERAL 	0
? OR_OP ] MUL_ASSIGN EQ_OP | < GE_OP MOD_ASSIGN * LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( 

90 1
unary_operator -> & 	1
& ( INC_OP SIZEOF CONSTANT - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 

91 1
unary_operator -> * 	1
& ( INC_OP SIZEOF CONSTANT - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 

92 1
unary_operator -> + 	1
& ( INC_OP SIZEOF CONSTANT - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 

93 1
unary_operator -> - 	1
& ( INC_OP SIZEOF CONSTANT - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 

94 1
unary_operator -> ~ 	1
& ( INC_OP SIZEOF CONSTANT - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 

95 1
unary_operator -> ! 	1
& ( INC_OP SIZEOF CONSTANT - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 

96 1
postfix_expression -> primary_expression 	1
? OR_OP ] MUL_ASSIGN EQ_OP | < * . ( [ PTR_OP INC_OP DEC_OP ) LEFT_ASSIGN DIV_ASSIGN GE_OP MOD_ASSIGN } ADD_ASSIGN = SUB_ASSIGN RIGHT_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 

97 1
cast_expression -> unary_expression 	1
OR_OP ? ] EQ_OP MUL_ASSIGN | < GE_OP MOD_ASSIGN : * LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 

98 8
postfix_expression -> postfix_expression . IDENTIFIER 	1
? OR_OP ] MUL_ASSIGN EQ_OP | < * . ( [ PTR_OP INC_OP DEC_OP ) LEFT_ASSIGN DIV_ASSIGN GE_OP MOD_ASSIGN } ADD_ASSIGN = SUB_ASSIGN RIGHT_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
postfix_expression -> postfix_expression ( ) 	1
? OR_OP ] MUL_ASSIGN EQ_OP | < * . ( [ PTR_OP INC_OP DEC_OP ) LEFT_ASSIGN DIV_ASSIGN GE_OP MOD_ASSIGN } ADD_ASSIGN = SUB_ASSIGN RIGHT_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
postfix_expression -> postfix_expression ( argument_expression_list ) 	1
? OR_OP ] MUL_ASSIGN EQ_OP | < * . ( [ PTR_OP INC_OP DEC_OP ) LEFT_ASSIGN DIV_ASSIGN GE_OP MOD_ASSIGN } ADD_ASSIGN = SUB_ASSIGN RIGHT_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
unary_expression -> postfix_expression 	1
? OR_OP ] | < MUL_ASSIGN EQ_OP GE_OP MOD_ASSIGN * ) LEFT_ASSIGN DIV_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
postfix_expression -> postfix_expression DEC_OP 	1
? OR_OP ] MUL_ASSIGN EQ_OP | < * . ( [ PTR_OP INC_OP DEC_OP ) LEFT_ASSIGN DIV_ASSIGN GE_OP MOD_ASSIGN } ADD_ASSIGN = SUB_ASSIGN RIGHT_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
postfix_expression -> postfix_expression INC_OP 	1
? OR_OP ] MUL_ASSIGN EQ_OP | < * . ( [ PTR_OP INC_OP DEC_OP ) LEFT_ASSIGN DIV_ASSIGN GE_OP MOD_ASSIGN } ADD_ASSIGN = SUB_ASSIGN RIGHT_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
postfix_expression -> postfix_expression [ expression ] 	1
? OR_OP ] MUL_ASSIGN EQ_OP | < * . ( [ PTR_OP INC_OP DEC_OP ) LEFT_ASSIGN DIV_ASSIGN GE_OP MOD_ASSIGN } ADD_ASSIGN = SUB_ASSIGN RIGHT_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	1
? OR_OP ] MUL_ASSIGN EQ_OP | < * . ( [ PTR_OP INC_OP DEC_OP ) LEFT_ASSIGN DIV_ASSIGN GE_OP MOD_ASSIGN } ADD_ASSIGN = SUB_ASSIGN RIGHT_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 

99 1
multiplicative_expression -> cast_expression 	1
? OR_OP / ] % | < EQ_OP * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 

100 27
cast_expression -> ( type_name ) cast_expression 	0
? OR_OP ] MUL_ASSIGN EQ_OP | < GE_OP MOD_ASSIGN * LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
unary_expression -> unary_operator cast_expression 	1
? OR_OP ] | < MUL_ASSIGN EQ_OP GE_OP MOD_ASSIGN * ) LEFT_ASSIGN DIV_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
unary_expression -> unary_operator cast_expression 	0
? OR_OP ] | < MUL_ASSIGN EQ_OP GE_OP MOD_ASSIGN * ) LEFT_ASSIGN DIV_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
? OR_OP ] MUL_ASSIGN EQ_OP | < GE_OP MOD_ASSIGN * LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
unary_expression -> INC_OP unary_expression 	0
? OR_OP ] | < MUL_ASSIGN EQ_OP GE_OP MOD_ASSIGN * ) LEFT_ASSIGN DIV_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
unary_expression -> postfix_expression 	0
? OR_OP ] | < MUL_ASSIGN EQ_OP GE_OP MOD_ASSIGN * ) LEFT_ASSIGN DIV_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
primary_expression -> IDENTIFIER 	0
? OR_OP ] | < MUL_ASSIGN EQ_OP GE_OP MOD_ASSIGN * ) LEFT_ASSIGN DIV_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( 
unary_expression -> DEC_OP unary_expression 	0
? OR_OP ] | < MUL_ASSIGN EQ_OP GE_OP MOD_ASSIGN * ) LEFT_ASSIGN DIV_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
cast_expression -> unary_expression 	0
? OR_OP ] MUL_ASSIGN EQ_OP | < GE_OP MOD_ASSIGN * LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
unary_expression -> SIZEOF ( type_name ) 	0
? OR_OP ] | < MUL_ASSIGN EQ_OP GE_OP MOD_ASSIGN * ) LEFT_ASSIGN DIV_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
unary_expression -> SIZEOF unary_expression 	0
? OR_OP ] | < MUL_ASSIGN EQ_OP GE_OP MOD_ASSIGN * ) LEFT_ASSIGN DIV_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
postfix_expression -> postfix_expression . IDENTIFIER 	0
? OR_OP ] MUL_ASSIGN EQ_OP | < GE_OP MOD_ASSIGN * LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> primary_expression 	0
? OR_OP ] MUL_ASSIGN EQ_OP | < GE_OP MOD_ASSIGN * LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression ( ) 	0
? OR_OP ] MUL_ASSIGN EQ_OP | < GE_OP MOD_ASSIGN * LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression INC_OP 	0
? OR_OP ] MUL_ASSIGN EQ_OP | < GE_OP MOD_ASSIGN * LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
? OR_OP ] MUL_ASSIGN EQ_OP | < GE_OP MOD_ASSIGN * LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
? OR_OP ] MUL_ASSIGN EQ_OP | < GE_OP MOD_ASSIGN * LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
? OR_OP ] MUL_ASSIGN EQ_OP | < GE_OP MOD_ASSIGN * LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
primary_expression -> CONSTANT 	0
? OR_OP ] | < MUL_ASSIGN EQ_OP GE_OP MOD_ASSIGN * ) LEFT_ASSIGN DIV_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( 
primary_expression -> ( expression ) 	0
? OR_OP ] | < MUL_ASSIGN EQ_OP GE_OP MOD_ASSIGN * ) LEFT_ASSIGN DIV_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( 
primary_expression -> STRING_LITERAL 	0
? OR_OP ] | < MUL_ASSIGN EQ_OP GE_OP MOD_ASSIGN * ) LEFT_ASSIGN DIV_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( 

101 4
multiplicative_expression -> multiplicative_expression / cast_expression 	1
? OR_OP / ] % | < EQ_OP * ; ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 
additive_expression -> multiplicative_expression 	1
OR_OP ? ] - EQ_OP | < ; + ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 
multiplicative_expression -> multiplicative_expression * cast_expression 	1
? OR_OP / ] % | < EQ_OP * ; ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 
multiplicative_expression -> multiplicative_expression % cast_expression 	1
? OR_OP / ] % | < EQ_OP * ; ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 

102 1
constant_expression -> conditional_expression 	1
} ] : ; , 

103 3
additive_expression -> additive_expression + multiplicative_expression 	1
OR_OP ? ] - EQ_OP | < ; + ) : } , LE_OP > GE_OP NE_OP & ^ AND_OP 
shift_expression -> additive_expression 	1
? OR_OP ] | < EQ_OP ; LEFT_OP RIGHT_OP ) : } , LE_OP > GE_OP NE_OP & ^ AND_OP 
additive_expression -> additive_expression - multiplicative_expression 	1
OR_OP ? ] - EQ_OP | < ; + ) : } , LE_OP > GE_OP NE_OP & ^ AND_OP 

104 1
direct_declarator -> direct_declarator [ constant_expression ] 	3
; { VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ ) = , : 

105 3
relational_expression -> shift_expression 	1
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP 
shift_expression -> shift_expression RIGHT_OP additive_expression 	1
? OR_OP ] | < EQ_OP ; LEFT_OP RIGHT_OP ) : } , NE_OP & ^ AND_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	1
? OR_OP ] | < EQ_OP ; LEFT_OP RIGHT_OP ) : } , NE_OP & ^ AND_OP 

106 5
equality_expression -> relational_expression 	1
? OR_OP NE_OP } ] EQ_OP ; ) : , & ^ | AND_OP 
relational_expression -> relational_expression < shift_expression 	1
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , & ^ AND_OP 
relational_expression -> relational_expression > shift_expression 	1
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , & ^ AND_OP 
relational_expression -> relational_expression LE_OP shift_expression 	1
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , & ^ AND_OP 
relational_expression -> relational_expression GE_OP shift_expression 	1
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , & ^ AND_OP 

107 3
and_expression -> equality_expression 	1
OR_OP ? } ] & ; ) : , ^ | AND_OP 
equality_expression -> equality_expression NE_OP relational_expression 	1
? OR_OP NE_OP } ] EQ_OP ; ) : , ^ | AND_OP 
equality_expression -> equality_expression EQ_OP relational_expression 	1
? OR_OP NE_OP } ] EQ_OP ; ) : , ^ | AND_OP 

108 2
and_expression -> and_expression & equality_expression 	1
OR_OP ? } ] & ; ) : , | AND_OP 
exclusive_or_expression -> and_expression 	1
? OR_OP } ] ^ ; ) : , | AND_OP 

109 2
inclusive_or_expression -> exclusive_or_expression 	1
OR_OP ? } ] , | ; ) : AND_OP 
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	1
? OR_OP } ] ^ ; ) : , AND_OP 

110 2
logical_and_expression -> inclusive_or_expression 	1
? OR_OP } ] ) AND_OP ; : , 
inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression 	1
OR_OP ? } ] , | ; ) : 

111 2
logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression 	1
? OR_OP } ] ) AND_OP ; : , 
logical_or_expression -> logical_and_expression 	1
? OR_OP } ] ; ) : , 

112 3
conditional_expression -> logical_or_expression 	1
} ] ; ) : , 
conditional_expression -> logical_or_expression ? expression : conditional_expression 	1
} ] ; ) : , 
logical_or_expression -> logical_or_expression OR_OP logical_and_expression 	1
? OR_OP } ] ; ) : , 

113 16
declarator -> direct_declarator 	0
; , = 
init_declarator_list -> init_declarator_list , init_declarator 	2
; , 
declarator -> pointer direct_declarator 	0
; , = 
init_declarator -> declarator 	0
; , 
pointer -> * type_qualifier_list pointer 	0
IDENTIFIER ( 
init_declarator -> declarator = initializer 	0
; , 
pointer -> * pointer 	0
IDENTIFIER ( 
pointer -> * type_qualifier_list 	0
IDENTIFIER ( 
direct_declarator -> direct_declarator ( ) 	0
[ ; , = ( 
pointer -> * 	0
IDENTIFIER ( 
direct_declarator -> ( declarator ) 	0
[ ; , = ( 
direct_declarator -> IDENTIFIER 	0
[ ; , = ( 
direct_declarator -> direct_declarator ( parameter_type_list ) 	0
[ ; , = ( 
direct_declarator -> direct_declarator [ ] 	0
[ ; , = ( 
direct_declarator -> direct_declarator [ constant_expression ] 	0
[ ; , = ( 
direct_declarator -> direct_declarator ( identifier_list ) 	0
[ ; , = ( 

114 1
declaration -> declaration_specifiers init_declarator_list ; 	3
STATIC DEC_OP LONG $ DEFAULT INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT FLOAT STRUCT REGISTER DO UNION CONST CHAR * IF UNSIGNED ( STRING_LITERAL TYPEDEF EXTERN AUTO DOUBLE RETURN VOID ENUM { ; BREAK - } WHILE GOTO CASE FOR CONTINUE SIZEOF INC_OP SWITCH CONSTANT & ~ + ! 

115 62
primary_expression -> IDENTIFIER 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
unary_expression -> DEC_OP unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < , * 
relational_expression -> relational_expression LE_OP shift_expression 	0
? OR_OP ; < , EQ_OP > LE_OP GE_OP 
unary_expression -> unary_operator cast_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < , * 
init_declarator -> declarator = initializer 	2
; , 
initializer -> assignment_expression 	0
; , 
assignment_expression -> conditional_expression 	0
; , 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
/ OR_OP ? ; EQ_OP , < * % 
initializer -> { initializer_list } 	0
; , 
postfix_expression -> postfix_expression . IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
conditional_expression -> logical_or_expression 	0
; , 
conditional_expression -> logical_or_expression ? expression : conditional_expression 	0
; , 
postfix_expression -> postfix_expression ( ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
initializer -> { initializer_list , } 	0
; , 
assignment_expression -> unary_expression assignment_operator assignment_expression 	0
; , 
and_expression -> equality_expression 	0
OR_OP ? ; , & 
unary_expression -> SIZEOF ( type_name ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < , * 
unary_expression -> postfix_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < , * 
equality_expression -> equality_expression EQ_OP relational_expression 	0
NE_OP ? OR_OP ; EQ_OP , 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
unary_expression -> INC_OP unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < , * 
logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression 	0
? OR_OP ; , AND_OP 
unary_expression -> SIZEOF unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < , * 
logical_or_expression -> logical_or_expression OR_OP logical_and_expression 	0
OR_OP ? ; , 
cast_expression -> unary_expression 	0
OR_OP ? ; < , EQ_OP * 
logical_or_expression -> logical_and_expression 	0
OR_OP ? ; , 
postfix_expression -> primary_expression 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression INC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
equality_expression -> equality_expression NE_OP relational_expression 	0
NE_OP ? OR_OP ; EQ_OP , 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
additive_expression -> additive_expression + multiplicative_expression 	0
OR_OP ? + ; < , EQ_OP - 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
/ OR_OP ? ; EQ_OP , < * % 
logical_and_expression -> inclusive_or_expression 	0
? OR_OP ; , AND_OP 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP , < RIGHT_OP 
primary_expression -> CONSTANT 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
primary_expression -> ( expression ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
primary_expression -> STRING_LITERAL 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
inclusive_or_expression -> exclusive_or_expression 	0
OR_OP ? ; | , 
and_expression -> and_expression & equality_expression 	0
OR_OP ? ; , & 
inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression 	0
OR_OP ? ; | , 
exclusive_or_expression -> and_expression 	0
? OR_OP ; , ^ 
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	0
? OR_OP ; , ^ 
equality_expression -> relational_expression 	0
NE_OP ? OR_OP ; EQ_OP , 
multiplicative_expression -> cast_expression 	0
/ OR_OP ? ; EQ_OP , < * % 
relational_expression -> shift_expression 	0
? OR_OP ; < , EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression < shift_expression 	0
? OR_OP ; < , EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression > shift_expression 	0
? OR_OP ; < , EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression GE_OP shift_expression 	0
? OR_OP ; < , EQ_OP > LE_OP GE_OP 
shift_expression -> additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP , < RIGHT_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP , < RIGHT_OP 
additive_expression -> multiplicative_expression 	0
OR_OP ? + ; < , EQ_OP - 
additive_expression -> additive_expression - multiplicative_expression 	0
OR_OP ? + ; < , EQ_OP - 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
/ OR_OP ? ; EQ_OP , < * % 
cast_expression -> ( type_name ) cast_expression 	0
OR_OP ? ; < , EQ_OP * 

116 1
function_definition -> declaration_specifiers declarator compound_statement 	3
STATIC LONG $ INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT FLOAT STRUCT REGISTER UNION CONST CHAR * UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID ENUM 

117 41
function_definition -> declaration_specifiers declarator declaration_list compound_statement 	3
STATIC LONG $ INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT FLOAT STRUCT REGISTER UNION CONST CHAR * UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID ENUM 
declaration -> declaration_specifiers ; 	0
{ STRUCT REGISTER VOLATILE SIGNED TYPE_NAME SHORT STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM 
declaration_list -> declaration_list declaration 	1
{ STRUCT REGISTER SHORT SIGNED TYPE_NAME VOLATILE STATIC TYPEDEF CONST UNION EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM 
compound_statement -> { declaration_list } 	0
LONG $ STATIC INT IDENTIFIER SHORT SIGNED TYPE_NAME VOLATILE FLOAT REGISTER STRUCT CONST UNION * CHAR UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID ENUM 
compound_statement -> { statement_list } 	0
LONG $ STATIC INT IDENTIFIER SHORT SIGNED TYPE_NAME VOLATILE FLOAT REGISTER STRUCT CONST UNION * CHAR UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID ENUM 
declaration_specifiers -> type_specifier declaration_specifiers 	0
IDENTIFIER * ( ; 
type_specifier -> struct_or_union_specifier 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
declaration_specifiers -> storage_class_specifier 	0
IDENTIFIER * ( ; 
compound_statement -> { } 	0
LONG $ STATIC INT IDENTIFIER SHORT SIGNED TYPE_NAME VOLATILE FLOAT REGISTER STRUCT CONST UNION * CHAR UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID ENUM 
storage_class_specifier -> REGISTER 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
declaration -> declaration_specifiers init_declarator_list ; 	0
{ STRUCT REGISTER VOLATILE SIGNED TYPE_NAME SHORT STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM 
compound_statement -> { declaration_list statement_list } 	0
LONG $ STATIC INT IDENTIFIER SHORT SIGNED TYPE_NAME VOLATILE FLOAT REGISTER STRUCT CONST UNION * CHAR UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID ENUM 
declaration_specifiers -> type_specifier 	0
IDENTIFIER * ( ; 
declaration_specifiers -> storage_class_specifier declaration_specifiers 	0
IDENTIFIER * ( ; 
type_specifier -> SIGNED 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
declaration_specifiers -> type_qualifier 	0
IDENTIFIER * ( ; 
declaration_specifiers -> type_qualifier declaration_specifiers 	0
IDENTIFIER * ( ; 
type_specifier -> CHAR 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
storage_class_specifier -> STATIC 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
type_specifier -> FLOAT 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_specifier -> TYPE_NAME 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
storage_class_specifier -> EXTERN 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
type_specifier -> SHORT 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_specifier -> LONG 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_specifier -> VOID 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_specifier -> INT 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_specifier -> DOUBLE 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_specifier -> UNSIGNED 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_specifier -> enum_specifier 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_qualifier -> CONST 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
storage_class_specifier -> AUTO 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
enum_specifier -> ENUM { enumerator_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; 
storage_class_specifier -> TYPEDEF 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
type_qualifier -> VOLATILE 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
struct_or_union_specifier -> struct_or_union { struct_declaration_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; 
enum_specifier -> ENUM IDENTIFIER { enumerator_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; 
struct_or_union_specifier -> struct_or_union IDENTIFIER { struct_declaration_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; 
struct_or_union_specifier -> struct_or_union IDENTIFIER 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; 
enum_specifier -> ENUM IDENTIFIER 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; 
struct_or_union -> STRUCT 	0
{ IDENTIFIER 
struct_or_union -> UNION 	0
{ IDENTIFIER 

118 2
labeled_statement -> IDENTIFIER : statement 	1
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
primary_expression -> IDENTIFIER 	1
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 

119 1
jump_statement -> CONTINUE ; 	1
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 

120 1
compound_statement -> { } 	2
} FOR ELSE WHILE DEFAULT INT IDENTIFIER STATIC DEC_OP LONG $ VOLATILE SIGNED TYPE_NAME SHORT FLOAT STRUCT REGISTER DO UNION CONST CHAR * IF UNSIGNED ( STRING_LITERAL TYPEDEF EXTERN AUTO DOUBLE RETURN VOID ENUM GOTO CASE ; { CONTINUE BREAK - SIZEOF INC_OP SWITCH CONSTANT & ~ + ! 

121 1
expression_statement -> ; 	1
BREAK - } WHILE SIZEOF CONSTANT { ; INC_OP ( DEC_OP DEFAULT IDENTIFIER & STRING_LITERAL * ~ + ! CONTINUE ) FOR ELSE GOTO CASE RETURN DO IF SWITCH 

122 2
selection_statement -> IF ( expression ) statement ELSE statement 	1
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
selection_statement -> IF ( expression ) statement 	1
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 

123 58
constant_expression -> conditional_expression 	0
: 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
/ ? OR_OP * : EQ_OP < % 
labeled_statement -> CASE constant_expression : statement 	1
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
postfix_expression -> postfix_expression . IDENTIFIER 	0
? OR_OP : * < EQ_OP . ( [ PTR_OP INC_OP DEC_OP 
conditional_expression -> logical_or_expression 	0
: 
conditional_expression -> logical_or_expression ? expression : conditional_expression 	0
: 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
/ ? OR_OP * : EQ_OP < % 
logical_and_expression -> inclusive_or_expression 	0
? OR_OP : AND_OP 
logical_or_expression -> logical_or_expression OR_OP logical_and_expression 	0
OR_OP ? : 
cast_expression -> unary_expression 	0
OR_OP ? : * < EQ_OP 
logical_or_expression -> logical_and_expression 	0
OR_OP ? : 
unary_expression -> SIZEOF unary_expression 	0
? OR_OP * : EQ_OP < 
logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression 	0
? OR_OP : AND_OP 
inclusive_or_expression -> exclusive_or_expression 	0
OR_OP ? : | 
and_expression -> and_expression & equality_expression 	0
OR_OP ? : & 
inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression 	0
OR_OP ? : | 
exclusive_or_expression -> and_expression 	0
? OR_OP : ^ 
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	0
? OR_OP : ^ 
unary_expression -> SIZEOF ( type_name ) 	0
? OR_OP * : EQ_OP < 
and_expression -> equality_expression 	0
OR_OP ? : & 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
? OR_OP : * < EQ_OP . ( [ PTR_OP INC_OP DEC_OP 
unary_expression -> INC_OP unary_expression 	0
? OR_OP * : EQ_OP < 
equality_expression -> equality_expression EQ_OP relational_expression 	0
NE_OP ? OR_OP : EQ_OP 
equality_expression -> relational_expression 	0
NE_OP ? OR_OP : EQ_OP 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
equality_expression -> equality_expression NE_OP relational_expression 	0
NE_OP ? OR_OP : EQ_OP 
multiplicative_expression -> cast_expression 	0
/ ? OR_OP * : EQ_OP < % 
relational_expression -> shift_expression 	0
OR_OP ? GE_OP : < EQ_OP > LE_OP 
relational_expression -> relational_expression < shift_expression 	0
OR_OP ? GE_OP : < EQ_OP > LE_OP 
relational_expression -> relational_expression > shift_expression 	0
OR_OP ? GE_OP : < EQ_OP > LE_OP 
unary_expression -> unary_operator cast_expression 	0
? OR_OP * : EQ_OP < 
relational_expression -> relational_expression LE_OP shift_expression 	0
OR_OP ? GE_OP : < EQ_OP > LE_OP 
relational_expression -> relational_expression GE_OP shift_expression 	0
OR_OP ? GE_OP : < EQ_OP > LE_OP 
shift_expression -> additive_expression 	0
? OR_OP : EQ_OP < LEFT_OP RIGHT_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	0
? OR_OP : EQ_OP < LEFT_OP RIGHT_OP 
primary_expression -> CONSTANT 	0
? OR_OP * : EQ_OP < . ( 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
? OR_OP : EQ_OP < LEFT_OP RIGHT_OP 
additive_expression -> multiplicative_expression 	0
OR_OP ? : < EQ_OP + - 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
additive_expression -> additive_expression + multiplicative_expression 	0
OR_OP ? : < EQ_OP + - 
additive_expression -> additive_expression - multiplicative_expression 	0
OR_OP ? : < EQ_OP + - 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
/ ? OR_OP * : EQ_OP < % 
cast_expression -> ( type_name ) cast_expression 	0
OR_OP ? : * < EQ_OP 
primary_expression -> IDENTIFIER 	0
? OR_OP * : EQ_OP < . ( 
unary_expression -> DEC_OP unary_expression 	0
? OR_OP * : EQ_OP < 
unary_expression -> postfix_expression 	0
? OR_OP * : EQ_OP < 
postfix_expression -> primary_expression 	0
? OR_OP : * < EQ_OP . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression ( ) 	0
? OR_OP : * < EQ_OP . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression INC_OP 	0
? OR_OP : * < EQ_OP . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
? OR_OP : * < EQ_OP . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
? OR_OP : * < EQ_OP . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
? OR_OP : * < EQ_OP . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
primary_expression -> ( expression ) 	0
? OR_OP * : EQ_OP < . ( 
primary_expression -> STRING_LITERAL 	0
? OR_OP * : EQ_OP < . ( 

124 1
labeled_statement -> DEFAULT : statement 	1
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 

125 1
selection_statement -> SWITCH ( expression ) statement 	1
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 

126 1
iteration_statement -> WHILE ( expression ) statement 	1
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 

127 88
logical_and_expression -> inclusive_or_expression 	0
? OR_OP ; AND_OP 
statement -> selection_statement 	0
WHILE 
selection_statement -> IF ( expression ) statement 	0
WHILE 
iteration_statement -> DO statement WHILE ( expression ) ; 	1
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
iteration_statement -> FOR ( expression_statement expression_statement ) statement 	0
WHILE 
iteration_statement -> WHILE ( expression ) statement 	0
WHILE 
statement -> labeled_statement 	0
WHILE 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
statement -> iteration_statement 	0
WHILE 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
additive_expression -> additive_expression + multiplicative_expression 	0
OR_OP ? + ; < EQ_OP - 
statement -> compound_statement 	0
WHILE 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
statement -> jump_statement 	0
WHILE 
statement -> expression_statement 	0
WHILE 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
iteration_statement -> DO statement WHILE ( expression ) ; 	0
WHILE 
iteration_statement -> FOR ( expression_statement expression_statement expression ) statement 	0
WHILE 
compound_statement -> { declaration_list } 	0
WHILE 
primary_expression -> CONSTANT 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
compound_statement -> { statement_list } 	0
WHILE 
labeled_statement -> DEFAULT : statement 	0
WHILE 
compound_statement -> { } 	0
WHILE 
unary_expression -> DEC_OP unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
primary_expression -> IDENTIFIER 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
compound_statement -> { declaration_list statement_list } 	0
WHILE 
postfix_expression -> primary_expression 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
jump_statement -> GOTO IDENTIFIER ; 	0
WHILE 
postfix_expression -> postfix_expression ( ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
labeled_statement -> IDENTIFIER : statement 	0
WHILE 
jump_statement -> RETURN ; 	0
WHILE 
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	0
? OR_OP ; ^ 
jump_statement -> CONTINUE ; 	0
WHILE 
jump_statement -> BREAK ; 	0
WHILE 
jump_statement -> RETURN expression ; 	0
WHILE 
labeled_statement -> CASE constant_expression : statement 	0
WHILE 
inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression 	0
OR_OP ? ; | 
and_expression -> and_expression & equality_expression 	0
OR_OP ? ; & 
expression_statement -> expression ; 	0
WHILE 
expression_statement -> ; 	0
WHILE 
selection_statement -> IF ( expression ) statement ELSE statement 	0
WHILE 
selection_statement -> SWITCH ( expression ) statement 	0
WHILE 
primary_expression -> ( expression ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
expression -> assignment_expression 	0
; , 
primary_expression -> STRING_LITERAL 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
expression -> expression , assignment_expression 	0
; , 
assignment_expression -> conditional_expression 	0
; 
assignment_expression -> unary_expression assignment_operator assignment_expression 	0
; 
conditional_expression -> logical_or_expression ? expression : conditional_expression 	0
; 
postfix_expression -> postfix_expression . IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
conditional_expression -> logical_or_expression 	0
; 
unary_expression -> SIZEOF ( type_name ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
unary_expression -> postfix_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
unary_expression -> INC_OP unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
unary_expression -> unary_operator cast_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression 	0
? OR_OP ; AND_OP 
unary_expression -> SIZEOF unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
logical_or_expression -> logical_or_expression OR_OP logical_and_expression 	0
OR_OP ? ; 
logical_or_expression -> logical_and_expression 	0
OR_OP ? ; 
postfix_expression -> postfix_expression INC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
inclusive_or_expression -> exclusive_or_expression 	0
OR_OP ? ; | 
exclusive_or_expression -> and_expression 	0
? OR_OP ; ^ 
and_expression -> equality_expression 	0
OR_OP ? ; & 
equality_expression -> equality_expression EQ_OP relational_expression 	0
NE_OP ? OR_OP ; EQ_OP 
equality_expression -> relational_expression 	0
NE_OP ? OR_OP ; EQ_OP 
equality_expression -> equality_expression NE_OP relational_expression 	0
NE_OP ? OR_OP ; EQ_OP 
relational_expression -> shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression < shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression > shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression LE_OP shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression GE_OP shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
shift_expression -> additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP < RIGHT_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP < RIGHT_OP 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP < RIGHT_OP 
additive_expression -> multiplicative_expression 	0
OR_OP ? + ; < EQ_OP - 
additive_expression -> additive_expression - multiplicative_expression 	0
OR_OP ? + ; < EQ_OP - 
multiplicative_expression -> cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
cast_expression -> ( type_name ) cast_expression 	0
OR_OP ? ; < EQ_OP * 
cast_expression -> unary_expression 	0
OR_OP ? ; < EQ_OP * 

128 2
iteration_statement -> FOR ( expression_statement expression_statement ) statement 	1
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
iteration_statement -> FOR ( expression_statement expression_statement expression ) statement 	1
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 

129 1
jump_statement -> GOTO IDENTIFIER ; 	1
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 

130 1
jump_statement -> BREAK ; 	1
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 

131 62
primary_expression -> IDENTIFIER 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
unary_expression -> DEC_OP unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
relational_expression -> relational_expression LE_OP shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
unary_expression -> unary_operator cast_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
jump_statement -> RETURN ; 	1
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
primary_expression -> STRING_LITERAL 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
expression -> expression , assignment_expression 	0
; , 
primary_expression -> ( expression ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
expression -> assignment_expression 	0
; , 
shift_expression -> additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP < RIGHT_OP 
jump_statement -> RETURN expression ; 	1
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
assignment_expression -> conditional_expression 	0
; 
assignment_expression -> unary_expression assignment_operator assignment_expression 	0
; 
postfix_expression -> postfix_expression . IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
conditional_expression -> logical_or_expression 	0
; 
conditional_expression -> logical_or_expression ? expression : conditional_expression 	0
; 
and_expression -> equality_expression 	0
OR_OP ? ; & 
unary_expression -> SIZEOF ( type_name ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
unary_expression -> postfix_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
equality_expression -> equality_expression EQ_OP relational_expression 	0
NE_OP ? OR_OP ; EQ_OP 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
unary_expression -> INC_OP unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression 	0
? OR_OP ; AND_OP 
unary_expression -> SIZEOF unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
logical_or_expression -> logical_or_expression OR_OP logical_and_expression 	0
OR_OP ? ; 
cast_expression -> unary_expression 	0
OR_OP ? ; < EQ_OP * 
logical_or_expression -> logical_and_expression 	0
OR_OP ? ; 
postfix_expression -> primary_expression 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression ( ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression INC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
equality_expression -> equality_expression NE_OP relational_expression 	0
NE_OP ? OR_OP ; EQ_OP 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
additive_expression -> additive_expression + multiplicative_expression 	0
OR_OP ? + ; < EQ_OP - 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
logical_and_expression -> inclusive_or_expression 	0
? OR_OP ; AND_OP 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP < RIGHT_OP 
primary_expression -> CONSTANT 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
inclusive_or_expression -> exclusive_or_expression 	0
OR_OP ? ; | 
and_expression -> and_expression & equality_expression 	0
OR_OP ? ; & 
inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression 	0
OR_OP ? ; | 
exclusive_or_expression -> and_expression 	0
? OR_OP ; ^ 
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	0
? OR_OP ; ^ 
equality_expression -> relational_expression 	0
NE_OP ? OR_OP ; EQ_OP 
multiplicative_expression -> cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
relational_expression -> shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression < shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression > shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression GE_OP shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP < RIGHT_OP 
additive_expression -> multiplicative_expression 	0
OR_OP ? + ; < EQ_OP - 
additive_expression -> additive_expression - multiplicative_expression 	0
OR_OP ? + ; < EQ_OP - 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
cast_expression -> ( type_name ) cast_expression 	0
OR_OP ? ; < EQ_OP * 

132 13
assignment_operator -> = 	0
CONSTANT SIZEOF - ( INC_OP DEC_OP IDENTIFIER & STRING_LITERAL * ~ + ! 
assignment_operator -> ADD_ASSIGN 	0
CONSTANT SIZEOF - ( INC_OP DEC_OP IDENTIFIER & STRING_LITERAL * ~ + ! 
assignment_expression -> unary_expression assignment_operator assignment_expression 	1
; ) } ] : , 
assignment_operator -> DIV_ASSIGN 	0
CONSTANT SIZEOF - ( INC_OP DEC_OP IDENTIFIER & STRING_LITERAL * ~ + ! 
cast_expression -> unary_expression 	1
OR_OP ? ; EQ_OP < : * ) ] } , 
assignment_operator -> MUL_ASSIGN 	0
CONSTANT SIZEOF - ( INC_OP DEC_OP IDENTIFIER & STRING_LITERAL * ~ + ! 
assignment_operator -> SUB_ASSIGN 	0
CONSTANT SIZEOF - ( INC_OP DEC_OP IDENTIFIER & STRING_LITERAL * ~ + ! 
assignment_operator -> XOR_ASSIGN 	0
CONSTANT SIZEOF - ( INC_OP DEC_OP IDENTIFIER & STRING_LITERAL * ~ + ! 
assignment_operator -> MOD_ASSIGN 	0
CONSTANT SIZEOF - ( INC_OP DEC_OP IDENTIFIER & STRING_LITERAL * ~ + ! 
assignment_operator -> LEFT_ASSIGN 	0
CONSTANT SIZEOF - ( INC_OP DEC_OP IDENTIFIER & STRING_LITERAL * ~ + ! 
assignment_operator -> RIGHT_ASSIGN 	0
CONSTANT SIZEOF - ( INC_OP DEC_OP IDENTIFIER & STRING_LITERAL * ~ + ! 
assignment_operator -> AND_ASSIGN 	0
CONSTANT SIZEOF - ( INC_OP DEC_OP IDENTIFIER & STRING_LITERAL * ~ + ! 
assignment_operator -> OR_ASSIGN 	0
CONSTANT SIZEOF - ( INC_OP DEC_OP IDENTIFIER & STRING_LITERAL * ~ + ! 

133 1
expression -> assignment_expression 	1
; , ) ] : 

134 2
expression_statement -> expression ; 	1
BREAK - } WHILE SIZEOF CONSTANT { ; INC_OP ( DEC_OP DEFAULT IDENTIFIER & STRING_LITERAL * ~ + ! CONTINUE ) FOR ELSE GOTO CASE RETURN DO IF SWITCH 
expression -> expression , assignment_expression 	1
; , 

135 1
statement -> expression_statement 	1
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 

136 1
assignment_expression -> conditional_expression 	1
; ) } ] : , 

137 1
statement_list -> statement 	1
} FOR GOTO WHILE IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 

138 1
statement -> compound_statement 	1
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 

139 89
logical_and_expression -> inclusive_or_expression 	0
? OR_OP ; AND_OP 
statement -> selection_statement 	0
FOR } IDENTIFIER DEFAULT WHILE GOTO CASE ; { RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
expression_statement -> ; 	0
} FOR GOTO WHILE IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
compound_statement -> { statement_list } 	2
} FOR ELSE WHILE DEFAULT INT IDENTIFIER STATIC DEC_OP LONG $ VOLATILE SIGNED TYPE_NAME SHORT FLOAT STRUCT REGISTER DO UNION CONST CHAR * IF UNSIGNED ( STRING_LITERAL TYPEDEF EXTERN AUTO DOUBLE RETURN VOID ENUM GOTO CASE ; { CONTINUE BREAK - SIZEOF INC_OP SWITCH CONSTANT & ~ + ! 
unary_expression -> DEC_OP unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
primary_expression -> IDENTIFIER 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
compound_statement -> { declaration_list statement_list } 	0
} FOR GOTO WHILE IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
statement_list -> statement_list statement 	1
} FOR GOTO WHILE IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
statement -> labeled_statement 	0
FOR } IDENTIFIER DEFAULT WHILE GOTO CASE ; { RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
statement -> iteration_statement 	0
FOR } IDENTIFIER DEFAULT WHILE GOTO CASE ; { RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
additive_expression -> additive_expression + multiplicative_expression 	0
OR_OP ? + ; < EQ_OP - 
statement -> compound_statement 	0
FOR } IDENTIFIER DEFAULT WHILE GOTO CASE ; { RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
statement -> jump_statement 	0
FOR } IDENTIFIER DEFAULT WHILE GOTO CASE ; { RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
statement -> expression_statement 	0
FOR } IDENTIFIER DEFAULT WHILE GOTO CASE ; { RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
iteration_statement -> DO statement WHILE ( expression ) ; 	0
} FOR GOTO WHILE IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
iteration_statement -> FOR ( expression_statement expression_statement ) statement 	0
} FOR GOTO WHILE IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
iteration_statement -> WHILE ( expression ) statement 	0
} FOR GOTO WHILE IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
iteration_statement -> FOR ( expression_statement expression_statement expression ) statement 	0
} FOR GOTO WHILE IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
compound_statement -> { declaration_list } 	0
} FOR GOTO WHILE IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
primary_expression -> CONSTANT 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
compound_statement -> { statement_list } 	0
} FOR GOTO WHILE IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
labeled_statement -> DEFAULT : statement 	0
} FOR GOTO WHILE IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
compound_statement -> { } 	0
} FOR GOTO WHILE IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
postfix_expression -> primary_expression 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
jump_statement -> GOTO IDENTIFIER ; 	0
} FOR GOTO WHILE IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
postfix_expression -> postfix_expression ( ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
labeled_statement -> IDENTIFIER : statement 	0
} FOR GOTO WHILE IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
jump_statement -> RETURN ; 	0
} FOR GOTO WHILE IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	0
? OR_OP ; ^ 
jump_statement -> CONTINUE ; 	0
} FOR GOTO WHILE IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
jump_statement -> BREAK ; 	0
} FOR GOTO WHILE IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
jump_statement -> RETURN expression ; 	0
} FOR GOTO WHILE IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
labeled_statement -> CASE constant_expression : statement 	0
} FOR GOTO WHILE IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression 	0
OR_OP ? ; | 
and_expression -> and_expression & equality_expression 	0
OR_OP ? ; & 
expression_statement -> expression ; 	0
} FOR GOTO WHILE IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
selection_statement -> IF ( expression ) statement ELSE statement 	0
} FOR GOTO WHILE IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
selection_statement -> IF ( expression ) statement 	0
} FOR GOTO WHILE IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
selection_statement -> SWITCH ( expression ) statement 	0
} FOR GOTO WHILE IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
primary_expression -> ( expression ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
expression -> assignment_expression 	0
; , 
primary_expression -> STRING_LITERAL 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
expression -> expression , assignment_expression 	0
; , 
assignment_expression -> conditional_expression 	0
; 
assignment_expression -> unary_expression assignment_operator assignment_expression 	0
; 
conditional_expression -> logical_or_expression ? expression : conditional_expression 	0
; 
postfix_expression -> postfix_expression . IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
conditional_expression -> logical_or_expression 	0
; 
unary_expression -> SIZEOF ( type_name ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
unary_expression -> postfix_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
unary_expression -> INC_OP unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
unary_expression -> unary_operator cast_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression 	0
? OR_OP ; AND_OP 
unary_expression -> SIZEOF unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
logical_or_expression -> logical_or_expression OR_OP logical_and_expression 	0
OR_OP ? ; 
logical_or_expression -> logical_and_expression 	0
OR_OP ? ; 
postfix_expression -> postfix_expression INC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
inclusive_or_expression -> exclusive_or_expression 	0
OR_OP ? ; | 
exclusive_or_expression -> and_expression 	0
? OR_OP ; ^ 
and_expression -> equality_expression 	0
OR_OP ? ; & 
equality_expression -> equality_expression EQ_OP relational_expression 	0
NE_OP ? OR_OP ; EQ_OP 
equality_expression -> relational_expression 	0
NE_OP ? OR_OP ; EQ_OP 
equality_expression -> equality_expression NE_OP relational_expression 	0
NE_OP ? OR_OP ; EQ_OP 
relational_expression -> shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression < shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression > shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression LE_OP shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression GE_OP shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
shift_expression -> additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP < RIGHT_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP < RIGHT_OP 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP < RIGHT_OP 
additive_expression -> multiplicative_expression 	0
OR_OP ? + ; < EQ_OP - 
additive_expression -> additive_expression - multiplicative_expression 	0
OR_OP ? + ; < EQ_OP - 
multiplicative_expression -> cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
cast_expression -> ( type_name ) cast_expression 	0
OR_OP ? ; < EQ_OP * 
cast_expression -> unary_expression 	0
OR_OP ? ; < EQ_OP * 

140 127
multiplicative_expression -> multiplicative_expression * cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
statement -> iteration_statement 	0
} 
compound_statement -> { declaration_list } 	2
} FOR ELSE WHILE DEFAULT INT IDENTIFIER STATIC DEC_OP LONG $ VOLATILE SIGNED TYPE_NAME SHORT FLOAT STRUCT REGISTER DO UNION CONST CHAR * IF UNSIGNED ( STRING_LITERAL TYPEDEF EXTERN AUTO DOUBLE RETURN VOID ENUM GOTO CASE ; { CONTINUE BREAK - SIZEOF INC_OP SWITCH CONSTANT & ~ + ! 
struct_or_union_specifier -> struct_or_union { struct_declaration_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; 
compound_statement -> { declaration_list statement_list } 	2
} FOR ELSE WHILE DEFAULT INT IDENTIFIER STATIC DEC_OP LONG $ VOLATILE SIGNED TYPE_NAME SHORT FLOAT STRUCT REGISTER DO UNION CONST CHAR * IF UNSIGNED ( STRING_LITERAL TYPEDEF EXTERN AUTO DOUBLE RETURN VOID ENUM GOTO CASE ; { CONTINUE BREAK - SIZEOF INC_OP SWITCH CONSTANT & ~ + ! 
declaration -> declaration_specifiers ; 	0
STRUCT REGISTER } VOLATILE SIGNED TYPE_NAME SHORT STATIC TYPEDEF STRING_LITERAL UNION CONST DO EXTERN AUTO DOUBLE VOID RETURN CHAR * FLOAT INT IDENTIFIER DEFAULT LONG DEC_OP UNSIGNED IF ENUM WHILE GOTO CASE ; { - BREAK FOR CONTINUE SIZEOF INC_OP SWITCH CONSTANT ( & ~ + ! 
statement_list -> statement 	0
FOR } IDENTIFIER DEFAULT WHILE GOTO CASE ; { RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
declaration_list -> declaration_list declaration 	1
} STRUCT REGISTER SHORT SIGNED TYPE_NAME VOLATILE STATIC STRING_LITERAL TYPEDEF DO CONST UNION EXTERN AUTO DOUBLE RETURN VOID * CHAR FLOAT DEFAULT IDENTIFIER INT DEC_OP LONG IF UNSIGNED ENUM WHILE GOTO CASE { ; BREAK - FOR CONTINUE SIZEOF INC_OP SWITCH CONSTANT ( & ~ + ! 
declaration_specifiers -> storage_class_specifier declaration_specifiers 	0
IDENTIFIER * ( ; 
statement_list -> statement_list statement 	0
FOR } IDENTIFIER DEFAULT WHILE GOTO CASE ; { RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
storage_class_specifier -> REGISTER 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
declaration -> declaration_specifiers init_declarator_list ; 	0
STRUCT REGISTER } VOLATILE SIGNED TYPE_NAME SHORT STATIC TYPEDEF STRING_LITERAL UNION CONST DO EXTERN AUTO DOUBLE VOID RETURN CHAR * FLOAT INT IDENTIFIER DEFAULT LONG DEC_OP UNSIGNED IF ENUM WHILE GOTO CASE ; { - BREAK FOR CONTINUE SIZEOF INC_OP SWITCH CONSTANT ( & ~ + ! 
additive_expression -> additive_expression + multiplicative_expression 	0
OR_OP ? + ; < EQ_OP - 
statement -> compound_statement 	0
} 
statement -> jump_statement 	0
} 
enum_specifier -> ENUM IDENTIFIER { enumerator_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; 
struct_or_union_specifier -> struct_or_union IDENTIFIER { struct_declaration_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; 
statement -> labeled_statement 	0
} 
statement -> expression_statement 	0
} 
statement -> selection_statement 	0
} 
labeled_statement -> IDENTIFIER : statement 	0
} 
declaration_specifiers -> type_specifier declaration_specifiers 	0
IDENTIFIER * ( ; 
jump_statement -> RETURN ; 	0
} 
declaration_specifiers -> type_specifier 	0
IDENTIFIER * ( ; 
type_specifier -> struct_or_union_specifier 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
compound_statement -> { } 	0
} 
declaration_specifiers -> storage_class_specifier 	0
IDENTIFIER * ( ; 
type_specifier -> SIGNED 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
declaration_specifiers -> type_qualifier 	0
IDENTIFIER * ( ; 
labeled_statement -> CASE constant_expression : statement 	0
} 
declaration_specifiers -> type_qualifier declaration_specifiers 	0
IDENTIFIER * ( ; 
iteration_statement -> DO statement WHILE ( expression ) ; 	0
} 
iteration_statement -> FOR ( expression_statement expression_statement ) statement 	0
} 
iteration_statement -> WHILE ( expression ) statement 	0
} 
iteration_statement -> FOR ( expression_statement expression_statement expression ) statement 	0
} 
compound_statement -> { declaration_list } 	0
} 
compound_statement -> { statement_list } 	0
} 
labeled_statement -> DEFAULT : statement 	0
} 
compound_statement -> { declaration_list statement_list } 	0
} 
storage_class_specifier -> EXTERN 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
type_specifier -> SHORT 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
jump_statement -> GOTO IDENTIFIER ; 	0
} 
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	0
? OR_OP ; ^ 
jump_statement -> CONTINUE ; 	0
} 
jump_statement -> BREAK ; 	0
} 
jump_statement -> RETURN expression ; 	0
} 
and_expression -> and_expression & equality_expression 	0
OR_OP ? ; & 
expression_statement -> expression ; 	0
} 
expression_statement -> ; 	0
} 
selection_statement -> IF ( expression ) statement ELSE statement 	0
} 
selection_statement -> IF ( expression ) statement 	0
} 
selection_statement -> SWITCH ( expression ) statement 	0
} 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
type_specifier -> CHAR 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
storage_class_specifier -> STATIC 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
type_specifier -> FLOAT 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_specifier -> TYPE_NAME 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_specifier -> LONG 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_specifier -> VOID 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_specifier -> INT 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_specifier -> DOUBLE 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_specifier -> UNSIGNED 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_specifier -> enum_specifier 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; 
type_qualifier -> CONST 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
inclusive_or_expression -> exclusive_or_expression 	0
OR_OP ? ; | 
storage_class_specifier -> AUTO 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
expression -> assignment_expression 	0
; , 
storage_class_specifier -> TYPEDEF 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
type_qualifier -> VOLATILE 	0
INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT CHAR * ( ; STRUCT REGISTER STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
expression -> expression , assignment_expression 	0
; , 
struct_or_union_specifier -> struct_or_union IDENTIFIER 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; 
enum_specifier -> ENUM { enumerator_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; 
enum_specifier -> ENUM IDENTIFIER 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; 
assignment_expression -> conditional_expression 	0
; 
assignment_expression -> unary_expression assignment_operator assignment_expression 	0
; 
struct_or_union -> STRUCT 	0
{ IDENTIFIER 
struct_or_union -> UNION 	0
{ IDENTIFIER 
conditional_expression -> logical_or_expression ? expression : conditional_expression 	0
; 
conditional_expression -> logical_or_expression 	0
; 
primary_expression -> IDENTIFIER 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
unary_expression -> DEC_OP unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
unary_expression -> SIZEOF ( type_name ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
unary_expression -> postfix_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
unary_expression -> INC_OP unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
unary_expression -> unary_operator cast_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
unary_expression -> SIZEOF unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
logical_or_expression -> logical_or_expression OR_OP logical_and_expression 	0
OR_OP ? ; 
logical_or_expression -> logical_and_expression 	0
OR_OP ? ; 
postfix_expression -> postfix_expression . IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> primary_expression 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression ( ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression INC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
logical_and_expression -> inclusive_or_expression 	0
? OR_OP ; AND_OP 
logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression 	0
? OR_OP ; AND_OP 
primary_expression -> CONSTANT 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
primary_expression -> ( expression ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
primary_expression -> STRING_LITERAL 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression 	0
OR_OP ? ; | 
exclusive_or_expression -> and_expression 	0
? OR_OP ; ^ 
and_expression -> equality_expression 	0
OR_OP ? ; & 
equality_expression -> equality_expression EQ_OP relational_expression 	0
NE_OP ? OR_OP ; EQ_OP 
equality_expression -> relational_expression 	0
NE_OP ? OR_OP ; EQ_OP 
equality_expression -> equality_expression NE_OP relational_expression 	0
NE_OP ? OR_OP ; EQ_OP 
relational_expression -> shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression < shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression > shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression LE_OP shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression GE_OP shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
shift_expression -> additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP < RIGHT_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP < RIGHT_OP 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP < RIGHT_OP 
additive_expression -> multiplicative_expression 	0
OR_OP ? + ; < EQ_OP - 
additive_expression -> additive_expression - multiplicative_expression 	0
OR_OP ? + ; < EQ_OP - 
multiplicative_expression -> cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
cast_expression -> ( type_name ) cast_expression 	0
OR_OP ? ; < EQ_OP * 
cast_expression -> unary_expression 	0
OR_OP ? ; < EQ_OP * 

141 1
statement -> jump_statement 	1
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 

142 1
statement -> labeled_statement 	1
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 

143 1
statement -> selection_statement 	1
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 

144 1
statement -> iteration_statement 	1
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 

145 2
init_declarator -> declarator 	1
; , 
init_declarator -> declarator = initializer 	1
; , 

146 1
function_definition -> declarator declaration_list compound_statement 	3
STATIC LONG $ INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT FLOAT STRUCT REGISTER UNION CONST CHAR * UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID ENUM 

147 1
declaration_list -> declaration_list declaration 	2
; { STRUCT REGISTER VOLATILE SIGNED TYPE_NAME SHORT STATIC STRING_LITERAL TYPEDEF DO UNION CONST EXTERN AUTO DOUBLE RETURN VOID * CHAR FLOAT IDENTIFIER DEFAULT INT DEC_OP LONG IF UNSIGNED ENUM } WHILE GOTO CASE - BREAK FOR CONTINUE SIZEOF INC_OP SWITCH CONSTANT ( & ~ + ! 

148 2
enumerator_list -> enumerator_list , enumerator 	1
} , 
enum_specifier -> ENUM IDENTIFIER { enumerator_list } 	4
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; : [ ) , 

149 58
enumerator -> IDENTIFIER = constant_expression 	2
} , 
postfix_expression -> primary_expression 	0
? OR_OP } < , EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
constant_expression -> conditional_expression 	0
} , 
conditional_expression -> logical_or_expression 	0
} , 
postfix_expression -> postfix_expression . IDENTIFIER 	0
? OR_OP } < , EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
conditional_expression -> logical_or_expression ? expression : conditional_expression 	0
} , 
logical_and_expression -> inclusive_or_expression 	0
? OR_OP } , AND_OP 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
/ OR_OP ? % } EQ_OP , < * 
logical_or_expression -> logical_or_expression OR_OP logical_and_expression 	0
OR_OP ? } , 
logical_or_expression -> logical_and_expression 	0
OR_OP ? } , 
cast_expression -> unary_expression 	0
OR_OP ? } < , EQ_OP * 
logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression 	0
? OR_OP } , AND_OP 
unary_expression -> SIZEOF unary_expression 	0
? OR_OP } EQ_OP , < * 
inclusive_or_expression -> exclusive_or_expression 	0
OR_OP ? } | , 
inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression 	0
OR_OP ? } | , 
and_expression -> and_expression & equality_expression 	0
OR_OP ? } , & 
exclusive_or_expression -> and_expression 	0
? OR_OP } , ^ 
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	0
? OR_OP } , ^ 
and_expression -> equality_expression 	0
OR_OP ? } , & 
unary_expression -> SIZEOF ( type_name ) 	0
? OR_OP } EQ_OP , < * 
equality_expression -> equality_expression EQ_OP relational_expression 	0
NE_OP ? OR_OP } EQ_OP , 
unary_expression -> INC_OP unary_expression 	0
? OR_OP } EQ_OP , < * 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
? OR_OP } < , EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
equality_expression -> relational_expression 	0
NE_OP ? OR_OP } EQ_OP , 
equality_expression -> equality_expression NE_OP relational_expression 	0
NE_OP ? OR_OP } EQ_OP , 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
relational_expression -> relational_expression < shift_expression 	0
? OR_OP LE_OP } < , EQ_OP > GE_OP 
relational_expression -> shift_expression 	0
? OR_OP LE_OP } < , EQ_OP > GE_OP 
multiplicative_expression -> cast_expression 	0
/ OR_OP ? % } EQ_OP , < * 
relational_expression -> relational_expression > shift_expression 	0
? OR_OP LE_OP } < , EQ_OP > GE_OP 
relational_expression -> relational_expression LE_OP shift_expression 	0
? OR_OP LE_OP } < , EQ_OP > GE_OP 
unary_expression -> unary_operator cast_expression 	0
? OR_OP } EQ_OP , < * 
relational_expression -> relational_expression GE_OP shift_expression 	0
? OR_OP LE_OP } < , EQ_OP > GE_OP 
shift_expression -> additive_expression 	0
? OR_OP } EQ_OP , < LEFT_OP RIGHT_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	0
? OR_OP } EQ_OP , < LEFT_OP RIGHT_OP 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
? OR_OP } EQ_OP , < LEFT_OP RIGHT_OP 
primary_expression -> CONSTANT 	0
? OR_OP } EQ_OP , < * . ( 
additive_expression -> multiplicative_expression 	0
OR_OP ? - } < , EQ_OP + 
additive_expression -> additive_expression + multiplicative_expression 	0
OR_OP ? - } < , EQ_OP + 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
additive_expression -> additive_expression - multiplicative_expression 	0
OR_OP ? - } < , EQ_OP + 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
/ OR_OP ? % } EQ_OP , < * 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
/ OR_OP ? % } EQ_OP , < * 
cast_expression -> ( type_name ) cast_expression 	0
OR_OP ? } < , EQ_OP * 
unary_expression -> DEC_OP unary_expression 	0
? OR_OP } EQ_OP , < * 
primary_expression -> IDENTIFIER 	0
? OR_OP } EQ_OP , < * . ( 
unary_expression -> postfix_expression 	0
? OR_OP } EQ_OP , < * 
postfix_expression -> postfix_expression ( ) 	0
? OR_OP } < , EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
? OR_OP } < , EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression INC_OP 	0
? OR_OP } < , EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
? OR_OP } < , EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
? OR_OP } < , EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
primary_expression -> ( expression ) 	0
? OR_OP } EQ_OP , < * . ( 
primary_expression -> STRING_LITERAL 	0
? OR_OP } EQ_OP , < * . ( 

150 3
enumerator_list -> enumerator_list , enumerator 	2
} , 
enumerator -> IDENTIFIER = constant_expression 	0
} , 
enumerator -> IDENTIFIER 	0
} , 

151 1
enum_specifier -> ENUM { enumerator_list } 	4
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; : [ ) , 

152 29
struct_or_union_specifier -> struct_or_union IDENTIFIER { struct_declaration_list } 	4
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; : [ ) , 
type_qualifier -> VOLATILE 	0
TYPE_NAME SIGNED FLOAT * CHAR SHORT VOID DOUBLE IDENTIFIER INT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT : ( 
specifier_qualifier_list -> type_specifier 	0
* : IDENTIFIER ( 
specifier_qualifier_list -> type_qualifier specifier_qualifier_list 	0
* : IDENTIFIER ( 
struct_declaration -> specifier_qualifier_list struct_declarator_list ; 	0
DOUBLE } FLOAT CHAR SIGNED TYPE_NAME SHORT VOID INT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
struct_declaration_list -> struct_declaration_list struct_declaration 	1
} DOUBLE SHORT SIGNED TYPE_NAME CHAR FLOAT VOID INT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 
type_specifier -> struct_or_union_specifier 	0
* CHAR SHORT SIGNED TYPE_NAME : INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
specifier_qualifier_list -> type_specifier specifier_qualifier_list 	0
* : IDENTIFIER ( 
type_specifier -> CHAR 	0
* CHAR SHORT SIGNED TYPE_NAME : INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
specifier_qualifier_list -> type_qualifier 	0
* : IDENTIFIER ( 
type_qualifier -> CONST 	0
TYPE_NAME SIGNED FLOAT * CHAR SHORT VOID DOUBLE IDENTIFIER INT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT : ( 
type_specifier -> FLOAT 	0
* CHAR SHORT SIGNED TYPE_NAME : INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> TYPE_NAME 	0
* CHAR SHORT SIGNED TYPE_NAME : INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> SHORT 	0
* CHAR SHORT SIGNED TYPE_NAME : INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> VOID 	0
* CHAR SHORT SIGNED TYPE_NAME : INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> LONG 	0
* CHAR SHORT SIGNED TYPE_NAME : INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> INT 	0
* CHAR SHORT SIGNED TYPE_NAME : INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> DOUBLE 	0
* CHAR SHORT SIGNED TYPE_NAME : INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> SIGNED 	0
* CHAR SHORT SIGNED TYPE_NAME : INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> UNSIGNED 	0
* CHAR SHORT SIGNED TYPE_NAME : INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> enum_specifier 	0
* CHAR SHORT SIGNED TYPE_NAME : INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
struct_or_union_specifier -> struct_or_union { struct_declaration_list } 	0
: SIGNED TYPE_NAME SHORT * CHAR INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 
struct_or_union_specifier -> struct_or_union IDENTIFIER { struct_declaration_list } 	0
: SIGNED TYPE_NAME SHORT * CHAR INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 
enum_specifier -> ENUM IDENTIFIER { enumerator_list } 	0
: SIGNED TYPE_NAME SHORT * CHAR INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 
struct_or_union_specifier -> struct_or_union IDENTIFIER 	0
: SIGNED TYPE_NAME SHORT * CHAR INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 
enum_specifier -> ENUM { enumerator_list } 	0
: SIGNED TYPE_NAME SHORT * CHAR INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 
enum_specifier -> ENUM IDENTIFIER 	0
: SIGNED TYPE_NAME SHORT * CHAR INT IDENTIFIER VOID ( DOUBLE FLOAT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 
struct_or_union -> STRUCT 	0
{ IDENTIFIER 
struct_or_union -> UNION 	0
{ IDENTIFIER 

153 1
specifier_qualifier_list -> type_specifier specifier_qualifier_list 	2
* : IDENTIFIER ( [ ) 

154 1
specifier_qualifier_list -> type_qualifier specifier_qualifier_list 	2
* : IDENTIFIER ( [ ) 

155 1
struct_or_union_specifier -> struct_or_union { struct_declaration_list } 	4
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; : [ ) , 

156 1
struct_declaration_list -> struct_declaration_list struct_declaration 	2
DOUBLE } FLOAT CHAR SIGNED TYPE_NAME SHORT VOID INT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 

157 58
struct_declarator -> : constant_expression 	1
; , 
constant_expression -> conditional_expression 	0
; , 
conditional_expression -> logical_or_expression 	0
; , 
postfix_expression -> postfix_expression . IDENTIFIER 	0
? OR_OP ; < , EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
conditional_expression -> logical_or_expression ? expression : conditional_expression 	0
; , 
logical_and_expression -> inclusive_or_expression 	0
? OR_OP ; , AND_OP 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
/ OR_OP ? ; EQ_OP , < * % 
logical_or_expression -> logical_or_expression OR_OP logical_and_expression 	0
OR_OP ? ; , 
logical_or_expression -> logical_and_expression 	0
OR_OP ? ; , 
cast_expression -> unary_expression 	0
OR_OP ? ; < , EQ_OP * 
logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression 	0
? OR_OP ; , AND_OP 
unary_expression -> SIZEOF unary_expression 	0
? OR_OP ; EQ_OP , < * 
inclusive_or_expression -> exclusive_or_expression 	0
OR_OP ? ; | , 
inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression 	0
OR_OP ? ; | , 
and_expression -> and_expression & equality_expression 	0
OR_OP ? ; , & 
exclusive_or_expression -> and_expression 	0
? OR_OP ; , ^ 
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	0
? OR_OP ; , ^ 
and_expression -> equality_expression 	0
OR_OP ? ; , & 
unary_expression -> SIZEOF ( type_name ) 	0
? OR_OP ; EQ_OP , < * 
equality_expression -> equality_expression EQ_OP relational_expression 	0
NE_OP ? OR_OP ; EQ_OP , 
unary_expression -> INC_OP unary_expression 	0
? OR_OP ; EQ_OP , < * 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
? OR_OP ; < , EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
equality_expression -> relational_expression 	0
NE_OP ? OR_OP ; EQ_OP , 
equality_expression -> equality_expression NE_OP relational_expression 	0
NE_OP ? OR_OP ; EQ_OP , 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
relational_expression -> relational_expression < shift_expression 	0
? OR_OP ; < , EQ_OP > LE_OP GE_OP 
relational_expression -> shift_expression 	0
? OR_OP ; < , EQ_OP > LE_OP GE_OP 
multiplicative_expression -> cast_expression 	0
/ OR_OP ? ; EQ_OP , < * % 
relational_expression -> relational_expression > shift_expression 	0
? OR_OP ; < , EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression LE_OP shift_expression 	0
? OR_OP ; < , EQ_OP > LE_OP GE_OP 
unary_expression -> unary_operator cast_expression 	0
? OR_OP ; EQ_OP , < * 
relational_expression -> relational_expression GE_OP shift_expression 	0
? OR_OP ; < , EQ_OP > LE_OP GE_OP 
shift_expression -> additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP , < RIGHT_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP , < RIGHT_OP 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP , < RIGHT_OP 
primary_expression -> CONSTANT 	0
? OR_OP ; EQ_OP , < * . ( 
additive_expression -> multiplicative_expression 	0
OR_OP ? + ; < , EQ_OP - 
additive_expression -> additive_expression + multiplicative_expression 	0
OR_OP ? + ; < , EQ_OP - 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
additive_expression -> additive_expression - multiplicative_expression 	0
OR_OP ? + ; < , EQ_OP - 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
/ OR_OP ? ; EQ_OP , < * % 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
/ OR_OP ? ; EQ_OP , < * % 
cast_expression -> ( type_name ) cast_expression 	0
OR_OP ? ; < , EQ_OP * 
unary_expression -> DEC_OP unary_expression 	0
? OR_OP ; EQ_OP , < * 
primary_expression -> IDENTIFIER 	0
? OR_OP ; EQ_OP , < * . ( 
unary_expression -> postfix_expression 	0
? OR_OP ; EQ_OP , < * 
postfix_expression -> primary_expression 	0
? OR_OP ; < , EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression ( ) 	0
? OR_OP ; < , EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
? OR_OP ; < , EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression INC_OP 	0
? OR_OP ; < , EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
? OR_OP ; < , EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
? OR_OP ; < , EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
primary_expression -> ( expression ) 	0
? OR_OP ; EQ_OP , < * . ( 
primary_expression -> STRING_LITERAL 	0
? OR_OP ; EQ_OP , < * . ( 

158 1
struct_declarator_list -> struct_declarator 	1
; , 

159 2
struct_declaration -> specifier_qualifier_list struct_declarator_list ; 	2
} DOUBLE SHORT SIGNED TYPE_NAME CHAR FLOAT VOID INT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 
struct_declarator_list -> struct_declarator_list , struct_declarator 	1
; , 

160 2
struct_declarator -> declarator : constant_expression 	1
; , 
struct_declarator -> declarator 	1
; , 

161 69
parameter_type_list -> parameter_list , ELLIPSIS 	0
) 
direct_abstract_declarator -> ( ) 	1
( [ ) , 
direct_declarator -> ( declarator ) 	1
( [ ) , 
declaration_specifiers -> storage_class_specifier declaration_specifiers 	0
IDENTIFIER * ( [ ) , 
parameter_type_list -> parameter_list 	0
) 
type_specifier -> struct_or_union_specifier 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
declaration_specifiers -> storage_class_specifier 	0
IDENTIFIER * ( [ ) , 
direct_abstract_declarator -> ( parameter_type_list ) 	1
( [ ) , 
declarator -> direct_declarator 	0
) 
parameter_list -> parameter_declaration 	0
) , 
direct_abstract_declarator -> ( abstract_declarator ) 	1
( [ ) , 
declarator -> pointer direct_declarator 	0
) 
abstract_declarator -> pointer direct_abstract_declarator 	0
) 
abstract_declarator -> pointer 	0
) 
abstract_declarator -> direct_abstract_declarator 	0
) 
direct_abstract_declarator -> direct_abstract_declarator [ constant_expression ] 	0
) ( [ 
direct_declarator -> direct_declarator ( ) 	0
) ( [ 
pointer -> * 	0
IDENTIFIER ( [ ) 
pointer -> * type_qualifier_list 	0
IDENTIFIER ( [ ) 
pointer -> * pointer 	0
IDENTIFIER ( [ ) 
direct_abstract_declarator -> ( parameter_type_list ) 	0
) ( [ 
pointer -> * type_qualifier_list pointer 	0
IDENTIFIER ( [ ) 
direct_abstract_declarator -> ( ) 	0
) ( [ 
direct_declarator -> ( declarator ) 	0
) ( [ 
storage_class_specifier -> TYPEDEF 	0
INT IDENTIFIER SIGNED TYPE_NAME SHORT CHAR * ( [ ) , STRUCT REGISTER VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
parameter_declaration -> declaration_specifiers abstract_declarator 	0
) , 
enum_specifier -> ENUM { enumerator_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( [ ) , 
direct_abstract_declarator -> direct_abstract_declarator [ ] 	0
) ( [ 
direct_declarator -> IDENTIFIER 	0
) ( [ 
direct_declarator -> direct_declarator ( parameter_type_list ) 	0
) ( [ 
direct_declarator -> direct_declarator [ ] 	0
) ( [ 
direct_abstract_declarator -> ( abstract_declarator ) 	0
) ( [ 
direct_declarator -> direct_declarator [ constant_expression ] 	0
) ( [ 
declaration_specifiers -> type_specifier declaration_specifiers 	0
IDENTIFIER * ( [ ) , 
direct_declarator -> direct_declarator ( identifier_list ) 	0
) ( [ 
parameter_list -> parameter_list , parameter_declaration 	0
) , 
parameter_declaration -> declaration_specifiers 	0
) , 
direct_abstract_declarator -> direct_abstract_declarator ( parameter_type_list ) 	0
) ( [ 
direct_abstract_declarator -> [ ] 	0
) ( [ 
type_qualifier -> VOLATILE 	0
INT IDENTIFIER SIGNED TYPE_NAME SHORT CHAR * ( [ ) , STRUCT REGISTER VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
direct_abstract_declarator -> [ constant_expression ] 	0
) ( [ 
type_specifier -> CHAR 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
direct_abstract_declarator -> direct_abstract_declarator ( ) 	0
) ( [ 
type_specifier -> LONG 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
type_specifier -> VOID 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
parameter_declaration -> declaration_specifiers declarator 	0
) , 
declaration_specifiers -> type_specifier 	0
IDENTIFIER * ( [ ) , 
type_specifier -> SIGNED 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
declaration_specifiers -> type_qualifier 	0
IDENTIFIER * ( [ ) , 
declaration_specifiers -> type_qualifier declaration_specifiers 	0
IDENTIFIER * ( [ ) , 
storage_class_specifier -> STATIC 	0
INT IDENTIFIER SIGNED TYPE_NAME SHORT CHAR * ( [ ) , STRUCT REGISTER VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
type_specifier -> FLOAT 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
type_specifier -> TYPE_NAME 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
storage_class_specifier -> EXTERN 	0
INT IDENTIFIER SIGNED TYPE_NAME SHORT CHAR * ( [ ) , STRUCT REGISTER VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
type_specifier -> SHORT 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
type_specifier -> INT 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
type_specifier -> DOUBLE 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
type_specifier -> UNSIGNED 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
type_specifier -> enum_specifier 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
type_qualifier -> CONST 	0
INT IDENTIFIER SIGNED TYPE_NAME SHORT CHAR * ( [ ) , STRUCT REGISTER VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
storage_class_specifier -> AUTO 	0
INT IDENTIFIER SIGNED TYPE_NAME SHORT CHAR * ( [ ) , STRUCT REGISTER VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
storage_class_specifier -> REGISTER 	0
INT IDENTIFIER SIGNED TYPE_NAME SHORT CHAR * ( [ ) , STRUCT REGISTER VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
struct_or_union_specifier -> struct_or_union { struct_declaration_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( [ ) , 
enum_specifier -> ENUM IDENTIFIER { enumerator_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( [ ) , 
struct_or_union_specifier -> struct_or_union IDENTIFIER { struct_declaration_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( [ ) , 
struct_or_union_specifier -> struct_or_union IDENTIFIER 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( [ ) , 
enum_specifier -> ENUM IDENTIFIER 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( [ ) , 
struct_or_union -> STRUCT 	0
{ IDENTIFIER 
struct_or_union -> UNION 	0
{ IDENTIFIER 

162 59
direct_abstract_declarator -> [ ] 	1
( [ ) , 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
? OR_OP ] EQ_OP < LEFT_OP RIGHT_OP 
primary_expression -> CONSTANT 	0
? OR_OP ] EQ_OP < * . ( 
logical_or_expression -> logical_and_expression 	0
OR_OP ? ] 
cast_expression -> unary_expression 	0
OR_OP ? ] < EQ_OP * 
direct_abstract_declarator -> [ constant_expression ] 	1
( [ ) , 
equality_expression -> equality_expression EQ_OP relational_expression 	0
NE_OP ? OR_OP ] EQ_OP 
unary_expression -> INC_OP unary_expression 	0
? OR_OP ] EQ_OP < * 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
? OR_OP ] < EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
constant_expression -> conditional_expression 	0
] 
conditional_expression -> logical_or_expression 	0
] 
postfix_expression -> postfix_expression . IDENTIFIER 	0
? OR_OP ] < EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
conditional_expression -> logical_or_expression ? expression : conditional_expression 	0
] 
logical_and_expression -> inclusive_or_expression 	0
? OR_OP ] AND_OP 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
/ ? OR_OP % ] EQ_OP < * 
logical_or_expression -> logical_or_expression OR_OP logical_and_expression 	0
OR_OP ? ] 
logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression 	0
? OR_OP ] AND_OP 
unary_expression -> SIZEOF unary_expression 	0
? OR_OP ] EQ_OP < * 
inclusive_or_expression -> exclusive_or_expression 	0
OR_OP ? ] | 
inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression 	0
OR_OP ? ] | 
and_expression -> and_expression & equality_expression 	0
OR_OP ? ] & 
exclusive_or_expression -> and_expression 	0
? OR_OP ] ^ 
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	0
? OR_OP ] ^ 
and_expression -> equality_expression 	0
OR_OP ? ] & 
unary_expression -> SIZEOF ( type_name ) 	0
? OR_OP ] EQ_OP < * 
equality_expression -> relational_expression 	0
NE_OP ? OR_OP ] EQ_OP 
equality_expression -> equality_expression NE_OP relational_expression 	0
NE_OP ? OR_OP ] EQ_OP 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
relational_expression -> relational_expression < shift_expression 	0
OR_OP ? LE_OP ] < EQ_OP > GE_OP 
relational_expression -> shift_expression 	0
OR_OP ? LE_OP ] < EQ_OP > GE_OP 
multiplicative_expression -> cast_expression 	0
/ ? OR_OP % ] EQ_OP < * 
relational_expression -> relational_expression > shift_expression 	0
OR_OP ? LE_OP ] < EQ_OP > GE_OP 
relational_expression -> relational_expression LE_OP shift_expression 	0
OR_OP ? LE_OP ] < EQ_OP > GE_OP 
unary_expression -> unary_operator cast_expression 	0
? OR_OP ] EQ_OP < * 
relational_expression -> relational_expression GE_OP shift_expression 	0
OR_OP ? LE_OP ] < EQ_OP > GE_OP 
shift_expression -> additive_expression 	0
? OR_OP ] EQ_OP < LEFT_OP RIGHT_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	0
? OR_OP ] EQ_OP < LEFT_OP RIGHT_OP 
additive_expression -> multiplicative_expression 	0
OR_OP ? - ] < EQ_OP + 
additive_expression -> additive_expression + multiplicative_expression 	0
OR_OP ? - ] < EQ_OP + 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
additive_expression -> additive_expression - multiplicative_expression 	0
OR_OP ? - ] < EQ_OP + 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
/ ? OR_OP % ] EQ_OP < * 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
/ ? OR_OP % ] EQ_OP < * 
cast_expression -> ( type_name ) cast_expression 	0
OR_OP ? ] < EQ_OP * 
unary_expression -> DEC_OP unary_expression 	0
? OR_OP ] EQ_OP < * 
primary_expression -> IDENTIFIER 	0
? OR_OP ] EQ_OP < * . ( 
unary_expression -> postfix_expression 	0
? OR_OP ] EQ_OP < * 
postfix_expression -> primary_expression 	0
? OR_OP ] < EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression ( ) 	0
? OR_OP ] < EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
? OR_OP ] < EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression INC_OP 	0
? OR_OP ] < EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
? OR_OP ] < EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
? OR_OP ] < EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
primary_expression -> ( expression ) 	0
? OR_OP ] EQ_OP < * . ( 
primary_expression -> STRING_LITERAL 	0
? OR_OP ] EQ_OP < * . ( 

163 1
parameter_declaration -> declaration_specifiers declarator 	2
) , 

164 5
abstract_declarator -> direct_abstract_declarator 	1
) , 
direct_abstract_declarator -> direct_abstract_declarator [ constant_expression ] 	1
( [ ) , 
direct_abstract_declarator -> direct_abstract_declarator [ ] 	1
( [ ) , 
direct_abstract_declarator -> direct_abstract_declarator ( parameter_type_list ) 	1
( [ ) , 
direct_abstract_declarator -> direct_abstract_declarator ( ) 	1
( [ ) , 

165 19
direct_declarator -> direct_declarator ( parameter_type_list ) 	0
) , ( [ 
declarator -> pointer direct_declarator 	1
) , 
direct_declarator -> direct_declarator [ ] 	0
) , ( [ 
abstract_declarator -> pointer direct_abstract_declarator 	1
) , 
direct_declarator -> IDENTIFIER 	0
) , ( [ 
direct_abstract_declarator -> direct_abstract_declarator [ ] 	0
) , ( [ 
abstract_declarator -> pointer 	1
) , 
direct_declarator -> ( declarator ) 	0
) , ( [ 
direct_abstract_declarator -> ( ) 	0
) , ( [ 
direct_declarator -> direct_declarator [ constant_expression ] 	0
) , ( [ 
direct_abstract_declarator -> ( abstract_declarator ) 	0
) , ( [ 
direct_declarator -> direct_declarator ( identifier_list ) 	0
) , ( [ 
direct_declarator -> direct_declarator ( ) 	0
) , ( [ 
direct_abstract_declarator -> direct_abstract_declarator [ constant_expression ] 	0
) , ( [ 
direct_abstract_declarator -> direct_abstract_declarator ( parameter_type_list ) 	0
) , ( [ 
direct_abstract_declarator -> [ ] 	0
) , ( [ 
direct_abstract_declarator -> [ constant_expression ] 	0
) , ( [ 
direct_abstract_declarator -> direct_abstract_declarator ( ) 	0
) , ( [ 
direct_abstract_declarator -> ( parameter_type_list ) 	0
) , ( [ 

166 1
parameter_declaration -> declaration_specifiers abstract_declarator 	2
) , 

167 1
direct_declarator -> direct_declarator ( identifier_list ) 	4
; { SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC TYPEDEF CONST UNION EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ ) = , : 

168 1
identifier_list -> identifier_list , IDENTIFIER 	2
) , 

169 1
direct_declarator -> direct_declarator ( parameter_type_list ) 	4
; { SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC TYPEDEF CONST UNION EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ ) = , : 

170 38
parameter_type_list -> parameter_list , ELLIPSIS 	2
) 
parameter_declaration -> declaration_specifiers 	0
) , 
parameter_list -> parameter_list , parameter_declaration 	2
) , 
parameter_declaration -> declaration_specifiers declarator 	0
) , 
type_specifier -> VOID 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
type_specifier -> LONG 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
parameter_declaration -> declaration_specifiers abstract_declarator 	0
) , 
storage_class_specifier -> TYPEDEF 	0
INT IDENTIFIER SIGNED TYPE_NAME SHORT CHAR * ( [ ) , STRUCT REGISTER VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
enum_specifier -> ENUM { enumerator_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( [ ) , 
declaration_specifiers -> storage_class_specifier declaration_specifiers 	0
IDENTIFIER * ( [ ) , 
declaration_specifiers -> storage_class_specifier 	0
IDENTIFIER * ( [ ) , 
type_specifier -> struct_or_union_specifier 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
declaration_specifiers -> type_specifier 	0
IDENTIFIER * ( [ ) , 
declaration_specifiers -> type_specifier declaration_specifiers 	0
IDENTIFIER * ( [ ) , 
declaration_specifiers -> type_qualifier 	0
IDENTIFIER * ( [ ) , 
type_specifier -> SIGNED 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
declaration_specifiers -> type_qualifier declaration_specifiers 	0
IDENTIFIER * ( [ ) , 
type_specifier -> CHAR 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
type_specifier -> FLOAT 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
storage_class_specifier -> STATIC 	0
INT IDENTIFIER SIGNED TYPE_NAME SHORT CHAR * ( [ ) , STRUCT REGISTER VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
type_specifier -> TYPE_NAME 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
type_specifier -> SHORT 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
storage_class_specifier -> EXTERN 	0
INT IDENTIFIER SIGNED TYPE_NAME SHORT CHAR * ( [ ) , STRUCT REGISTER VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
type_specifier -> INT 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
type_specifier -> DOUBLE 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
type_specifier -> UNSIGNED 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
type_specifier -> enum_specifier 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
storage_class_specifier -> AUTO 	0
INT IDENTIFIER SIGNED TYPE_NAME SHORT CHAR * ( [ ) , STRUCT REGISTER VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
type_qualifier -> CONST 	0
INT IDENTIFIER SIGNED TYPE_NAME SHORT CHAR * ( [ ) , STRUCT REGISTER VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
storage_class_specifier -> REGISTER 	0
INT IDENTIFIER SIGNED TYPE_NAME SHORT CHAR * ( [ ) , STRUCT REGISTER VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
type_qualifier -> VOLATILE 	0
INT IDENTIFIER SIGNED TYPE_NAME SHORT CHAR * ( [ ) , STRUCT REGISTER VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
struct_or_union_specifier -> struct_or_union { struct_declaration_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( [ ) , 
struct_or_union_specifier -> struct_or_union IDENTIFIER { struct_declaration_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( [ ) , 
enum_specifier -> ENUM IDENTIFIER { enumerator_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( [ ) , 
struct_or_union_specifier -> struct_or_union IDENTIFIER 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( [ ) , 
enum_specifier -> ENUM IDENTIFIER 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( [ ) , 
struct_or_union -> STRUCT 	0
{ IDENTIFIER 
struct_or_union -> UNION 	0
{ IDENTIFIER 

171 61
conditional_expression -> logical_or_expression 	0
) 
postfix_expression -> postfix_expression . IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
conditional_expression -> logical_or_expression ? expression : conditional_expression 	0
) 
primary_expression -> ( expression ) 	1
. ( ? OR_OP ] MUL_ASSIGN EQ_OP | < GE_OP MOD_ASSIGN * LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
expression -> expression , assignment_expression 	0
) , 
primary_expression -> STRING_LITERAL 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
expression -> assignment_expression 	0
) , 
primary_expression -> ( expression ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
unary_expression -> SIZEOF ( type_name ) 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
and_expression -> equality_expression 	0
OR_OP ? ) & 
assignment_expression -> conditional_expression 	0
) 
assignment_expression -> unary_expression assignment_operator assignment_expression 	0
) 
unary_expression -> DEC_OP unary_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
primary_expression -> IDENTIFIER 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
unary_expression -> postfix_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
unary_expression -> INC_OP unary_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
equality_expression -> equality_expression EQ_OP relational_expression 	0
NE_OP ? OR_OP ) EQ_OP 
unary_expression -> unary_operator cast_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
relational_expression -> relational_expression LE_OP shift_expression 	0
OR_OP ? ) < EQ_OP > LE_OP GE_OP 
unary_expression -> SIZEOF unary_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression 	0
? OR_OP AND_OP ) 
logical_or_expression -> logical_or_expression OR_OP logical_and_expression 	0
OR_OP ? ) 
logical_or_expression -> logical_and_expression 	0
OR_OP ? ) 
cast_expression -> unary_expression 	0
OR_OP ? ) < EQ_OP * 
postfix_expression -> primary_expression 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression ( ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression INC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
equality_expression -> equality_expression NE_OP relational_expression 	0
NE_OP ? OR_OP ) EQ_OP 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
additive_expression -> additive_expression + multiplicative_expression 	0
OR_OP ? ) < EQ_OP + - 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
logical_and_expression -> inclusive_or_expression 	0
? OR_OP AND_OP ) 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
/ ? OR_OP ) EQ_OP < * % 
primary_expression -> CONSTANT 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
? OR_OP ) EQ_OP < LEFT_OP RIGHT_OP 
inclusive_or_expression -> exclusive_or_expression 	0
OR_OP ? ) | 
inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression 	0
OR_OP ? ) | 
and_expression -> and_expression & equality_expression 	0
OR_OP ? ) & 
exclusive_or_expression -> and_expression 	0
? OR_OP ) ^ 
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	0
? OR_OP ) ^ 
equality_expression -> relational_expression 	0
NE_OP ? OR_OP ) EQ_OP 
relational_expression -> relational_expression < shift_expression 	0
OR_OP ? ) < EQ_OP > LE_OP GE_OP 
relational_expression -> shift_expression 	0
OR_OP ? ) < EQ_OP > LE_OP GE_OP 
multiplicative_expression -> cast_expression 	0
/ ? OR_OP ) EQ_OP < * % 
relational_expression -> relational_expression > shift_expression 	0
OR_OP ? ) < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression GE_OP shift_expression 	0
OR_OP ? ) < EQ_OP > LE_OP GE_OP 
shift_expression -> additive_expression 	0
? OR_OP ) EQ_OP < LEFT_OP RIGHT_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	0
? OR_OP ) EQ_OP < LEFT_OP RIGHT_OP 
additive_expression -> multiplicative_expression 	0
OR_OP ? ) < EQ_OP + - 
additive_expression -> additive_expression - multiplicative_expression 	0
OR_OP ? ) < EQ_OP + - 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
/ ? OR_OP ) EQ_OP < * % 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
/ ? OR_OP ) EQ_OP < * % 
cast_expression -> ( type_name ) cast_expression 	0
OR_OP ? ) < EQ_OP * 

172 1
unary_expression -> DEC_OP unary_expression 	2
? OR_OP ] MUL_ASSIGN EQ_OP | < * GE_OP MOD_ASSIGN LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 

173 2
primary_expression -> ( expression ) 	2
? OR_OP ] MUL_ASSIGN EQ_OP | < * . ( DIV_ASSIGN ) LEFT_ASSIGN GE_OP MOD_ASSIGN } = ADD_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
expression -> expression , assignment_expression 	1
) , 

174 1
cast_expression -> ( type_name ) cast_expression 	2
OR_OP ? ] | < MUL_ASSIGN EQ_OP * : XOR_ASSIGN ; LEFT_ASSIGN ) ADD_ASSIGN = } , MOD_ASSIGN GE_OP DIV_ASSIGN RIGHT_ASSIGN SUB_ASSIGN AND_ASSIGN OR_ASSIGN / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 

175 18
abstract_declarator -> pointer direct_abstract_declarator 	0
) 
type_name -> specifier_qualifier_list 	1
) 
type_name -> specifier_qualifier_list abstract_declarator 	1
) 
direct_abstract_declarator -> ( ) 	0
) ( [ 
pointer -> * type_qualifier_list 	0
( [ ) 
pointer -> * 	0
( [ ) 
direct_abstract_declarator -> direct_abstract_declarator [ constant_expression ] 	0
) ( [ 
abstract_declarator -> pointer 	0
) 
abstract_declarator -> direct_abstract_declarator 	0
) 
pointer -> * type_qualifier_list pointer 	0
( [ ) 
direct_abstract_declarator -> ( parameter_type_list ) 	0
) ( [ 
pointer -> * pointer 	0
( [ ) 
direct_abstract_declarator -> direct_abstract_declarator ( parameter_type_list ) 	0
) ( [ 
direct_abstract_declarator -> [ ] 	0
) ( [ 
direct_abstract_declarator -> [ constant_expression ] 	0
) ( [ 
direct_abstract_declarator -> direct_abstract_declarator ( ) 	0
) ( [ 
direct_abstract_declarator -> ( abstract_declarator ) 	0
) ( [ 
direct_abstract_declarator -> direct_abstract_declarator [ ] 	0
) ( [ 

176 1
unary_expression -> INC_OP unary_expression 	2
? OR_OP ] MUL_ASSIGN EQ_OP | < * GE_OP MOD_ASSIGN LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 

177 90
postfix_expression -> postfix_expression ( ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
specifier_qualifier_list -> type_qualifier specifier_qualifier_list 	0
* ( [ ) 
conditional_expression -> logical_or_expression ? expression : conditional_expression 	0
) 
primary_expression -> ( expression ) 	1
. ( ? OR_OP ] MUL_ASSIGN EQ_OP | < GE_OP MOD_ASSIGN * LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
specifier_qualifier_list -> type_specifier 	0
* ( [ ) 
unary_expression -> SIZEOF ( type_name ) 	2
? OR_OP ] MUL_ASSIGN EQ_OP | < * GE_OP MOD_ASSIGN LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
primary_expression -> STRING_LITERAL 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
expression -> expression , assignment_expression 	0
) , 
primary_expression -> ( expression ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
enum_specifier -> ENUM { enumerator_list } 	0
SIGNED TYPE_NAME SHORT * CHAR ( VOID [ ) DOUBLE INT FLOAT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 
expression -> assignment_expression 	0
) , 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
type_name -> specifier_qualifier_list abstract_declarator 	0
) 
unary_expression -> INC_OP unary_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
struct_or_union_specifier -> struct_or_union { struct_declaration_list } 	0
SIGNED TYPE_NAME SHORT * CHAR ( VOID [ ) DOUBLE INT FLOAT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 
type_name -> specifier_qualifier_list 	0
) 
type_specifier -> FLOAT 	0
* CHAR SHORT SIGNED TYPE_NAME VOID ( [ ) DOUBLE INT FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
assignment_expression -> conditional_expression 	0
) 
assignment_expression -> unary_expression assignment_operator assignment_expression 	0
) 
specifier_qualifier_list -> type_qualifier 	0
* ( [ ) 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
type_specifier -> CHAR 	0
* CHAR SHORT SIGNED TYPE_NAME VOID ( [ ) DOUBLE INT FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
specifier_qualifier_list -> type_specifier specifier_qualifier_list 	0
* ( [ ) 
postfix_expression -> postfix_expression . IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
type_qualifier -> VOLATILE 	0
TYPE_NAME SIGNED FLOAT * CHAR SHORT VOID DOUBLE INT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT ( [ ) 
conditional_expression -> logical_or_expression 	0
) 
primary_expression -> IDENTIFIER 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
unary_expression -> DEC_OP unary_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
unary_expression -> SIZEOF ( type_name ) 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
type_specifier -> INT 	0
* CHAR SHORT SIGNED TYPE_NAME VOID ( [ ) DOUBLE INT FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
unary_expression -> postfix_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
unary_expression -> unary_operator cast_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression 	0
? OR_OP AND_OP ) 
unary_expression -> SIZEOF unary_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
inclusive_or_expression -> exclusive_or_expression 	0
OR_OP ? ) | 
type_qualifier -> CONST 	0
TYPE_NAME SIGNED FLOAT * CHAR SHORT VOID DOUBLE INT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT ( [ ) 
type_specifier -> TYPE_NAME 	0
* CHAR SHORT SIGNED TYPE_NAME VOID ( [ ) DOUBLE INT FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
postfix_expression -> primary_expression 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
type_specifier -> SHORT 	0
* CHAR SHORT SIGNED TYPE_NAME VOID ( [ ) DOUBLE INT FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
type_specifier -> LONG 	0
* CHAR SHORT SIGNED TYPE_NAME VOID ( [ ) DOUBLE INT FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> VOID 	0
* CHAR SHORT SIGNED TYPE_NAME VOID ( [ ) DOUBLE INT FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> DOUBLE 	0
* CHAR SHORT SIGNED TYPE_NAME VOID ( [ ) DOUBLE INT FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
logical_or_expression -> logical_or_expression OR_OP logical_and_expression 	0
OR_OP ? ) 
type_specifier -> SIGNED 	0
* CHAR SHORT SIGNED TYPE_NAME VOID ( [ ) DOUBLE INT FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> UNSIGNED 	0
* CHAR SHORT SIGNED TYPE_NAME VOID ( [ ) DOUBLE INT FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> struct_or_union_specifier 	0
* CHAR SHORT SIGNED TYPE_NAME VOID ( [ ) DOUBLE INT FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
type_specifier -> enum_specifier 	0
* CHAR SHORT SIGNED TYPE_NAME VOID ( [ ) DOUBLE INT FLOAT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 
logical_or_expression -> logical_and_expression 	0
OR_OP ? ) 
postfix_expression -> postfix_expression INC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
enum_specifier -> ENUM IDENTIFIER { enumerator_list } 	0
SIGNED TYPE_NAME SHORT * CHAR ( VOID [ ) DOUBLE INT FLOAT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 
struct_or_union_specifier -> struct_or_union IDENTIFIER { struct_declaration_list } 	0
SIGNED TYPE_NAME SHORT * CHAR ( VOID [ ) DOUBLE INT FLOAT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
struct_or_union_specifier -> struct_or_union IDENTIFIER 	0
SIGNED TYPE_NAME SHORT * CHAR ( VOID [ ) DOUBLE INT FLOAT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 
enum_specifier -> ENUM IDENTIFIER 	0
SIGNED TYPE_NAME SHORT * CHAR ( VOID [ ) DOUBLE INT FLOAT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 
logical_and_expression -> inclusive_or_expression 	0
? OR_OP AND_OP ) 
primary_expression -> CONSTANT 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
struct_or_union -> STRUCT 	0
{ IDENTIFIER 
struct_or_union -> UNION 	0
{ IDENTIFIER 
inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression 	0
OR_OP ? ) | 
exclusive_or_expression -> and_expression 	0
? OR_OP ) ^ 
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	0
? OR_OP ) ^ 
and_expression -> equality_expression 	0
OR_OP ? ) & 
and_expression -> and_expression & equality_expression 	0
OR_OP ? ) & 
equality_expression -> equality_expression EQ_OP relational_expression 	0
NE_OP ? OR_OP ) EQ_OP 
equality_expression -> relational_expression 	0
NE_OP ? OR_OP ) EQ_OP 
equality_expression -> equality_expression NE_OP relational_expression 	0
NE_OP ? OR_OP ) EQ_OP 
relational_expression -> relational_expression < shift_expression 	0
OR_OP ? ) < EQ_OP > LE_OP GE_OP 
relational_expression -> shift_expression 	0
OR_OP ? ) < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression > shift_expression 	0
OR_OP ? ) < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression LE_OP shift_expression 	0
OR_OP ? ) < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression GE_OP shift_expression 	0
OR_OP ? ) < EQ_OP > LE_OP GE_OP 
shift_expression -> additive_expression 	0
? OR_OP ) EQ_OP < LEFT_OP RIGHT_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	0
? OR_OP ) EQ_OP < LEFT_OP RIGHT_OP 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
? OR_OP ) EQ_OP < LEFT_OP RIGHT_OP 
additive_expression -> multiplicative_expression 	0
OR_OP ? ) < EQ_OP + - 
additive_expression -> additive_expression + multiplicative_expression 	0
OR_OP ? ) < EQ_OP + - 
additive_expression -> additive_expression - multiplicative_expression 	0
OR_OP ? ) < EQ_OP + - 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
/ ? OR_OP ) EQ_OP < * % 
multiplicative_expression -> cast_expression 	0
/ ? OR_OP ) EQ_OP < * % 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
/ ? OR_OP ) EQ_OP < * % 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
/ ? OR_OP ) EQ_OP < * % 
cast_expression -> ( type_name ) cast_expression 	0
OR_OP ? ) < EQ_OP * 
cast_expression -> unary_expression 	0
OR_OP ? ) < EQ_OP * 

178 1
unary_expression -> SIZEOF unary_expression 	2
? OR_OP ] MUL_ASSIGN EQ_OP | < * GE_OP MOD_ASSIGN LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 

179 1
postfix_expression -> postfix_expression DEC_OP 	2
? OR_OP ] | < MUL_ASSIGN EQ_OP * . ( [ PTR_OP INC_OP DEC_OP LEFT_ASSIGN ) DIV_ASSIGN GE_OP MOD_ASSIGN = ADD_ASSIGN } SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 

180 1
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	2
? OR_OP ] | < MUL_ASSIGN EQ_OP * . ( [ PTR_OP INC_OP DEC_OP LEFT_ASSIGN ) DIV_ASSIGN GE_OP MOD_ASSIGN = ADD_ASSIGN } SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 

181 62
postfix_expression -> postfix_expression ( ) 	2
? OR_OP ] | < MUL_ASSIGN EQ_OP * . ( [ PTR_OP INC_OP DEC_OP LEFT_ASSIGN ) DIV_ASSIGN GE_OP MOD_ASSIGN = ADD_ASSIGN } SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
relational_expression -> relational_expression < shift_expression 	0
OR_OP ? ) < EQ_OP > LE_OP GE_OP 
relational_expression -> shift_expression 	0
OR_OP ? ) < EQ_OP > LE_OP GE_OP 
multiplicative_expression -> cast_expression 	0
/ ? OR_OP ) EQ_OP < * % 
postfix_expression -> postfix_expression ( argument_expression_list ) 	2
? OR_OP ] | < MUL_ASSIGN EQ_OP * . ( [ PTR_OP INC_OP DEC_OP LEFT_ASSIGN ) DIV_ASSIGN GE_OP MOD_ASSIGN = ADD_ASSIGN } SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	0
? OR_OP ) EQ_OP < LEFT_OP RIGHT_OP 
conditional_expression -> logical_or_expression 	0
) 
argument_expression_list -> assignment_expression 	0
) , 
postfix_expression -> postfix_expression . IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
conditional_expression -> logical_or_expression ? expression : conditional_expression 	0
) 
argument_expression_list -> argument_expression_list , assignment_expression 	0
) , 
primary_expression -> STRING_LITERAL 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
assignment_expression -> conditional_expression 	0
) 
assignment_expression -> unary_expression assignment_operator assignment_expression 	0
) 
unary_expression -> DEC_OP unary_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
primary_expression -> IDENTIFIER 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
unary_expression -> SIZEOF ( type_name ) 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
and_expression -> equality_expression 	0
OR_OP ? ) & 
unary_expression -> postfix_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
unary_expression -> INC_OP unary_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
equality_expression -> equality_expression EQ_OP relational_expression 	0
NE_OP ? OR_OP ) EQ_OP 
unary_expression -> unary_operator cast_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
relational_expression -> relational_expression LE_OP shift_expression 	0
OR_OP ? ) < EQ_OP > LE_OP GE_OP 
unary_expression -> SIZEOF unary_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression 	0
? OR_OP AND_OP ) 
logical_or_expression -> logical_or_expression OR_OP logical_and_expression 	0
OR_OP ? ) 
logical_or_expression -> logical_and_expression 	0
OR_OP ? ) 
cast_expression -> unary_expression 	0
OR_OP ? ) < EQ_OP * 
postfix_expression -> primary_expression 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression ( ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression INC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
equality_expression -> equality_expression NE_OP relational_expression 	0
NE_OP ? OR_OP ) EQ_OP 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
additive_expression -> additive_expression + multiplicative_expression 	0
OR_OP ? ) < EQ_OP + - 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
logical_and_expression -> inclusive_or_expression 	0
? OR_OP AND_OP ) 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
/ ? OR_OP ) EQ_OP < * % 
primary_expression -> CONSTANT 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
? OR_OP ) EQ_OP < LEFT_OP RIGHT_OP 
primary_expression -> ( expression ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
inclusive_or_expression -> exclusive_or_expression 	0
OR_OP ? ) | 
inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression 	0
OR_OP ? ) | 
and_expression -> and_expression & equality_expression 	0
OR_OP ? ) & 
exclusive_or_expression -> and_expression 	0
? OR_OP ) ^ 
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	0
? OR_OP ) ^ 
equality_expression -> relational_expression 	0
NE_OP ? OR_OP ) EQ_OP 
relational_expression -> relational_expression > shift_expression 	0
OR_OP ? ) < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression GE_OP shift_expression 	0
OR_OP ? ) < EQ_OP > LE_OP GE_OP 
shift_expression -> additive_expression 	0
? OR_OP ) EQ_OP < LEFT_OP RIGHT_OP 
additive_expression -> multiplicative_expression 	0
OR_OP ? ) < EQ_OP + - 
additive_expression -> additive_expression - multiplicative_expression 	0
OR_OP ? ) < EQ_OP + - 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
/ ? OR_OP ) EQ_OP < * % 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
/ ? OR_OP ) EQ_OP < * % 
cast_expression -> ( type_name ) cast_expression 	0
OR_OP ? ) < EQ_OP * 

182 61
expression -> expression , assignment_expression 	0
] , 
primary_expression -> STRING_LITERAL 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
expression -> assignment_expression 	0
] , 
primary_expression -> ( expression ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
postfix_expression -> postfix_expression [ expression ] 	2
? OR_OP ] | < MUL_ASSIGN EQ_OP * . ( [ PTR_OP INC_OP DEC_OP LEFT_ASSIGN ) DIV_ASSIGN GE_OP MOD_ASSIGN = ADD_ASSIGN } SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
shift_expression -> additive_expression 	0
? OR_OP ] EQ_OP < LEFT_OP RIGHT_OP 
unary_expression -> SIZEOF ( type_name ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP ] < * 
and_expression -> equality_expression 	0
OR_OP ? ] & 
assignment_expression -> conditional_expression 	0
] 
assignment_expression -> unary_expression assignment_operator assignment_expression 	0
] 
conditional_expression -> logical_or_expression 	0
] 
postfix_expression -> postfix_expression . IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
conditional_expression -> logical_or_expression ? expression : conditional_expression 	0
] 
unary_expression -> DEC_OP unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP ] < * 
primary_expression -> IDENTIFIER 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
unary_expression -> postfix_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP ] < * 
unary_expression -> INC_OP unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP ] < * 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
equality_expression -> equality_expression EQ_OP relational_expression 	0
NE_OP ? OR_OP ] EQ_OP 
unary_expression -> unary_operator cast_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP ] < * 
relational_expression -> relational_expression LE_OP shift_expression 	0
OR_OP ? LE_OP ] < EQ_OP > GE_OP 
unary_expression -> SIZEOF unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP ] < * 
logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression 	0
? OR_OP ] AND_OP 
logical_or_expression -> logical_or_expression OR_OP logical_and_expression 	0
OR_OP ? ] 
logical_or_expression -> logical_and_expression 	0
OR_OP ? ] 
cast_expression -> unary_expression 	0
OR_OP ? ] < EQ_OP * 
postfix_expression -> primary_expression 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression ( ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression INC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
equality_expression -> equality_expression NE_OP relational_expression 	0
NE_OP ? OR_OP ] EQ_OP 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
additive_expression -> additive_expression + multiplicative_expression 	0
OR_OP ? - ] < EQ_OP + 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
logical_and_expression -> inclusive_or_expression 	0
? OR_OP ] AND_OP 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
/ ? OR_OP % ] EQ_OP < * 
primary_expression -> CONSTANT 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
? OR_OP ] EQ_OP < LEFT_OP RIGHT_OP 
inclusive_or_expression -> exclusive_or_expression 	0
OR_OP ? ] | 
inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression 	0
OR_OP ? ] | 
and_expression -> and_expression & equality_expression 	0
OR_OP ? ] & 
exclusive_or_expression -> and_expression 	0
? OR_OP ] ^ 
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	0
? OR_OP ] ^ 
equality_expression -> relational_expression 	0
NE_OP ? OR_OP ] EQ_OP 
relational_expression -> relational_expression < shift_expression 	0
OR_OP ? LE_OP ] < EQ_OP > GE_OP 
relational_expression -> shift_expression 	0
OR_OP ? LE_OP ] < EQ_OP > GE_OP 
multiplicative_expression -> cast_expression 	0
/ ? OR_OP % ] EQ_OP < * 
relational_expression -> relational_expression > shift_expression 	0
OR_OP ? LE_OP ] < EQ_OP > GE_OP 
relational_expression -> relational_expression GE_OP shift_expression 	0
OR_OP ? LE_OP ] < EQ_OP > GE_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	0
? OR_OP ] EQ_OP < LEFT_OP RIGHT_OP 
additive_expression -> multiplicative_expression 	0
OR_OP ? - ] < EQ_OP + 
additive_expression -> additive_expression - multiplicative_expression 	0
OR_OP ? - ] < EQ_OP + 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
/ ? OR_OP % ] EQ_OP < * 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
/ ? OR_OP % ] EQ_OP < * 
cast_expression -> ( type_name ) cast_expression 	0
OR_OP ? ] < EQ_OP * 

183 1
postfix_expression -> postfix_expression . IDENTIFIER 	2
? OR_OP ] | < MUL_ASSIGN EQ_OP * . ( [ PTR_OP INC_OP DEC_OP LEFT_ASSIGN ) DIV_ASSIGN GE_OP MOD_ASSIGN = ADD_ASSIGN } SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 

184 1
postfix_expression -> postfix_expression INC_OP 	2
? OR_OP ] | < MUL_ASSIGN EQ_OP * . ( [ PTR_OP INC_OP DEC_OP LEFT_ASSIGN ) DIV_ASSIGN GE_OP MOD_ASSIGN = ADD_ASSIGN } SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 

185 1
unary_expression -> unary_operator cast_expression 	2
? OR_OP ] MUL_ASSIGN EQ_OP | < * GE_OP MOD_ASSIGN LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 

186 27
unary_expression -> SIZEOF unary_expression 	0
/ ? OR_OP % ] EQ_OP | < * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 
multiplicative_expression -> multiplicative_expression * cast_expression 	2
/ ? OR_OP % ] EQ_OP | < * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 
cast_expression -> ( type_name ) cast_expression 	0
? OR_OP / ] % | < EQ_OP * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 
unary_expression -> unary_operator cast_expression 	0
/ ? OR_OP % ] EQ_OP | < * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 
unary_expression -> INC_OP unary_expression 	0
/ ? OR_OP % ] EQ_OP | < * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
? OR_OP / ] % | < EQ_OP * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
unary_expression -> postfix_expression 	0
/ ? OR_OP % ] EQ_OP | < * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 
unary_expression -> DEC_OP unary_expression 	0
/ ? OR_OP % ] EQ_OP | < * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 
primary_expression -> IDENTIFIER 	0
/ ? OR_OP % ] EQ_OP | < * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP . ( 
cast_expression -> unary_expression 	0
? OR_OP / ] % | < EQ_OP * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 
unary_expression -> SIZEOF ( type_name ) 	0
/ ? OR_OP % ] EQ_OP | < * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 
postfix_expression -> postfix_expression . IDENTIFIER 	0
? OR_OP / ] % | < EQ_OP * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> primary_expression 	0
? OR_OP / ] % | < EQ_OP * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression ( ) 	0
? OR_OP / ] % | < EQ_OP * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
? OR_OP / ] % | < EQ_OP * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression INC_OP 	0
? OR_OP / ] % | < EQ_OP * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
? OR_OP / ] % | < EQ_OP * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
? OR_OP / ] % | < EQ_OP * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
primary_expression -> CONSTANT 	0
/ ? OR_OP % ] EQ_OP | < * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP . ( 
primary_expression -> ( expression ) 	0
/ ? OR_OP % ] EQ_OP | < * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP . ( 
primary_expression -> STRING_LITERAL 	0
/ ? OR_OP % ] EQ_OP | < * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP . ( 

187 27
unary_expression -> SIZEOF ( type_name ) 	0
/ ? OR_OP % ] EQ_OP | < * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 
multiplicative_expression -> multiplicative_expression / cast_expression 	2
/ ? OR_OP % ] EQ_OP | < * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 
cast_expression -> ( type_name ) cast_expression 	0
? OR_OP / ] % | < EQ_OP * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 
unary_expression -> unary_operator cast_expression 	0
/ ? OR_OP % ] EQ_OP | < * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 
unary_expression -> INC_OP unary_expression 	0
/ ? OR_OP % ] EQ_OP | < * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
? OR_OP / ] % | < EQ_OP * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
unary_expression -> postfix_expression 	0
/ ? OR_OP % ] EQ_OP | < * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 
unary_expression -> DEC_OP unary_expression 	0
/ ? OR_OP % ] EQ_OP | < * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 
primary_expression -> IDENTIFIER 	0
/ ? OR_OP % ] EQ_OP | < * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP . ( 
cast_expression -> unary_expression 	0
? OR_OP / ] % | < EQ_OP * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 
unary_expression -> SIZEOF unary_expression 	0
/ ? OR_OP % ] EQ_OP | < * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 
postfix_expression -> postfix_expression . IDENTIFIER 	0
? OR_OP / ] % | < EQ_OP * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> primary_expression 	0
? OR_OP / ] % | < EQ_OP * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression ( ) 	0
? OR_OP / ] % | < EQ_OP * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
? OR_OP / ] % | < EQ_OP * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression INC_OP 	0
? OR_OP / ] % | < EQ_OP * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
? OR_OP / ] % | < EQ_OP * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
? OR_OP / ] % | < EQ_OP * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
primary_expression -> CONSTANT 	0
/ ? OR_OP % ] EQ_OP | < * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP . ( 
primary_expression -> ( expression ) 	0
/ ? OR_OP % ] EQ_OP | < * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP . ( 
primary_expression -> STRING_LITERAL 	0
/ ? OR_OP % ] EQ_OP | < * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP . ( 

188 27
multiplicative_expression -> multiplicative_expression % cast_expression 	2
/ ? OR_OP % ] EQ_OP | < * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 
cast_expression -> ( type_name ) cast_expression 	0
? OR_OP / ] % | < EQ_OP * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 
unary_expression -> unary_operator cast_expression 	0
/ ? OR_OP % ] EQ_OP | < * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 
unary_expression -> INC_OP unary_expression 	0
/ ? OR_OP % ] EQ_OP | < * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
? OR_OP / ] % | < EQ_OP * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
unary_expression -> postfix_expression 	0
/ ? OR_OP % ] EQ_OP | < * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 
unary_expression -> DEC_OP unary_expression 	0
/ ? OR_OP % ] EQ_OP | < * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 
primary_expression -> IDENTIFIER 	0
/ ? OR_OP % ] EQ_OP | < * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP . ( 
cast_expression -> unary_expression 	0
? OR_OP / ] % | < EQ_OP * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 
unary_expression -> SIZEOF ( type_name ) 	0
/ ? OR_OP % ] EQ_OP | < * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 
unary_expression -> SIZEOF unary_expression 	0
/ ? OR_OP % ] EQ_OP | < * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 
postfix_expression -> postfix_expression . IDENTIFIER 	0
? OR_OP / ] % | < EQ_OP * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> primary_expression 	0
? OR_OP / ] % | < EQ_OP * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression ( ) 	0
? OR_OP / ] % | < EQ_OP * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
? OR_OP / ] % | < EQ_OP * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression INC_OP 	0
? OR_OP / ] % | < EQ_OP * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
? OR_OP / ] % | < EQ_OP * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
? OR_OP / ] % | < EQ_OP * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
primary_expression -> CONSTANT 	0
/ ? OR_OP % ] EQ_OP | < * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP . ( 
primary_expression -> ( expression ) 	0
/ ? OR_OP % ] EQ_OP | < * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP . ( 
primary_expression -> STRING_LITERAL 	0
/ ? OR_OP % ] EQ_OP | < * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP . ( 

189 31
unary_expression -> DEC_OP unary_expression 	0
OR_OP ? ] - EQ_OP | < ; + ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP * 
primary_expression -> IDENTIFIER 	0
OR_OP ? ] - EQ_OP | < ; + ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP * . ( 
cast_expression -> unary_expression 	0
OR_OP ? - ] | < EQ_OP + ; ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP * 
additive_expression -> additive_expression + multiplicative_expression 	2
OR_OP ? - ] | < EQ_OP + ; ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
OR_OP ? ] - EQ_OP | < ; + ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP * / % 
cast_expression -> ( type_name ) cast_expression 	0
OR_OP ? - ] | < EQ_OP + ; ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP * 
multiplicative_expression -> cast_expression 	0
OR_OP ? ] - EQ_OP | < ; + ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP * / % 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
OR_OP ? ] - EQ_OP | < ; + ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP * / % 
unary_expression -> SIZEOF ( type_name ) 	0
OR_OP ? ] - EQ_OP | < ; + ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP * 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
OR_OP ? ] - EQ_OP | < ; + ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP * / % 
unary_expression -> postfix_expression 	0
OR_OP ? ] - EQ_OP | < ; + ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP * 
unary_expression -> INC_OP unary_expression 	0
OR_OP ? ] - EQ_OP | < ; + ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP * 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
OR_OP ? - ] | < EQ_OP + ; ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
unary_expression -> unary_operator cast_expression 	0
OR_OP ? ] - EQ_OP | < ; + ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP * 
unary_expression -> SIZEOF unary_expression 	0
OR_OP ? ] - EQ_OP | < ; + ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP * 
postfix_expression -> postfix_expression . IDENTIFIER 	0
OR_OP ? - ] | < EQ_OP + ; ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> primary_expression 	0
OR_OP ? - ] | < EQ_OP + ; ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression ( ) 	0
OR_OP ? - ] | < EQ_OP + ; ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
OR_OP ? - ] | < EQ_OP + ; ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression INC_OP 	0
OR_OP ? - ] | < EQ_OP + ; ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
OR_OP ? - ] | < EQ_OP + ; ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
OR_OP ? - ] | < EQ_OP + ; ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
primary_expression -> CONSTANT 	0
OR_OP ? ] - EQ_OP | < ; + ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP * . ( 
primary_expression -> ( expression ) 	0
OR_OP ? ] - EQ_OP | < ; + ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP * . ( 
primary_expression -> STRING_LITERAL 	0
OR_OP ? ] - EQ_OP | < ; + ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP * . ( 

190 31
additive_expression -> additive_expression - multiplicative_expression 	2
OR_OP ? - ] | < EQ_OP + ; ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 
unary_expression -> SIZEOF unary_expression 	0
OR_OP ? ] - EQ_OP | < ; + ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP * 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
OR_OP ? ] - EQ_OP | < ; + ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP * / % 
cast_expression -> ( type_name ) cast_expression 	0
OR_OP ? - ] | < EQ_OP + ; ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP * 
multiplicative_expression -> cast_expression 	0
OR_OP ? ] - EQ_OP | < ; + ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP * / % 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
OR_OP ? ] - EQ_OP | < ; + ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP * / % 
unary_expression -> SIZEOF ( type_name ) 	0
OR_OP ? ] - EQ_OP | < ; + ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP * 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
OR_OP ? ] - EQ_OP | < ; + ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP * / % 
unary_expression -> DEC_OP unary_expression 	0
OR_OP ? ] - EQ_OP | < ; + ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP * 
primary_expression -> IDENTIFIER 	0
OR_OP ? ] - EQ_OP | < ; + ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP * . ( 
cast_expression -> unary_expression 	0
OR_OP ? - ] | < EQ_OP + ; ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP * 
unary_expression -> postfix_expression 	0
OR_OP ? ] - EQ_OP | < ; + ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP * 
unary_expression -> INC_OP unary_expression 	0
OR_OP ? ] - EQ_OP | < ; + ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP * 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
OR_OP ? - ] | < EQ_OP + ; ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
unary_expression -> unary_operator cast_expression 	0
OR_OP ? ] - EQ_OP | < ; + ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP * 
postfix_expression -> postfix_expression . IDENTIFIER 	0
OR_OP ? - ] | < EQ_OP + ; ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> primary_expression 	0
OR_OP ? - ] | < EQ_OP + ; ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression ( ) 	0
OR_OP ? - ] | < EQ_OP + ; ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
OR_OP ? - ] | < EQ_OP + ; ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression INC_OP 	0
OR_OP ? - ] | < EQ_OP + ; ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
OR_OP ? - ] | < EQ_OP + ; ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
OR_OP ? - ] | < EQ_OP + ; ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
primary_expression -> CONSTANT 	0
OR_OP ? ] - EQ_OP | < ; + ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP * . ( 
primary_expression -> ( expression ) 	0
OR_OP ? ] - EQ_OP | < ; + ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP * . ( 
primary_expression -> STRING_LITERAL 	0
OR_OP ? ] - EQ_OP | < ; + ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP * . ( 

191 1
direct_declarator -> direct_declarator [ constant_expression ] 	4
; { SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC TYPEDEF CONST UNION EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ ) = , : 

192 34
multiplicative_expression -> multiplicative_expression * cast_expression 	0
? OR_OP ] EQ_OP | < LEFT_OP ; RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP * / % 
additive_expression -> additive_expression - multiplicative_expression 	0
? OR_OP ] | < EQ_OP ; LEFT_OP RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP + - 
shift_expression -> shift_expression LEFT_OP additive_expression 	2
? OR_OP ] EQ_OP | < LEFT_OP ; RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP 
additive_expression -> multiplicative_expression 	0
? OR_OP ] | < EQ_OP ; LEFT_OP RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP + - 
additive_expression -> additive_expression + multiplicative_expression 	0
? OR_OP ] | < EQ_OP ; LEFT_OP RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP + - 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
cast_expression -> ( type_name ) cast_expression 	0
? OR_OP ] | < EQ_OP ; LEFT_OP RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP * 
multiplicative_expression -> cast_expression 	0
? OR_OP ] EQ_OP | < LEFT_OP ; RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP * / % 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
? OR_OP ] EQ_OP | < LEFT_OP ; RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP * / % 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
? OR_OP ] EQ_OP | < LEFT_OP ; RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP * / % 
cast_expression -> unary_expression 	0
? OR_OP ] | < EQ_OP ; LEFT_OP RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP * 
unary_expression -> DEC_OP unary_expression 	0
? OR_OP ] EQ_OP | < LEFT_OP ; RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP * 
primary_expression -> IDENTIFIER 	0
? OR_OP ] EQ_OP | < LEFT_OP ; RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP * . ( 
unary_expression -> SIZEOF ( type_name ) 	0
? OR_OP ] EQ_OP | < LEFT_OP ; RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP * 
unary_expression -> postfix_expression 	0
? OR_OP ] EQ_OP | < LEFT_OP ; RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP * 
unary_expression -> INC_OP unary_expression 	0
? OR_OP ] EQ_OP | < LEFT_OP ; RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP * 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
? OR_OP ] | < EQ_OP ; LEFT_OP RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
unary_expression -> unary_operator cast_expression 	0
? OR_OP ] EQ_OP | < LEFT_OP ; RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP * 
unary_expression -> SIZEOF unary_expression 	0
? OR_OP ] EQ_OP | < LEFT_OP ; RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP * 
postfix_expression -> postfix_expression . IDENTIFIER 	0
? OR_OP ] | < EQ_OP ; LEFT_OP RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> primary_expression 	0
? OR_OP ] | < EQ_OP ; LEFT_OP RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression ( ) 	0
? OR_OP ] | < EQ_OP ; LEFT_OP RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
? OR_OP ] | < EQ_OP ; LEFT_OP RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression INC_OP 	0
? OR_OP ] | < EQ_OP ; LEFT_OP RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
? OR_OP ] | < EQ_OP ; LEFT_OP RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
? OR_OP ] | < EQ_OP ; LEFT_OP RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
primary_expression -> CONSTANT 	0
? OR_OP ] EQ_OP | < LEFT_OP ; RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP * . ( 
primary_expression -> ( expression ) 	0
? OR_OP ] EQ_OP | < LEFT_OP ; RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP * . ( 
primary_expression -> STRING_LITERAL 	0
? OR_OP ] EQ_OP | < LEFT_OP ; RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP * . ( 

193 34
multiplicative_expression -> multiplicative_expression / cast_expression 	0
? OR_OP ] EQ_OP | < LEFT_OP ; RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP * / % 
shift_expression -> shift_expression RIGHT_OP additive_expression 	2
? OR_OP ] EQ_OP | < LEFT_OP ; RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP 
additive_expression -> multiplicative_expression 	0
? OR_OP ] | < EQ_OP ; LEFT_OP RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP + - 
additive_expression -> additive_expression + multiplicative_expression 	0
? OR_OP ] | < EQ_OP ; LEFT_OP RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP + - 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
? OR_OP ] EQ_OP | < LEFT_OP ; RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP * / % 
additive_expression -> additive_expression - multiplicative_expression 	0
? OR_OP ] | < EQ_OP ; LEFT_OP RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP + - 
cast_expression -> ( type_name ) cast_expression 	0
? OR_OP ] | < EQ_OP ; LEFT_OP RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP * 
multiplicative_expression -> cast_expression 	0
? OR_OP ] EQ_OP | < LEFT_OP ; RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP * / % 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
? OR_OP ] EQ_OP | < LEFT_OP ; RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP * / % 
cast_expression -> unary_expression 	0
? OR_OP ] | < EQ_OP ; LEFT_OP RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP * 
unary_expression -> DEC_OP unary_expression 	0
? OR_OP ] EQ_OP | < LEFT_OP ; RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP * 
primary_expression -> IDENTIFIER 	0
? OR_OP ] EQ_OP | < LEFT_OP ; RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP * . ( 
unary_expression -> SIZEOF ( type_name ) 	0
? OR_OP ] EQ_OP | < LEFT_OP ; RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP * 
unary_expression -> postfix_expression 	0
? OR_OP ] EQ_OP | < LEFT_OP ; RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP * 
unary_expression -> INC_OP unary_expression 	0
? OR_OP ] EQ_OP | < LEFT_OP ; RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP * 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
? OR_OP ] | < EQ_OP ; LEFT_OP RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
unary_expression -> unary_operator cast_expression 	0
? OR_OP ] EQ_OP | < LEFT_OP ; RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP * 
unary_expression -> SIZEOF unary_expression 	0
? OR_OP ] EQ_OP | < LEFT_OP ; RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP * 
postfix_expression -> postfix_expression . IDENTIFIER 	0
? OR_OP ] | < EQ_OP ; LEFT_OP RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> primary_expression 	0
? OR_OP ] | < EQ_OP ; LEFT_OP RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression ( ) 	0
? OR_OP ] | < EQ_OP ; LEFT_OP RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
? OR_OP ] | < EQ_OP ; LEFT_OP RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression INC_OP 	0
? OR_OP ] | < EQ_OP ; LEFT_OP RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
? OR_OP ] | < EQ_OP ; LEFT_OP RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
? OR_OP ] | < EQ_OP ; LEFT_OP RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
primary_expression -> CONSTANT 	0
? OR_OP ] EQ_OP | < LEFT_OP ; RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP * . ( 
primary_expression -> ( expression ) 	0
? OR_OP ] EQ_OP | < LEFT_OP ; RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP * . ( 
primary_expression -> STRING_LITERAL 	0
? OR_OP ] EQ_OP | < LEFT_OP ; RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP * . ( 

194 37
multiplicative_expression -> cast_expression 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * / % 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP LEFT_OP RIGHT_OP 
relational_expression -> relational_expression > shift_expression 	2
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP 
primary_expression -> CONSTANT 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * . ( 
additive_expression -> additive_expression + multiplicative_expression 	0
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP + - 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
shift_expression -> additive_expression 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP LEFT_OP RIGHT_OP 
additive_expression -> multiplicative_expression 	0
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP + - 
shift_expression -> shift_expression LEFT_OP additive_expression 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP LEFT_OP RIGHT_OP 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * / % 
additive_expression -> additive_expression - multiplicative_expression 	0
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP + - 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * / % 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * / % 
cast_expression -> ( type_name ) cast_expression 	0
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP * 
cast_expression -> unary_expression 	0
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP * 
unary_expression -> DEC_OP unary_expression 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * 
primary_expression -> IDENTIFIER 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * . ( 
unary_expression -> SIZEOF ( type_name ) 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * 
unary_expression -> postfix_expression 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * 
unary_expression -> INC_OP unary_expression 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
unary_expression -> unary_operator cast_expression 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * 
unary_expression -> SIZEOF unary_expression 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * 
postfix_expression -> postfix_expression . IDENTIFIER 	0
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> primary_expression 	0
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression ( ) 	0
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression INC_OP 	0
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
primary_expression -> ( expression ) 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * . ( 
primary_expression -> STRING_LITERAL 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * . ( 

195 37
relational_expression -> relational_expression < shift_expression 	2
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
additive_expression -> additive_expression + multiplicative_expression 	0
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP + - 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
shift_expression -> additive_expression 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP LEFT_OP RIGHT_OP 
additive_expression -> multiplicative_expression 	0
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP + - 
shift_expression -> shift_expression LEFT_OP additive_expression 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP LEFT_OP RIGHT_OP 
multiplicative_expression -> cast_expression 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * / % 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP LEFT_OP RIGHT_OP 
primary_expression -> CONSTANT 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * . ( 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * / % 
additive_expression -> additive_expression - multiplicative_expression 	0
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP + - 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * / % 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * / % 
cast_expression -> ( type_name ) cast_expression 	0
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP * 
cast_expression -> unary_expression 	0
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP * 
unary_expression -> DEC_OP unary_expression 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * 
primary_expression -> IDENTIFIER 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * . ( 
unary_expression -> SIZEOF ( type_name ) 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * 
unary_expression -> postfix_expression 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * 
unary_expression -> INC_OP unary_expression 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
unary_expression -> unary_operator cast_expression 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * 
unary_expression -> SIZEOF unary_expression 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * 
postfix_expression -> postfix_expression . IDENTIFIER 	0
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> primary_expression 	0
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression ( ) 	0
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression INC_OP 	0
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
primary_expression -> ( expression ) 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * . ( 
primary_expression -> STRING_LITERAL 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * . ( 

196 37
additive_expression -> multiplicative_expression 	0
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP + - 
shift_expression -> shift_expression LEFT_OP additive_expression 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP LEFT_OP RIGHT_OP 
relational_expression -> relational_expression LE_OP shift_expression 	2
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP 
additive_expression -> additive_expression + multiplicative_expression 	0
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP + - 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
shift_expression -> additive_expression 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP LEFT_OP RIGHT_OP 
multiplicative_expression -> cast_expression 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * / % 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP LEFT_OP RIGHT_OP 
primary_expression -> CONSTANT 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * . ( 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * / % 
additive_expression -> additive_expression - multiplicative_expression 	0
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP + - 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * / % 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * / % 
cast_expression -> ( type_name ) cast_expression 	0
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP * 
cast_expression -> unary_expression 	0
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP * 
unary_expression -> DEC_OP unary_expression 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * 
primary_expression -> IDENTIFIER 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * . ( 
unary_expression -> SIZEOF ( type_name ) 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * 
unary_expression -> postfix_expression 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * 
unary_expression -> INC_OP unary_expression 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
unary_expression -> unary_operator cast_expression 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * 
unary_expression -> SIZEOF unary_expression 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * 
postfix_expression -> postfix_expression . IDENTIFIER 	0
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> primary_expression 	0
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression ( ) 	0
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression INC_OP 	0
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
primary_expression -> ( expression ) 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * . ( 
primary_expression -> STRING_LITERAL 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * . ( 

197 37
relational_expression -> relational_expression GE_OP shift_expression 	2
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP 
additive_expression -> additive_expression + multiplicative_expression 	0
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP + - 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
shift_expression -> additive_expression 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP LEFT_OP RIGHT_OP 
additive_expression -> multiplicative_expression 	0
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP + - 
shift_expression -> shift_expression LEFT_OP additive_expression 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP LEFT_OP RIGHT_OP 
multiplicative_expression -> cast_expression 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * / % 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP LEFT_OP RIGHT_OP 
primary_expression -> CONSTANT 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * . ( 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * / % 
additive_expression -> additive_expression - multiplicative_expression 	0
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP + - 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * / % 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * / % 
cast_expression -> ( type_name ) cast_expression 	0
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP * 
cast_expression -> unary_expression 	0
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP * 
unary_expression -> DEC_OP unary_expression 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * 
primary_expression -> IDENTIFIER 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * . ( 
unary_expression -> SIZEOF ( type_name ) 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * 
unary_expression -> postfix_expression 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * 
unary_expression -> INC_OP unary_expression 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
unary_expression -> unary_operator cast_expression 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * 
unary_expression -> SIZEOF unary_expression 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * 
postfix_expression -> postfix_expression . IDENTIFIER 	0
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> primary_expression 	0
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression ( ) 	0
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression INC_OP 	0
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
primary_expression -> ( expression ) 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * . ( 
primary_expression -> STRING_LITERAL 	0
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP * . ( 

198 42
shift_expression -> shift_expression LEFT_OP additive_expression 	0
NE_OP ? OR_OP ] } EQ_OP ; ) : , & ^ | < AND_OP LEFT_OP RIGHT_OP 
equality_expression -> equality_expression EQ_OP relational_expression 	2
NE_OP ? OR_OP ] } EQ_OP ; ) : , & ^ | AND_OP 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
NE_OP ? OR_OP ] } EQ_OP ; ) : , & ^ | < AND_OP LEFT_OP RIGHT_OP 
primary_expression -> CONSTANT 	0
NE_OP ? OR_OP ] } EQ_OP ; ) : , & ^ | < AND_OP * . ( 
relational_expression -> shift_expression 	0
? OR_OP NE_OP } ] EQ_OP ; ) : , & ^ < | AND_OP > LE_OP GE_OP 
relational_expression -> relational_expression < shift_expression 	0
? OR_OP NE_OP } ] EQ_OP ; ) : , & ^ < | AND_OP > LE_OP GE_OP 
multiplicative_expression -> cast_expression 	0
NE_OP ? OR_OP ] } EQ_OP ; ) : , & ^ | < AND_OP * / % 
relational_expression -> relational_expression > shift_expression 	0
? OR_OP NE_OP } ] EQ_OP ; ) : , & ^ < | AND_OP > LE_OP GE_OP 
relational_expression -> relational_expression LE_OP shift_expression 	0
? OR_OP NE_OP } ] EQ_OP ; ) : , & ^ < | AND_OP > LE_OP GE_OP 
unary_expression -> unary_operator cast_expression 	0
NE_OP ? OR_OP ] } EQ_OP ; ) : , & ^ | < AND_OP * 
relational_expression -> relational_expression GE_OP shift_expression 	0
? OR_OP NE_OP } ] EQ_OP ; ) : , & ^ < | AND_OP > LE_OP GE_OP 
shift_expression -> additive_expression 	0
NE_OP ? OR_OP ] } EQ_OP ; ) : , & ^ | < AND_OP LEFT_OP RIGHT_OP 
additive_expression -> multiplicative_expression 	0
? OR_OP NE_OP } ] EQ_OP ; ) : , & ^ < | AND_OP + - 
additive_expression -> additive_expression + multiplicative_expression 	0
? OR_OP NE_OP } ] EQ_OP ; ) : , & ^ < | AND_OP + - 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
additive_expression -> additive_expression - multiplicative_expression 	0
? OR_OP NE_OP } ] EQ_OP ; ) : , & ^ < | AND_OP + - 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
NE_OP ? OR_OP ] } EQ_OP ; ) : , & ^ | < AND_OP * / % 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
NE_OP ? OR_OP ] } EQ_OP ; ) : , & ^ | < AND_OP * / % 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
NE_OP ? OR_OP ] } EQ_OP ; ) : , & ^ | < AND_OP * / % 
cast_expression -> ( type_name ) cast_expression 	0
? OR_OP NE_OP } ] EQ_OP ; ) : , & ^ < | AND_OP * 
cast_expression -> unary_expression 	0
? OR_OP NE_OP } ] EQ_OP ; ) : , & ^ < | AND_OP * 
unary_expression -> DEC_OP unary_expression 	0
NE_OP ? OR_OP ] } EQ_OP ; ) : , & ^ | < AND_OP * 
primary_expression -> IDENTIFIER 	0
NE_OP ? OR_OP ] } EQ_OP ; ) : , & ^ | < AND_OP * . ( 
unary_expression -> SIZEOF ( type_name ) 	0
NE_OP ? OR_OP ] } EQ_OP ; ) : , & ^ | < AND_OP * 
unary_expression -> postfix_expression 	0
NE_OP ? OR_OP ] } EQ_OP ; ) : , & ^ | < AND_OP * 
unary_expression -> INC_OP unary_expression 	0
NE_OP ? OR_OP ] } EQ_OP ; ) : , & ^ | < AND_OP * 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
? OR_OP NE_OP } ] EQ_OP ; ) : , & ^ < | AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
unary_expression -> SIZEOF unary_expression 	0
NE_OP ? OR_OP ] } EQ_OP ; ) : , & ^ | < AND_OP * 
postfix_expression -> postfix_expression . IDENTIFIER 	0
? OR_OP NE_OP } ] EQ_OP ; ) : , & ^ < | AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> primary_expression 	0
? OR_OP NE_OP } ] EQ_OP ; ) : , & ^ < | AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression ( ) 	0
? OR_OP NE_OP } ] EQ_OP ; ) : , & ^ < | AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
? OR_OP NE_OP } ] EQ_OP ; ) : , & ^ < | AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression INC_OP 	0
? OR_OP NE_OP } ] EQ_OP ; ) : , & ^ < | AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
? OR_OP NE_OP } ] EQ_OP ; ) : , & ^ < | AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
? OR_OP NE_OP } ] EQ_OP ; ) : , & ^ < | AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
primary_expression -> ( expression ) 	0
NE_OP ? OR_OP ] } EQ_OP ; ) : , & ^ | < AND_OP * . ( 
primary_expression -> STRING_LITERAL 	0
NE_OP ? OR_OP ] } EQ_OP ; ) : , & ^ | < AND_OP * . ( 

199 42
relational_expression -> relational_expression > shift_expression 	0
? OR_OP NE_OP } ] EQ_OP ; ) : , & ^ < | AND_OP > LE_OP GE_OP 
equality_expression -> equality_expression NE_OP relational_expression 	2
NE_OP ? OR_OP ] } EQ_OP ; ) : , & ^ | AND_OP 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
NE_OP ? OR_OP ] } EQ_OP ; ) : , & ^ | < AND_OP LEFT_OP RIGHT_OP 
primary_expression -> CONSTANT 	0
NE_OP ? OR_OP ] } EQ_OP ; ) : , & ^ | < AND_OP * . ( 
relational_expression -> shift_expression 	0
? OR_OP NE_OP } ] EQ_OP ; ) : , & ^ < | AND_OP > LE_OP GE_OP 
relational_expression -> relational_expression < shift_expression 	0
? OR_OP NE_OP } ] EQ_OP ; ) : , & ^ < | AND_OP > LE_OP GE_OP 
multiplicative_expression -> cast_expression 	0
NE_OP ? OR_OP ] } EQ_OP ; ) : , & ^ | < AND_OP * / % 
relational_expression -> relational_expression LE_OP shift_expression 	0
? OR_OP NE_OP } ] EQ_OP ; ) : , & ^ < | AND_OP > LE_OP GE_OP 
unary_expression -> unary_operator cast_expression 	0
NE_OP ? OR_OP ] } EQ_OP ; ) : , & ^ | < AND_OP * 
relational_expression -> relational_expression GE_OP shift_expression 	0
? OR_OP NE_OP } ] EQ_OP ; ) : , & ^ < | AND_OP > LE_OP GE_OP 
shift_expression -> additive_expression 	0
NE_OP ? OR_OP ] } EQ_OP ; ) : , & ^ | < AND_OP LEFT_OP RIGHT_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	0
NE_OP ? OR_OP ] } EQ_OP ; ) : , & ^ | < AND_OP LEFT_OP RIGHT_OP 
additive_expression -> multiplicative_expression 	0
? OR_OP NE_OP } ] EQ_OP ; ) : , & ^ < | AND_OP + - 
additive_expression -> additive_expression + multiplicative_expression 	0
? OR_OP NE_OP } ] EQ_OP ; ) : , & ^ < | AND_OP + - 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
additive_expression -> additive_expression - multiplicative_expression 	0
? OR_OP NE_OP } ] EQ_OP ; ) : , & ^ < | AND_OP + - 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
NE_OP ? OR_OP ] } EQ_OP ; ) : , & ^ | < AND_OP * / % 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
NE_OP ? OR_OP ] } EQ_OP ; ) : , & ^ | < AND_OP * / % 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
NE_OP ? OR_OP ] } EQ_OP ; ) : , & ^ | < AND_OP * / % 
cast_expression -> ( type_name ) cast_expression 	0
? OR_OP NE_OP } ] EQ_OP ; ) : , & ^ < | AND_OP * 
cast_expression -> unary_expression 	0
? OR_OP NE_OP } ] EQ_OP ; ) : , & ^ < | AND_OP * 
unary_expression -> DEC_OP unary_expression 	0
NE_OP ? OR_OP ] } EQ_OP ; ) : , & ^ | < AND_OP * 
primary_expression -> IDENTIFIER 	0
NE_OP ? OR_OP ] } EQ_OP ; ) : , & ^ | < AND_OP * . ( 
unary_expression -> SIZEOF ( type_name ) 	0
NE_OP ? OR_OP ] } EQ_OP ; ) : , & ^ | < AND_OP * 
unary_expression -> postfix_expression 	0
NE_OP ? OR_OP ] } EQ_OP ; ) : , & ^ | < AND_OP * 
unary_expression -> INC_OP unary_expression 	0
NE_OP ? OR_OP ] } EQ_OP ; ) : , & ^ | < AND_OP * 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
? OR_OP NE_OP } ] EQ_OP ; ) : , & ^ < | AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
unary_expression -> SIZEOF unary_expression 	0
NE_OP ? OR_OP ] } EQ_OP ; ) : , & ^ | < AND_OP * 
postfix_expression -> postfix_expression . IDENTIFIER 	0
? OR_OP NE_OP } ] EQ_OP ; ) : , & ^ < | AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> primary_expression 	0
? OR_OP NE_OP } ] EQ_OP ; ) : , & ^ < | AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression ( ) 	0
? OR_OP NE_OP } ] EQ_OP ; ) : , & ^ < | AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
? OR_OP NE_OP } ] EQ_OP ; ) : , & ^ < | AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression INC_OP 	0
? OR_OP NE_OP } ] EQ_OP ; ) : , & ^ < | AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
? OR_OP NE_OP } ] EQ_OP ; ) : , & ^ < | AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
? OR_OP NE_OP } ] EQ_OP ; ) : , & ^ < | AND_OP * . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
primary_expression -> ( expression ) 	0
NE_OP ? OR_OP ] } EQ_OP ; ) : , & ^ | < AND_OP * . ( 
primary_expression -> STRING_LITERAL 	0
NE_OP ? OR_OP ] } EQ_OP ; ) : , & ^ | < AND_OP * . ( 

200 45
relational_expression -> relational_expression GE_OP shift_expression 	0
OR_OP ? ] } & ; ) : , ^ < | AND_OP EQ_OP > LE_OP GE_OP 
and_expression -> and_expression & equality_expression 	2
OR_OP ? ] } & ; ) : , ^ | AND_OP 
relational_expression -> relational_expression LE_OP shift_expression 	0
OR_OP ? ] } & ; ) : , ^ < | AND_OP EQ_OP > LE_OP GE_OP 
unary_expression -> unary_operator cast_expression 	0
OR_OP ? } ] & ; ) : , ^ | < AND_OP EQ_OP * 
equality_expression -> equality_expression EQ_OP relational_expression 	0
OR_OP ? } ] & ; ) : , ^ | AND_OP EQ_OP NE_OP 
unary_expression -> INC_OP unary_expression 	0
OR_OP ? } ] & ; ) : , ^ | < AND_OP EQ_OP * 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
OR_OP ? ] } & ; ) : , ^ < | AND_OP EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
equality_expression -> equality_expression NE_OP relational_expression 	0
OR_OP ? } ] & ; ) : , ^ | AND_OP EQ_OP NE_OP 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
equality_expression -> relational_expression 	0
OR_OP ? } ] & ; ) : , ^ | AND_OP EQ_OP NE_OP 
relational_expression -> shift_expression 	0
OR_OP ? ] } & ; ) : , ^ < | AND_OP EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression < shift_expression 	0
OR_OP ? ] } & ; ) : , ^ < | AND_OP EQ_OP > LE_OP GE_OP 
multiplicative_expression -> cast_expression 	0
OR_OP ? } ] & ; ) : , ^ | < AND_OP EQ_OP * / % 
relational_expression -> relational_expression > shift_expression 	0
OR_OP ? ] } & ; ) : , ^ < | AND_OP EQ_OP > LE_OP GE_OP 
shift_expression -> additive_expression 	0
OR_OP ? } ] & ; ) : , ^ | < AND_OP EQ_OP LEFT_OP RIGHT_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	0
OR_OP ? } ] & ; ) : , ^ | < AND_OP EQ_OP LEFT_OP RIGHT_OP 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
OR_OP ? } ] & ; ) : , ^ | < AND_OP EQ_OP LEFT_OP RIGHT_OP 
primary_expression -> CONSTANT 	0
OR_OP ? } ] & ; ) : , ^ | < AND_OP EQ_OP * . ( 
additive_expression -> multiplicative_expression 	0
OR_OP ? ] } & ; ) : , ^ < | AND_OP EQ_OP + - 
additive_expression -> additive_expression + multiplicative_expression 	0
OR_OP ? ] } & ; ) : , ^ < | AND_OP EQ_OP + - 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
additive_expression -> additive_expression - multiplicative_expression 	0
OR_OP ? ] } & ; ) : , ^ < | AND_OP EQ_OP + - 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
OR_OP ? } ] & ; ) : , ^ | < AND_OP EQ_OP * / % 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
OR_OP ? } ] & ; ) : , ^ | < AND_OP EQ_OP * / % 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
OR_OP ? } ] & ; ) : , ^ | < AND_OP EQ_OP * / % 
cast_expression -> ( type_name ) cast_expression 	0
OR_OP ? ] } & ; ) : , ^ < | AND_OP EQ_OP * 
cast_expression -> unary_expression 	0
OR_OP ? ] } & ; ) : , ^ < | AND_OP EQ_OP * 
unary_expression -> DEC_OP unary_expression 	0
OR_OP ? } ] & ; ) : , ^ | < AND_OP EQ_OP * 
primary_expression -> IDENTIFIER 	0
OR_OP ? } ] & ; ) : , ^ | < AND_OP EQ_OP * . ( 
unary_expression -> SIZEOF ( type_name ) 	0
OR_OP ? } ] & ; ) : , ^ | < AND_OP EQ_OP * 
unary_expression -> postfix_expression 	0
OR_OP ? } ] & ; ) : , ^ | < AND_OP EQ_OP * 
unary_expression -> SIZEOF unary_expression 	0
OR_OP ? } ] & ; ) : , ^ | < AND_OP EQ_OP * 
postfix_expression -> postfix_expression . IDENTIFIER 	0
OR_OP ? ] } & ; ) : , ^ < | AND_OP EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> primary_expression 	0
OR_OP ? ] } & ; ) : , ^ < | AND_OP EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression ( ) 	0
OR_OP ? ] } & ; ) : , ^ < | AND_OP EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
OR_OP ? ] } & ; ) : , ^ < | AND_OP EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression INC_OP 	0
OR_OP ? ] } & ; ) : , ^ < | AND_OP EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
OR_OP ? ] } & ; ) : , ^ < | AND_OP EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
OR_OP ? ] } & ; ) : , ^ < | AND_OP EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
primary_expression -> ( expression ) 	0
OR_OP ? } ] & ; ) : , ^ | < AND_OP EQ_OP * . ( 
primary_expression -> STRING_LITERAL 	0
OR_OP ? } ] & ; ) : , ^ | < AND_OP EQ_OP * . ( 

201 47
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	2
? OR_OP ] } ^ ; ) : , | AND_OP 
additive_expression -> additive_expression + multiplicative_expression 	0
? OR_OP } ] ^ ; ) : , < | AND_OP EQ_OP + - 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
equality_expression -> equality_expression NE_OP relational_expression 	0
? OR_OP ] } ^ ; ) : , | AND_OP EQ_OP NE_OP 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
equality_expression -> relational_expression 	0
? OR_OP ] } ^ ; ) : , | AND_OP EQ_OP NE_OP 
and_expression -> equality_expression 	0
? OR_OP } ] ^ ; ) : , | AND_OP & 
unary_expression -> SIZEOF ( type_name ) 	0
? OR_OP ] } ^ ; ) : , | < AND_OP EQ_OP * 
relational_expression -> shift_expression 	0
? OR_OP } ] ^ ; ) : , < | AND_OP EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression < shift_expression 	0
? OR_OP } ] ^ ; ) : , < | AND_OP EQ_OP > LE_OP GE_OP 
multiplicative_expression -> cast_expression 	0
? OR_OP ] } ^ ; ) : , | < AND_OP EQ_OP * / % 
and_expression -> and_expression & equality_expression 	0
? OR_OP } ] ^ ; ) : , | AND_OP & 
equality_expression -> equality_expression EQ_OP relational_expression 	0
? OR_OP ] } ^ ; ) : , | AND_OP EQ_OP NE_OP 
unary_expression -> INC_OP unary_expression 	0
? OR_OP ] } ^ ; ) : , | < AND_OP EQ_OP * 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
? OR_OP } ] ^ ; ) : , < | AND_OP EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
relational_expression -> relational_expression > shift_expression 	0
? OR_OP } ] ^ ; ) : , < | AND_OP EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression LE_OP shift_expression 	0
? OR_OP } ] ^ ; ) : , < | AND_OP EQ_OP > LE_OP GE_OP 
unary_expression -> unary_operator cast_expression 	0
? OR_OP ] } ^ ; ) : , | < AND_OP EQ_OP * 
relational_expression -> relational_expression GE_OP shift_expression 	0
? OR_OP } ] ^ ; ) : , < | AND_OP EQ_OP > LE_OP GE_OP 
shift_expression -> additive_expression 	0
? OR_OP ] } ^ ; ) : , | < AND_OP EQ_OP LEFT_OP RIGHT_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	0
? OR_OP ] } ^ ; ) : , | < AND_OP EQ_OP LEFT_OP RIGHT_OP 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
? OR_OP ] } ^ ; ) : , | < AND_OP EQ_OP LEFT_OP RIGHT_OP 
primary_expression -> CONSTANT 	0
? OR_OP ] } ^ ; ) : , | < AND_OP EQ_OP * . ( 
additive_expression -> multiplicative_expression 	0
? OR_OP } ] ^ ; ) : , < | AND_OP EQ_OP + - 
additive_expression -> additive_expression - multiplicative_expression 	0
? OR_OP } ] ^ ; ) : , < | AND_OP EQ_OP + - 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
? OR_OP ] } ^ ; ) : , | < AND_OP EQ_OP * / % 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
? OR_OP ] } ^ ; ) : , | < AND_OP EQ_OP * / % 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
? OR_OP ] } ^ ; ) : , | < AND_OP EQ_OP * / % 
cast_expression -> ( type_name ) cast_expression 	0
? OR_OP } ] ^ ; ) : , < | AND_OP EQ_OP * 
cast_expression -> unary_expression 	0
? OR_OP } ] ^ ; ) : , < | AND_OP EQ_OP * 
unary_expression -> DEC_OP unary_expression 	0
? OR_OP ] } ^ ; ) : , | < AND_OP EQ_OP * 
primary_expression -> IDENTIFIER 	0
? OR_OP ] } ^ ; ) : , | < AND_OP EQ_OP * . ( 
unary_expression -> postfix_expression 	0
? OR_OP ] } ^ ; ) : , | < AND_OP EQ_OP * 
unary_expression -> SIZEOF unary_expression 	0
? OR_OP ] } ^ ; ) : , | < AND_OP EQ_OP * 
postfix_expression -> postfix_expression . IDENTIFIER 	0
? OR_OP } ] ^ ; ) : , < | AND_OP EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> primary_expression 	0
? OR_OP } ] ^ ; ) : , < | AND_OP EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression ( ) 	0
? OR_OP } ] ^ ; ) : , < | AND_OP EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
? OR_OP } ] ^ ; ) : , < | AND_OP EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression INC_OP 	0
? OR_OP } ] ^ ; ) : , < | AND_OP EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
? OR_OP } ] ^ ; ) : , < | AND_OP EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
? OR_OP } ] ^ ; ) : , < | AND_OP EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
primary_expression -> ( expression ) 	0
? OR_OP ] } ^ ; ) : , | < AND_OP EQ_OP * . ( 
primary_expression -> STRING_LITERAL 	0
? OR_OP ] } ^ ; ) : , | < AND_OP EQ_OP * . ( 

202 49
inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression 	2
OR_OP ? ] } | , ; ) : AND_OP 
equality_expression -> equality_expression NE_OP relational_expression 	0
OR_OP ? } ] , | ; ) : AND_OP EQ_OP NE_OP 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
equality_expression -> relational_expression 	0
OR_OP ? } ] , | ; ) : AND_OP EQ_OP NE_OP 
and_expression -> equality_expression 	0
OR_OP ? ] } | , ; ) : AND_OP & 
unary_expression -> SIZEOF ( type_name ) 	0
OR_OP ? } ] , < | ; ) : AND_OP EQ_OP * 
exclusive_or_expression -> and_expression 	0
OR_OP ? } ] , | ; ) : AND_OP ^ 
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	0
OR_OP ? } ] , | ; ) : AND_OP ^ 
relational_expression -> relational_expression < shift_expression 	0
OR_OP ? ] } < | , ; ) : AND_OP EQ_OP > LE_OP GE_OP 
relational_expression -> shift_expression 	0
OR_OP ? ] } < | , ; ) : AND_OP EQ_OP > LE_OP GE_OP 
multiplicative_expression -> cast_expression 	0
OR_OP ? } ] , < | ; ) : AND_OP EQ_OP * / % 
and_expression -> and_expression & equality_expression 	0
OR_OP ? ] } | , ; ) : AND_OP & 
equality_expression -> equality_expression EQ_OP relational_expression 	0
OR_OP ? } ] , | ; ) : AND_OP EQ_OP NE_OP 
unary_expression -> INC_OP unary_expression 	0
OR_OP ? } ] , < | ; ) : AND_OP EQ_OP * 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
OR_OP ? ] } < | , ; ) : AND_OP EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
relational_expression -> relational_expression > shift_expression 	0
OR_OP ? ] } < | , ; ) : AND_OP EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression LE_OP shift_expression 	0
OR_OP ? ] } < | , ; ) : AND_OP EQ_OP > LE_OP GE_OP 
unary_expression -> unary_operator cast_expression 	0
OR_OP ? } ] , < | ; ) : AND_OP EQ_OP * 
relational_expression -> relational_expression GE_OP shift_expression 	0
OR_OP ? ] } < | , ; ) : AND_OP EQ_OP > LE_OP GE_OP 
shift_expression -> additive_expression 	0
OR_OP ? } ] , < | ; ) : AND_OP EQ_OP LEFT_OP RIGHT_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	0
OR_OP ? } ] , < | ; ) : AND_OP EQ_OP LEFT_OP RIGHT_OP 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
OR_OP ? } ] , < | ; ) : AND_OP EQ_OP LEFT_OP RIGHT_OP 
primary_expression -> CONSTANT 	0
OR_OP ? } ] , < | ; ) : AND_OP EQ_OP * . ( 
additive_expression -> multiplicative_expression 	0
OR_OP ? ] } < | , ; ) : AND_OP EQ_OP + - 
additive_expression -> additive_expression + multiplicative_expression 	0
OR_OP ? ] } < | , ; ) : AND_OP EQ_OP + - 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
additive_expression -> additive_expression - multiplicative_expression 	0
OR_OP ? ] } < | , ; ) : AND_OP EQ_OP + - 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
OR_OP ? } ] , < | ; ) : AND_OP EQ_OP * / % 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
OR_OP ? } ] , < | ; ) : AND_OP EQ_OP * / % 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
OR_OP ? } ] , < | ; ) : AND_OP EQ_OP * / % 
cast_expression -> ( type_name ) cast_expression 	0
OR_OP ? ] } < | , ; ) : AND_OP EQ_OP * 
cast_expression -> unary_expression 	0
OR_OP ? ] } < | , ; ) : AND_OP EQ_OP * 
unary_expression -> DEC_OP unary_expression 	0
OR_OP ? } ] , < | ; ) : AND_OP EQ_OP * 
primary_expression -> IDENTIFIER 	0
OR_OP ? } ] , < | ; ) : AND_OP EQ_OP * . ( 
unary_expression -> postfix_expression 	0
OR_OP ? } ] , < | ; ) : AND_OP EQ_OP * 
unary_expression -> SIZEOF unary_expression 	0
OR_OP ? } ] , < | ; ) : AND_OP EQ_OP * 
postfix_expression -> postfix_expression . IDENTIFIER 	0
OR_OP ? ] } < | , ; ) : AND_OP EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> primary_expression 	0
OR_OP ? ] } < | , ; ) : AND_OP EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression ( ) 	0
OR_OP ? ] } < | , ; ) : AND_OP EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
OR_OP ? ] } < | , ; ) : AND_OP EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression INC_OP 	0
OR_OP ? ] } < | , ; ) : AND_OP EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
OR_OP ? ] } < | , ; ) : AND_OP EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
OR_OP ? ] } < | , ; ) : AND_OP EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
primary_expression -> ( expression ) 	0
OR_OP ? } ] , < | ; ) : AND_OP EQ_OP * . ( 
primary_expression -> STRING_LITERAL 	0
OR_OP ? } ] , < | ; ) : AND_OP EQ_OP * . ( 

203 51
equality_expression -> equality_expression EQ_OP relational_expression 	0
? OR_OP ] } AND_OP ) ; : , EQ_OP NE_OP 
unary_expression -> INC_OP unary_expression 	0
? OR_OP ] } AND_OP ) ; : , EQ_OP < * 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
? OR_OP } ] ) AND_OP ; : , EQ_OP < * . ( [ PTR_OP INC_OP DEC_OP 
logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression 	2
? OR_OP ] } AND_OP ) ; : , 
cast_expression -> unary_expression 	0
? OR_OP } ] ) AND_OP ; : , EQ_OP < * 
inclusive_or_expression -> exclusive_or_expression 	0
? OR_OP } ] ) AND_OP ; : , | 
and_expression -> and_expression & equality_expression 	0
? OR_OP } ] ) AND_OP ; : , & 
inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression 	0
? OR_OP } ] ) AND_OP ; : , | 
equality_expression -> relational_expression 	0
? OR_OP ] } AND_OP ) ; : , EQ_OP NE_OP 
and_expression -> equality_expression 	0
? OR_OP } ] ) AND_OP ; : , & 
unary_expression -> SIZEOF ( type_name ) 	0
? OR_OP ] } AND_OP ) ; : , EQ_OP < * 
exclusive_or_expression -> and_expression 	0
? OR_OP ] } AND_OP ) ; : , ^ 
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	0
? OR_OP ] } AND_OP ) ; : , ^ 
equality_expression -> equality_expression NE_OP relational_expression 	0
? OR_OP ] } AND_OP ) ; : , EQ_OP NE_OP 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
relational_expression -> relational_expression < shift_expression 	0
? OR_OP } ] ) AND_OP ; : , EQ_OP < > LE_OP GE_OP 
relational_expression -> shift_expression 	0
? OR_OP } ] ) AND_OP ; : , EQ_OP < > LE_OP GE_OP 
multiplicative_expression -> cast_expression 	0
? OR_OP ] } AND_OP ) ; : , EQ_OP < * / % 
relational_expression -> relational_expression > shift_expression 	0
? OR_OP } ] ) AND_OP ; : , EQ_OP < > LE_OP GE_OP 
relational_expression -> relational_expression LE_OP shift_expression 	0
? OR_OP } ] ) AND_OP ; : , EQ_OP < > LE_OP GE_OP 
unary_expression -> unary_operator cast_expression 	0
? OR_OP ] } AND_OP ) ; : , EQ_OP < * 
relational_expression -> relational_expression GE_OP shift_expression 	0
? OR_OP } ] ) AND_OP ; : , EQ_OP < > LE_OP GE_OP 
shift_expression -> additive_expression 	0
? OR_OP ] } AND_OP ) ; : , EQ_OP < LEFT_OP RIGHT_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	0
? OR_OP ] } AND_OP ) ; : , EQ_OP < LEFT_OP RIGHT_OP 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
? OR_OP ] } AND_OP ) ; : , EQ_OP < LEFT_OP RIGHT_OP 
primary_expression -> CONSTANT 	0
? OR_OP ] } AND_OP ) ; : , EQ_OP < * . ( 
additive_expression -> multiplicative_expression 	0
? OR_OP } ] ) AND_OP ; : , EQ_OP < + - 
additive_expression -> additive_expression + multiplicative_expression 	0
? OR_OP } ] ) AND_OP ; : , EQ_OP < + - 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
additive_expression -> additive_expression - multiplicative_expression 	0
? OR_OP } ] ) AND_OP ; : , EQ_OP < + - 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
? OR_OP ] } AND_OP ) ; : , EQ_OP < * / % 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
? OR_OP ] } AND_OP ) ; : , EQ_OP < * / % 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
? OR_OP ] } AND_OP ) ; : , EQ_OP < * / % 
cast_expression -> ( type_name ) cast_expression 	0
? OR_OP } ] ) AND_OP ; : , EQ_OP < * 
unary_expression -> DEC_OP unary_expression 	0
? OR_OP ] } AND_OP ) ; : , EQ_OP < * 
primary_expression -> IDENTIFIER 	0
? OR_OP ] } AND_OP ) ; : , EQ_OP < * . ( 
unary_expression -> postfix_expression 	0
? OR_OP ] } AND_OP ) ; : , EQ_OP < * 
unary_expression -> SIZEOF unary_expression 	0
? OR_OP ] } AND_OP ) ; : , EQ_OP < * 
postfix_expression -> postfix_expression . IDENTIFIER 	0
? OR_OP } ] ) AND_OP ; : , EQ_OP < * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> primary_expression 	0
? OR_OP } ] ) AND_OP ; : , EQ_OP < * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression ( ) 	0
? OR_OP } ] ) AND_OP ; : , EQ_OP < * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
? OR_OP } ] ) AND_OP ; : , EQ_OP < * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression INC_OP 	0
? OR_OP } ] ) AND_OP ; : , EQ_OP < * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
? OR_OP } ] ) AND_OP ; : , EQ_OP < * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
? OR_OP } ] ) AND_OP ; : , EQ_OP < * . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
primary_expression -> ( expression ) 	0
? OR_OP ] } AND_OP ) ; : , EQ_OP < * . ( 
primary_expression -> STRING_LITERAL 	0
? OR_OP ] } AND_OP ) ; : , EQ_OP < * . ( 

204 61
conditional_expression -> logical_or_expression ? expression : conditional_expression 	2
] } ; ) : , 
cast_expression -> ( type_name ) cast_expression 	0
OR_OP ? : * < EQ_OP 
expression -> expression , assignment_expression 	0
: , 
primary_expression -> STRING_LITERAL 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
expression -> assignment_expression 	0
: , 
primary_expression -> ( expression ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
unary_expression -> SIZEOF ( type_name ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP : * < 
and_expression -> equality_expression 	0
OR_OP ? : & 
assignment_expression -> conditional_expression 	0
: 
assignment_expression -> unary_expression assignment_operator assignment_expression 	0
: 
conditional_expression -> logical_or_expression 	0
: 
postfix_expression -> postfix_expression . IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
conditional_expression -> logical_or_expression ? expression : conditional_expression 	0
: 
unary_expression -> DEC_OP unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP : * < 
primary_expression -> IDENTIFIER 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
unary_expression -> postfix_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP : * < 
unary_expression -> INC_OP unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP : * < 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
equality_expression -> equality_expression EQ_OP relational_expression 	0
NE_OP ? OR_OP : EQ_OP 
unary_expression -> unary_operator cast_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP : * < 
relational_expression -> relational_expression LE_OP shift_expression 	0
OR_OP ? GE_OP : < EQ_OP > LE_OP 
unary_expression -> SIZEOF unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP : * < 
logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression 	0
? OR_OP : AND_OP 
logical_or_expression -> logical_or_expression OR_OP logical_and_expression 	0
OR_OP ? : 
logical_or_expression -> logical_and_expression 	0
OR_OP ? : 
cast_expression -> unary_expression 	0
OR_OP ? : * < EQ_OP 
postfix_expression -> primary_expression 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression ( ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression INC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
equality_expression -> equality_expression NE_OP relational_expression 	0
NE_OP ? OR_OP : EQ_OP 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
additive_expression -> additive_expression + multiplicative_expression 	0
OR_OP ? : < EQ_OP + - 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
logical_and_expression -> inclusive_or_expression 	0
? OR_OP : AND_OP 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
/ ? OR_OP * : EQ_OP < % 
primary_expression -> CONSTANT 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
? OR_OP : EQ_OP < LEFT_OP RIGHT_OP 
inclusive_or_expression -> exclusive_or_expression 	0
OR_OP ? : | 
inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression 	0
OR_OP ? : | 
and_expression -> and_expression & equality_expression 	0
OR_OP ? : & 
exclusive_or_expression -> and_expression 	0
? OR_OP : ^ 
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	0
? OR_OP : ^ 
equality_expression -> relational_expression 	0
NE_OP ? OR_OP : EQ_OP 
relational_expression -> relational_expression < shift_expression 	0
OR_OP ? GE_OP : < EQ_OP > LE_OP 
relational_expression -> shift_expression 	0
OR_OP ? GE_OP : < EQ_OP > LE_OP 
multiplicative_expression -> cast_expression 	0
/ ? OR_OP * : EQ_OP < % 
relational_expression -> relational_expression > shift_expression 	0
OR_OP ? GE_OP : < EQ_OP > LE_OP 
relational_expression -> relational_expression GE_OP shift_expression 	0
OR_OP ? GE_OP : < EQ_OP > LE_OP 
shift_expression -> additive_expression 	0
? OR_OP : EQ_OP < LEFT_OP RIGHT_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	0
? OR_OP : EQ_OP < LEFT_OP RIGHT_OP 
additive_expression -> multiplicative_expression 	0
OR_OP ? : < EQ_OP + - 
additive_expression -> additive_expression - multiplicative_expression 	0
OR_OP ? : < EQ_OP + - 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
/ ? OR_OP * : EQ_OP < % 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
/ ? OR_OP * : EQ_OP < % 

205 53
and_expression -> equality_expression 	0
? OR_OP ] } ; ) : , & 
unary_expression -> SIZEOF ( type_name ) 	0
OR_OP ? } ] ; ) : EQ_OP , < * 
exclusive_or_expression -> and_expression 	0
OR_OP ? } ] ; ) : , ^ 
logical_or_expression -> logical_or_expression OR_OP logical_and_expression 	2
OR_OP ? ] } ; ) : , 
logical_and_expression -> inclusive_or_expression 	0
OR_OP ? } ] ; AND_OP ) : , 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
OR_OP ? } ] ; ) : EQ_OP , < * / % 
logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression 	0
OR_OP ? } ] ; AND_OP ) : , 
unary_expression -> SIZEOF unary_expression 	0
OR_OP ? } ] ; ) : EQ_OP , < * 
inclusive_or_expression -> exclusive_or_expression 	0
? OR_OP ] } ; ) : | , 
and_expression -> and_expression & equality_expression 	0
? OR_OP ] } ; ) : , & 
inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression 	0
? OR_OP ] } ; ) : | , 
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	0
OR_OP ? } ] ; ) : , ^ 
equality_expression -> equality_expression EQ_OP relational_expression 	0
OR_OP ? } ] ; ) : EQ_OP , NE_OP 
unary_expression -> INC_OP unary_expression 	0
OR_OP ? } ] ; ) : EQ_OP , < * 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
OR_OP ? ] } ; ) : , EQ_OP < * . ( [ PTR_OP INC_OP DEC_OP 
equality_expression -> relational_expression 	0
OR_OP ? } ] ; ) : EQ_OP , NE_OP 
equality_expression -> equality_expression NE_OP relational_expression 	0
OR_OP ? } ] ; ) : EQ_OP , NE_OP 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
relational_expression -> relational_expression < shift_expression 	0
OR_OP ? ] } ; ) : , EQ_OP < > LE_OP GE_OP 
relational_expression -> shift_expression 	0
OR_OP ? ] } ; ) : , EQ_OP < > LE_OP GE_OP 
multiplicative_expression -> cast_expression 	0
OR_OP ? } ] ; ) : EQ_OP , < * / % 
relational_expression -> relational_expression > shift_expression 	0
OR_OP ? ] } ; ) : , EQ_OP < > LE_OP GE_OP 
relational_expression -> relational_expression LE_OP shift_expression 	0
OR_OP ? ] } ; ) : , EQ_OP < > LE_OP GE_OP 
unary_expression -> unary_operator cast_expression 	0
OR_OP ? } ] ; ) : EQ_OP , < * 
relational_expression -> relational_expression GE_OP shift_expression 	0
OR_OP ? ] } ; ) : , EQ_OP < > LE_OP GE_OP 
shift_expression -> additive_expression 	0
OR_OP ? } ] ; ) : EQ_OP , < LEFT_OP RIGHT_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	0
OR_OP ? } ] ; ) : EQ_OP , < LEFT_OP RIGHT_OP 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
OR_OP ? } ] ; ) : EQ_OP , < LEFT_OP RIGHT_OP 
primary_expression -> CONSTANT 	0
OR_OP ? } ] ; ) : EQ_OP , < * . ( 
additive_expression -> multiplicative_expression 	0
OR_OP ? ] } ; ) : , EQ_OP < + - 
additive_expression -> additive_expression + multiplicative_expression 	0
OR_OP ? ] } ; ) : , EQ_OP < + - 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
additive_expression -> additive_expression - multiplicative_expression 	0
OR_OP ? ] } ; ) : , EQ_OP < + - 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
OR_OP ? } ] ; ) : EQ_OP , < * / % 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
OR_OP ? } ] ; ) : EQ_OP , < * / % 
cast_expression -> ( type_name ) cast_expression 	0
OR_OP ? ] } ; ) : , EQ_OP < * 
cast_expression -> unary_expression 	0
OR_OP ? ] } ; ) : , EQ_OP < * 
unary_expression -> DEC_OP unary_expression 	0
OR_OP ? } ] ; ) : EQ_OP , < * 
primary_expression -> IDENTIFIER 	0
OR_OP ? } ] ; ) : EQ_OP , < * . ( 
unary_expression -> postfix_expression 	0
OR_OP ? } ] ; ) : EQ_OP , < * 
postfix_expression -> postfix_expression . IDENTIFIER 	0
OR_OP ? ] } ; ) : , EQ_OP < * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> primary_expression 	0
OR_OP ? ] } ; ) : , EQ_OP < * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression ( ) 	0
OR_OP ? ] } ; ) : , EQ_OP < * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
OR_OP ? ] } ; ) : , EQ_OP < * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression INC_OP 	0
OR_OP ? ] } ; ) : , EQ_OP < * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
OR_OP ? ] } ; ) : , EQ_OP < * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
OR_OP ? ] } ; ) : , EQ_OP < * . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
primary_expression -> ( expression ) 	0
OR_OP ? } ] ; ) : EQ_OP , < * . ( 
primary_expression -> STRING_LITERAL 	0
OR_OP ? } ] ; ) : EQ_OP , < * . ( 

206 1
init_declarator_list -> init_declarator_list , init_declarator 	3
; , 

207 65
initializer -> assignment_expression 	0
} , 
primary_expression -> ( expression ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
initializer -> { initializer_list } 	1
} , ; 
relational_expression -> relational_expression LE_OP shift_expression 	0
? OR_OP LE_OP } < , EQ_OP > GE_OP 
initializer -> { initializer_list , } 	1
} , ; 
unary_expression -> unary_operator cast_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN } = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < , * 
inclusive_or_expression -> exclusive_or_expression 	0
OR_OP ? } | , 
initializer_list -> initializer_list , initializer 	0
} , 
assignment_expression -> conditional_expression 	0
} , 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
/ OR_OP ? % } EQ_OP , < * 
initializer -> { initializer_list } 	0
} , 
equality_expression -> relational_expression 	0
NE_OP ? OR_OP } EQ_OP , 
initializer_list -> initializer 	0
} , 
postfix_expression -> postfix_expression ( ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
initializer -> { initializer_list , } 	0
} , 
assignment_expression -> unary_expression assignment_operator assignment_expression 	0
} , 
conditional_expression -> logical_or_expression ? expression : conditional_expression 	0
} , 
postfix_expression -> postfix_expression . IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
conditional_expression -> logical_or_expression 	0
} , 
primary_expression -> IDENTIFIER 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
unary_expression -> DEC_OP unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN } = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < , * 
and_expression -> equality_expression 	0
OR_OP ? } , & 
unary_expression -> SIZEOF ( type_name ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN } = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < , * 
unary_expression -> postfix_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN } = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < , * 
equality_expression -> equality_expression EQ_OP relational_expression 	0
NE_OP ? OR_OP } EQ_OP , 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
unary_expression -> INC_OP unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN } = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < , * 
logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression 	0
? OR_OP } , AND_OP 
unary_expression -> SIZEOF unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN } = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < , * 
logical_or_expression -> logical_or_expression OR_OP logical_and_expression 	0
OR_OP ? } , 
cast_expression -> unary_expression 	0
OR_OP ? } < , EQ_OP * 
logical_or_expression -> logical_and_expression 	0
OR_OP ? } , 
postfix_expression -> primary_expression 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression INC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
equality_expression -> equality_expression NE_OP relational_expression 	0
NE_OP ? OR_OP } EQ_OP , 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
additive_expression -> additive_expression + multiplicative_expression 	0
OR_OP ? - } < , EQ_OP + 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
/ OR_OP ? % } EQ_OP , < * 
logical_and_expression -> inclusive_or_expression 	0
? OR_OP } , AND_OP 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
? OR_OP } EQ_OP , < LEFT_OP RIGHT_OP 
primary_expression -> CONSTANT 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
primary_expression -> STRING_LITERAL 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
and_expression -> and_expression & equality_expression 	0
OR_OP ? } , & 
inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression 	0
OR_OP ? } | , 
exclusive_or_expression -> and_expression 	0
? OR_OP } , ^ 
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	0
? OR_OP } , ^ 
multiplicative_expression -> cast_expression 	0
/ OR_OP ? % } EQ_OP , < * 
relational_expression -> shift_expression 	0
? OR_OP LE_OP } < , EQ_OP > GE_OP 
relational_expression -> relational_expression < shift_expression 	0
? OR_OP LE_OP } < , EQ_OP > GE_OP 
relational_expression -> relational_expression > shift_expression 	0
? OR_OP LE_OP } < , EQ_OP > GE_OP 
relational_expression -> relational_expression GE_OP shift_expression 	0
? OR_OP LE_OP } < , EQ_OP > GE_OP 
shift_expression -> additive_expression 	0
? OR_OP } EQ_OP , < LEFT_OP RIGHT_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	0
? OR_OP } EQ_OP , < LEFT_OP RIGHT_OP 
additive_expression -> multiplicative_expression 	0
OR_OP ? - } < , EQ_OP + 
additive_expression -> additive_expression - multiplicative_expression 	0
OR_OP ? - } < , EQ_OP + 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
/ OR_OP ? % } EQ_OP , < * 
cast_expression -> ( type_name ) cast_expression 	0
OR_OP ? } < , EQ_OP * 

208 1
initializer -> assignment_expression 	1
} , ; 

209 1
init_declarator -> declarator = initializer 	3
; , 

210 1
function_definition -> declaration_specifiers declarator declaration_list compound_statement 	4
LONG $ STATIC INT IDENTIFIER SHORT SIGNED TYPE_NAME VOLATILE FLOAT REGISTER STRUCT CONST UNION * CHAR UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID ENUM 

211 88
labeled_statement -> IDENTIFIER : statement 	2
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
iteration_statement -> FOR ( expression_statement expression_statement ) statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
iteration_statement -> WHILE ( expression ) statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
statement -> labeled_statement 	0
} ELSE FOR WHILE IDENTIFIER DEFAULT GOTO CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
statement -> iteration_statement 	0
} ELSE FOR WHILE IDENTIFIER DEFAULT GOTO CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
additive_expression -> additive_expression + multiplicative_expression 	0
OR_OP ? + ; < EQ_OP - 
statement -> compound_statement 	0
} ELSE FOR WHILE IDENTIFIER DEFAULT GOTO CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
statement -> jump_statement 	0
} ELSE FOR WHILE IDENTIFIER DEFAULT GOTO CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
statement -> expression_statement 	0
} ELSE FOR WHILE IDENTIFIER DEFAULT GOTO CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
logical_and_expression -> inclusive_or_expression 	0
? OR_OP ; AND_OP 
statement -> selection_statement 	0
} ELSE FOR WHILE IDENTIFIER DEFAULT GOTO CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
iteration_statement -> DO statement WHILE ( expression ) ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
iteration_statement -> FOR ( expression_statement expression_statement expression ) statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
compound_statement -> { declaration_list } 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
primary_expression -> CONSTANT 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
compound_statement -> { statement_list } 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
labeled_statement -> DEFAULT : statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
compound_statement -> { } 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
unary_expression -> DEC_OP unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
primary_expression -> IDENTIFIER 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
compound_statement -> { declaration_list statement_list } 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
postfix_expression -> primary_expression 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
jump_statement -> GOTO IDENTIFIER ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
postfix_expression -> postfix_expression ( ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
labeled_statement -> IDENTIFIER : statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
jump_statement -> RETURN ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	0
? OR_OP ; ^ 
jump_statement -> CONTINUE ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
jump_statement -> BREAK ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
jump_statement -> RETURN expression ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
labeled_statement -> CASE constant_expression : statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression 	0
OR_OP ? ; | 
and_expression -> and_expression & equality_expression 	0
OR_OP ? ; & 
expression_statement -> expression ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
expression_statement -> ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
selection_statement -> IF ( expression ) statement ELSE statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
selection_statement -> IF ( expression ) statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
selection_statement -> SWITCH ( expression ) statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
primary_expression -> ( expression ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
expression -> assignment_expression 	0
; , 
primary_expression -> STRING_LITERAL 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
expression -> expression , assignment_expression 	0
; , 
assignment_expression -> conditional_expression 	0
; 
assignment_expression -> unary_expression assignment_operator assignment_expression 	0
; 
conditional_expression -> logical_or_expression ? expression : conditional_expression 	0
; 
postfix_expression -> postfix_expression . IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
conditional_expression -> logical_or_expression 	0
; 
unary_expression -> SIZEOF ( type_name ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
unary_expression -> postfix_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
unary_expression -> INC_OP unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
unary_expression -> unary_operator cast_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression 	0
? OR_OP ; AND_OP 
unary_expression -> SIZEOF unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
logical_or_expression -> logical_or_expression OR_OP logical_and_expression 	0
OR_OP ? ; 
logical_or_expression -> logical_and_expression 	0
OR_OP ? ; 
postfix_expression -> postfix_expression INC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
inclusive_or_expression -> exclusive_or_expression 	0
OR_OP ? ; | 
exclusive_or_expression -> and_expression 	0
? OR_OP ; ^ 
and_expression -> equality_expression 	0
OR_OP ? ; & 
equality_expression -> equality_expression EQ_OP relational_expression 	0
NE_OP ? OR_OP ; EQ_OP 
equality_expression -> relational_expression 	0
NE_OP ? OR_OP ; EQ_OP 
equality_expression -> equality_expression NE_OP relational_expression 	0
NE_OP ? OR_OP ; EQ_OP 
relational_expression -> shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression < shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression > shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression LE_OP shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression GE_OP shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
shift_expression -> additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP < RIGHT_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP < RIGHT_OP 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP < RIGHT_OP 
additive_expression -> multiplicative_expression 	0
OR_OP ? + ; < EQ_OP - 
additive_expression -> additive_expression - multiplicative_expression 	0
OR_OP ? + ; < EQ_OP - 
multiplicative_expression -> cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
cast_expression -> ( type_name ) cast_expression 	0
OR_OP ? ; < EQ_OP * 
cast_expression -> unary_expression 	0
OR_OP ? ; < EQ_OP * 

212 1
jump_statement -> CONTINUE ; 	2
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 

213 62
postfix_expression -> postfix_expression . IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
conditional_expression -> logical_or_expression 	0
) 
conditional_expression -> logical_or_expression ? expression : conditional_expression 	0
) 
postfix_expression -> postfix_expression ( ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
selection_statement -> IF ( expression ) statement ELSE statement 	2
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
assignment_expression -> conditional_expression 	0
) 
and_expression -> equality_expression 	0
OR_OP ? ) & 
unary_expression -> SIZEOF ( type_name ) 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
selection_statement -> IF ( expression ) statement 	2
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
primary_expression -> STRING_LITERAL 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
expression -> expression , assignment_expression 	0
) , 
primary_expression -> ( expression ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
expression -> assignment_expression 	0
) , 
assignment_expression -> unary_expression assignment_operator assignment_expression 	0
) 
primary_expression -> IDENTIFIER 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
unary_expression -> DEC_OP unary_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
unary_expression -> postfix_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
equality_expression -> equality_expression EQ_OP relational_expression 	0
NE_OP ? OR_OP ) EQ_OP 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
unary_expression -> INC_OP unary_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
relational_expression -> relational_expression LE_OP shift_expression 	0
OR_OP ? ) < EQ_OP > LE_OP GE_OP 
unary_expression -> unary_operator cast_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression 	0
? OR_OP AND_OP ) 
unary_expression -> SIZEOF unary_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
logical_or_expression -> logical_or_expression OR_OP logical_and_expression 	0
OR_OP ? ) 
cast_expression -> unary_expression 	0
OR_OP ? ) < EQ_OP * 
logical_or_expression -> logical_and_expression 	0
OR_OP ? ) 
postfix_expression -> primary_expression 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression INC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
equality_expression -> equality_expression NE_OP relational_expression 	0
NE_OP ? OR_OP ) EQ_OP 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
additive_expression -> additive_expression + multiplicative_expression 	0
OR_OP ? ) < EQ_OP + - 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
/ ? OR_OP ) EQ_OP < * % 
logical_and_expression -> inclusive_or_expression 	0
? OR_OP AND_OP ) 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
? OR_OP ) EQ_OP < LEFT_OP RIGHT_OP 
primary_expression -> CONSTANT 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
inclusive_or_expression -> exclusive_or_expression 	0
OR_OP ? ) | 
and_expression -> and_expression & equality_expression 	0
OR_OP ? ) & 
inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression 	0
OR_OP ? ) | 
exclusive_or_expression -> and_expression 	0
? OR_OP ) ^ 
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	0
? OR_OP ) ^ 
equality_expression -> relational_expression 	0
NE_OP ? OR_OP ) EQ_OP 
multiplicative_expression -> cast_expression 	0
/ ? OR_OP ) EQ_OP < * % 
relational_expression -> shift_expression 	0
OR_OP ? ) < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression < shift_expression 	0
OR_OP ? ) < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression > shift_expression 	0
OR_OP ? ) < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression GE_OP shift_expression 	0
OR_OP ? ) < EQ_OP > LE_OP GE_OP 
shift_expression -> additive_expression 	0
? OR_OP ) EQ_OP < LEFT_OP RIGHT_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	0
? OR_OP ) EQ_OP < LEFT_OP RIGHT_OP 
additive_expression -> multiplicative_expression 	0
OR_OP ? ) < EQ_OP + - 
additive_expression -> additive_expression - multiplicative_expression 	0
OR_OP ? ) < EQ_OP + - 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
/ ? OR_OP ) EQ_OP < * % 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
/ ? OR_OP ) EQ_OP < * % 
cast_expression -> ( type_name ) cast_expression 	0
OR_OP ? ) < EQ_OP * 

214 1
labeled_statement -> CASE constant_expression : statement 	2
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 

215 88
logical_and_expression -> inclusive_or_expression 	0
? OR_OP ; AND_OP 
statement -> selection_statement 	0
} ELSE FOR WHILE IDENTIFIER DEFAULT GOTO CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
expression_statement -> ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
labeled_statement -> DEFAULT : statement 	2
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
iteration_statement -> FOR ( expression_statement expression_statement ) statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
iteration_statement -> WHILE ( expression ) statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
statement -> labeled_statement 	0
} ELSE FOR WHILE IDENTIFIER DEFAULT GOTO CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
statement -> iteration_statement 	0
} ELSE FOR WHILE IDENTIFIER DEFAULT GOTO CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
additive_expression -> additive_expression + multiplicative_expression 	0
OR_OP ? + ; < EQ_OP - 
statement -> compound_statement 	0
} ELSE FOR WHILE IDENTIFIER DEFAULT GOTO CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
statement -> jump_statement 	0
} ELSE FOR WHILE IDENTIFIER DEFAULT GOTO CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
statement -> expression_statement 	0
} ELSE FOR WHILE IDENTIFIER DEFAULT GOTO CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
iteration_statement -> DO statement WHILE ( expression ) ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
iteration_statement -> FOR ( expression_statement expression_statement expression ) statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
compound_statement -> { declaration_list } 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
primary_expression -> CONSTANT 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
compound_statement -> { statement_list } 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
labeled_statement -> DEFAULT : statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
compound_statement -> { } 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
unary_expression -> DEC_OP unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
primary_expression -> IDENTIFIER 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
compound_statement -> { declaration_list statement_list } 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
postfix_expression -> primary_expression 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
jump_statement -> GOTO IDENTIFIER ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
postfix_expression -> postfix_expression ( ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
labeled_statement -> IDENTIFIER : statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
jump_statement -> RETURN ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	0
? OR_OP ; ^ 
jump_statement -> CONTINUE ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
jump_statement -> BREAK ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
jump_statement -> RETURN expression ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
labeled_statement -> CASE constant_expression : statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression 	0
OR_OP ? ; | 
and_expression -> and_expression & equality_expression 	0
OR_OP ? ; & 
expression_statement -> expression ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
selection_statement -> IF ( expression ) statement ELSE statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
selection_statement -> IF ( expression ) statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
selection_statement -> SWITCH ( expression ) statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
primary_expression -> ( expression ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
expression -> assignment_expression 	0
; , 
primary_expression -> STRING_LITERAL 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
expression -> expression , assignment_expression 	0
; , 
assignment_expression -> conditional_expression 	0
; 
assignment_expression -> unary_expression assignment_operator assignment_expression 	0
; 
conditional_expression -> logical_or_expression ? expression : conditional_expression 	0
; 
postfix_expression -> postfix_expression . IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
conditional_expression -> logical_or_expression 	0
; 
unary_expression -> SIZEOF ( type_name ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
unary_expression -> postfix_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
unary_expression -> INC_OP unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
unary_expression -> unary_operator cast_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression 	0
? OR_OP ; AND_OP 
unary_expression -> SIZEOF unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
logical_or_expression -> logical_or_expression OR_OP logical_and_expression 	0
OR_OP ? ; 
logical_or_expression -> logical_and_expression 	0
OR_OP ? ; 
postfix_expression -> postfix_expression INC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
inclusive_or_expression -> exclusive_or_expression 	0
OR_OP ? ; | 
exclusive_or_expression -> and_expression 	0
? OR_OP ; ^ 
and_expression -> equality_expression 	0
OR_OP ? ; & 
equality_expression -> equality_expression EQ_OP relational_expression 	0
NE_OP ? OR_OP ; EQ_OP 
equality_expression -> relational_expression 	0
NE_OP ? OR_OP ; EQ_OP 
equality_expression -> equality_expression NE_OP relational_expression 	0
NE_OP ? OR_OP ; EQ_OP 
relational_expression -> shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression < shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression > shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression LE_OP shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression GE_OP shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
shift_expression -> additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP < RIGHT_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP < RIGHT_OP 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP < RIGHT_OP 
additive_expression -> multiplicative_expression 	0
OR_OP ? + ; < EQ_OP - 
additive_expression -> additive_expression - multiplicative_expression 	0
OR_OP ? + ; < EQ_OP - 
multiplicative_expression -> cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
cast_expression -> ( type_name ) cast_expression 	0
OR_OP ? ; < EQ_OP * 
cast_expression -> unary_expression 	0
OR_OP ? ; < EQ_OP * 

216 61
primary_expression -> STRING_LITERAL 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
expression -> expression , assignment_expression 	0
) , 
primary_expression -> ( expression ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
selection_statement -> SWITCH ( expression ) statement 	2
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
expression -> assignment_expression 	0
) , 
and_expression -> equality_expression 	0
OR_OP ? ) & 
unary_expression -> SIZEOF ( type_name ) 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
assignment_expression -> conditional_expression 	0
) 
assignment_expression -> unary_expression assignment_operator assignment_expression 	0
) 
postfix_expression -> postfix_expression . IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
conditional_expression -> logical_or_expression 	0
) 
conditional_expression -> logical_or_expression ? expression : conditional_expression 	0
) 
primary_expression -> IDENTIFIER 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
unary_expression -> DEC_OP unary_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
unary_expression -> postfix_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
equality_expression -> equality_expression EQ_OP relational_expression 	0
NE_OP ? OR_OP ) EQ_OP 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
unary_expression -> INC_OP unary_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
relational_expression -> relational_expression LE_OP shift_expression 	0
OR_OP ? ) < EQ_OP > LE_OP GE_OP 
unary_expression -> unary_operator cast_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression 	0
? OR_OP AND_OP ) 
unary_expression -> SIZEOF unary_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
logical_or_expression -> logical_or_expression OR_OP logical_and_expression 	0
OR_OP ? ) 
cast_expression -> unary_expression 	0
OR_OP ? ) < EQ_OP * 
logical_or_expression -> logical_and_expression 	0
OR_OP ? ) 
postfix_expression -> primary_expression 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression ( ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression INC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
equality_expression -> equality_expression NE_OP relational_expression 	0
NE_OP ? OR_OP ) EQ_OP 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
additive_expression -> additive_expression + multiplicative_expression 	0
OR_OP ? ) < EQ_OP + - 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
/ ? OR_OP ) EQ_OP < * % 
logical_and_expression -> inclusive_or_expression 	0
? OR_OP AND_OP ) 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
? OR_OP ) EQ_OP < LEFT_OP RIGHT_OP 
primary_expression -> CONSTANT 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
inclusive_or_expression -> exclusive_or_expression 	0
OR_OP ? ) | 
and_expression -> and_expression & equality_expression 	0
OR_OP ? ) & 
inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression 	0
OR_OP ? ) | 
exclusive_or_expression -> and_expression 	0
? OR_OP ) ^ 
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	0
? OR_OP ) ^ 
equality_expression -> relational_expression 	0
NE_OP ? OR_OP ) EQ_OP 
multiplicative_expression -> cast_expression 	0
/ ? OR_OP ) EQ_OP < * % 
relational_expression -> shift_expression 	0
OR_OP ? ) < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression < shift_expression 	0
OR_OP ? ) < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression > shift_expression 	0
OR_OP ? ) < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression GE_OP shift_expression 	0
OR_OP ? ) < EQ_OP > LE_OP GE_OP 
shift_expression -> additive_expression 	0
? OR_OP ) EQ_OP < LEFT_OP RIGHT_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	0
? OR_OP ) EQ_OP < LEFT_OP RIGHT_OP 
additive_expression -> multiplicative_expression 	0
OR_OP ? ) < EQ_OP + - 
additive_expression -> additive_expression - multiplicative_expression 	0
OR_OP ? ) < EQ_OP + - 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
/ ? OR_OP ) EQ_OP < * % 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
/ ? OR_OP ) EQ_OP < * % 
cast_expression -> ( type_name ) cast_expression 	0
OR_OP ? ) < EQ_OP * 

217 61
primary_expression -> STRING_LITERAL 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
expression -> expression , assignment_expression 	0
) , 
primary_expression -> ( expression ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
expression -> assignment_expression 	0
) , 
logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression 	0
? OR_OP AND_OP ) 
unary_expression -> SIZEOF unary_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
iteration_statement -> WHILE ( expression ) statement 	2
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
and_expression -> equality_expression 	0
OR_OP ? ) & 
unary_expression -> SIZEOF ( type_name ) 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
assignment_expression -> conditional_expression 	0
) 
assignment_expression -> unary_expression assignment_operator assignment_expression 	0
) 
postfix_expression -> postfix_expression . IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
conditional_expression -> logical_or_expression 	0
) 
conditional_expression -> logical_or_expression ? expression : conditional_expression 	0
) 
primary_expression -> IDENTIFIER 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
unary_expression -> DEC_OP unary_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
unary_expression -> postfix_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
equality_expression -> equality_expression EQ_OP relational_expression 	0
NE_OP ? OR_OP ) EQ_OP 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
unary_expression -> INC_OP unary_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
relational_expression -> relational_expression LE_OP shift_expression 	0
OR_OP ? ) < EQ_OP > LE_OP GE_OP 
unary_expression -> unary_operator cast_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
logical_or_expression -> logical_or_expression OR_OP logical_and_expression 	0
OR_OP ? ) 
cast_expression -> unary_expression 	0
OR_OP ? ) < EQ_OP * 
logical_or_expression -> logical_and_expression 	0
OR_OP ? ) 
postfix_expression -> primary_expression 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression ( ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression INC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
equality_expression -> equality_expression NE_OP relational_expression 	0
NE_OP ? OR_OP ) EQ_OP 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
additive_expression -> additive_expression + multiplicative_expression 	0
OR_OP ? ) < EQ_OP + - 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
/ ? OR_OP ) EQ_OP < * % 
logical_and_expression -> inclusive_or_expression 	0
? OR_OP AND_OP ) 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
? OR_OP ) EQ_OP < LEFT_OP RIGHT_OP 
primary_expression -> CONSTANT 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
inclusive_or_expression -> exclusive_or_expression 	0
OR_OP ? ) | 
and_expression -> and_expression & equality_expression 	0
OR_OP ? ) & 
inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression 	0
OR_OP ? ) | 
exclusive_or_expression -> and_expression 	0
? OR_OP ) ^ 
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	0
? OR_OP ) ^ 
equality_expression -> relational_expression 	0
NE_OP ? OR_OP ) EQ_OP 
multiplicative_expression -> cast_expression 	0
/ ? OR_OP ) EQ_OP < * % 
relational_expression -> shift_expression 	0
OR_OP ? ) < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression < shift_expression 	0
OR_OP ? ) < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression > shift_expression 	0
OR_OP ? ) < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression GE_OP shift_expression 	0
OR_OP ? ) < EQ_OP > LE_OP GE_OP 
shift_expression -> additive_expression 	0
? OR_OP ) EQ_OP < LEFT_OP RIGHT_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	0
? OR_OP ) EQ_OP < LEFT_OP RIGHT_OP 
additive_expression -> multiplicative_expression 	0
OR_OP ? ) < EQ_OP + - 
additive_expression -> additive_expression - multiplicative_expression 	0
OR_OP ? ) < EQ_OP + - 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
/ ? OR_OP ) EQ_OP < * % 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
/ ? OR_OP ) EQ_OP < * % 
cast_expression -> ( type_name ) cast_expression 	0
OR_OP ? ) < EQ_OP * 

218 1
iteration_statement -> DO statement WHILE ( expression ) ; 	2
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 

219 64
primary_expression -> STRING_LITERAL 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
expression -> expression , assignment_expression 	0
; , 
primary_expression -> ( expression ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
expression -> assignment_expression 	0
; , 
logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression 	0
? OR_OP ; AND_OP 
unary_expression -> SIZEOF unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
iteration_statement -> FOR ( expression_statement expression_statement ) statement 	2
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
postfix_expression -> postfix_expression DEC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
iteration_statement -> FOR ( expression_statement expression_statement expression ) statement 	2
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
and_expression -> and_expression & equality_expression 	0
OR_OP ? ; & 
inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression 	0
OR_OP ? ; | 
expression_statement -> expression ; 	0
CONSTANT SIZEOF - ; ( INC_OP DEC_OP IDENTIFIER & STRING_LITERAL * ~ + ! 
relational_expression -> relational_expression GE_OP shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
expression_statement -> ; 	0
CONSTANT SIZEOF - ; ( INC_OP DEC_OP IDENTIFIER & STRING_LITERAL * ~ + ! 
assignment_expression -> conditional_expression 	0
; 
assignment_expression -> unary_expression assignment_operator assignment_expression 	0
; 
conditional_expression -> logical_or_expression ? expression : conditional_expression 	0
; 
postfix_expression -> postfix_expression . IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
conditional_expression -> logical_or_expression 	0
; 
primary_expression -> IDENTIFIER 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
unary_expression -> DEC_OP unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
and_expression -> equality_expression 	0
OR_OP ? ; & 
unary_expression -> SIZEOF ( type_name ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
unary_expression -> postfix_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
equality_expression -> equality_expression EQ_OP relational_expression 	0
NE_OP ? OR_OP ; EQ_OP 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
unary_expression -> INC_OP unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
relational_expression -> relational_expression LE_OP shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
unary_expression -> unary_operator cast_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
logical_or_expression -> logical_or_expression OR_OP logical_and_expression 	0
OR_OP ? ; 
cast_expression -> unary_expression 	0
OR_OP ? ; < EQ_OP * 
logical_or_expression -> logical_and_expression 	0
OR_OP ? ; 
postfix_expression -> primary_expression 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression ( ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression INC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
equality_expression -> equality_expression NE_OP relational_expression 	0
NE_OP ? OR_OP ; EQ_OP 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
additive_expression -> additive_expression + multiplicative_expression 	0
OR_OP ? + ; < EQ_OP - 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
logical_and_expression -> inclusive_or_expression 	0
? OR_OP ; AND_OP 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP < RIGHT_OP 
primary_expression -> CONSTANT 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
inclusive_or_expression -> exclusive_or_expression 	0
OR_OP ? ; | 
exclusive_or_expression -> and_expression 	0
? OR_OP ; ^ 
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	0
? OR_OP ; ^ 
equality_expression -> relational_expression 	0
NE_OP ? OR_OP ; EQ_OP 
multiplicative_expression -> cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
relational_expression -> shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression < shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression > shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
shift_expression -> additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP < RIGHT_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP < RIGHT_OP 
additive_expression -> multiplicative_expression 	0
OR_OP ? + ; < EQ_OP - 
additive_expression -> additive_expression - multiplicative_expression 	0
OR_OP ? + ; < EQ_OP - 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
cast_expression -> ( type_name ) cast_expression 	0
OR_OP ? ; < EQ_OP * 

220 1
jump_statement -> GOTO IDENTIFIER ; 	2
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 

221 1
jump_statement -> BREAK ; 	2
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 

222 1
jump_statement -> RETURN ; 	2
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 

223 2
expression -> expression , assignment_expression 	1
; , 
jump_statement -> RETURN expression ; 	2
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 

224 1
assignment_operator -> LEFT_ASSIGN 	1
SIZEOF CONSTANT - INC_OP ( DEC_OP IDENTIFIER & STRING_LITERAL * ~ + ! 

225 1
assignment_operator -> MOD_ASSIGN 	1
SIZEOF CONSTANT - INC_OP ( DEC_OP IDENTIFIER & STRING_LITERAL * ~ + ! 

226 1
assignment_operator -> MUL_ASSIGN 	1
SIZEOF CONSTANT - INC_OP ( DEC_OP IDENTIFIER & STRING_LITERAL * ~ + ! 

227 1
assignment_operator -> ADD_ASSIGN 	1
SIZEOF CONSTANT - INC_OP ( DEC_OP IDENTIFIER & STRING_LITERAL * ~ + ! 

228 1
assignment_operator -> = 	1
SIZEOF CONSTANT - INC_OP ( DEC_OP IDENTIFIER & STRING_LITERAL * ~ + ! 

229 1
assignment_operator -> DIV_ASSIGN 	1
SIZEOF CONSTANT - INC_OP ( DEC_OP IDENTIFIER & STRING_LITERAL * ~ + ! 

230 1
assignment_operator -> SUB_ASSIGN 	1
SIZEOF CONSTANT - INC_OP ( DEC_OP IDENTIFIER & STRING_LITERAL * ~ + ! 

231 1
assignment_operator -> RIGHT_ASSIGN 	1
SIZEOF CONSTANT - INC_OP ( DEC_OP IDENTIFIER & STRING_LITERAL * ~ + ! 

232 1
assignment_operator -> AND_ASSIGN 	1
SIZEOF CONSTANT - INC_OP ( DEC_OP IDENTIFIER & STRING_LITERAL * ~ + ! 

233 1
assignment_operator -> XOR_ASSIGN 	1
SIZEOF CONSTANT - INC_OP ( DEC_OP IDENTIFIER & STRING_LITERAL * ~ + ! 

234 1
assignment_operator -> OR_ASSIGN 	1
SIZEOF CONSTANT - INC_OP ( DEC_OP IDENTIFIER & STRING_LITERAL * ~ + ! 

235 59
assignment_expression -> unary_expression assignment_operator assignment_expression 	2
; ) ] } : , 
and_expression -> equality_expression 	0
? OR_OP ; ) } ] : , & 
unary_expression -> SIZEOF ( type_name ) 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN } = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP ] : , < * 
assignment_expression -> conditional_expression 	0
; ) } ] : , 
assignment_expression -> unary_expression assignment_operator assignment_expression 	0
; ) } ] : , 
postfix_expression -> postfix_expression . IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
conditional_expression -> logical_or_expression 	0
; ) ] } : , 
conditional_expression -> logical_or_expression ? expression : conditional_expression 	0
; ) ] } : , 
equality_expression -> equality_expression EQ_OP relational_expression 	0
OR_OP ? ; ) ] } : EQ_OP , NE_OP 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
unary_expression -> INC_OP unary_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN } = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP ] : , < * 
unary_expression -> postfix_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN } = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP ] : , < * 
primary_expression -> IDENTIFIER 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
unary_expression -> DEC_OP unary_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN } = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP ] : , < * 
relational_expression -> relational_expression LE_OP shift_expression 	0
OR_OP ? ; ) } ] : , EQ_OP < > LE_OP GE_OP 
unary_expression -> unary_operator cast_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN } = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP ] : , < * 
logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression 	0
OR_OP ? ; AND_OP ) ] } : , 
unary_expression -> SIZEOF unary_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN } = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP ] : , < * 
logical_or_expression -> logical_or_expression OR_OP logical_and_expression 	0
OR_OP ? ; ) } ] : , 
cast_expression -> unary_expression 	0
OR_OP ? ; ) } ] : , EQ_OP < * 
logical_or_expression -> logical_and_expression 	0
OR_OP ? ; ) } ] : , 
postfix_expression -> primary_expression 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression ( ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression INC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
equality_expression -> equality_expression NE_OP relational_expression 	0
OR_OP ? ; ) ] } : EQ_OP , NE_OP 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
additive_expression -> additive_expression + multiplicative_expression 	0
OR_OP ? ; ) } ] : , EQ_OP < + - 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
OR_OP ? ; ) ] } : EQ_OP , < * / % 
logical_and_expression -> inclusive_or_expression 	0
OR_OP ? ; AND_OP ) ] } : , 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
OR_OP ? ; ) ] } : EQ_OP , < LEFT_OP RIGHT_OP 
primary_expression -> CONSTANT 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
primary_expression -> ( expression ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
primary_expression -> STRING_LITERAL 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
inclusive_or_expression -> exclusive_or_expression 	0
? OR_OP ; ) } ] : | , 
and_expression -> and_expression & equality_expression 	0
? OR_OP ; ) } ] : , & 
inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression 	0
? OR_OP ; ) } ] : | , 
exclusive_or_expression -> and_expression 	0
OR_OP ? ; ) ] } : , ^ 
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	0
OR_OP ? ; ) ] } : , ^ 
equality_expression -> relational_expression 	0
OR_OP ? ; ) ] } : EQ_OP , NE_OP 
multiplicative_expression -> cast_expression 	0
OR_OP ? ; ) ] } : EQ_OP , < * / % 
relational_expression -> shift_expression 	0
OR_OP ? ; ) } ] : , EQ_OP < > LE_OP GE_OP 
relational_expression -> relational_expression < shift_expression 	0
OR_OP ? ; ) } ] : , EQ_OP < > LE_OP GE_OP 
relational_expression -> relational_expression > shift_expression 	0
OR_OP ? ; ) } ] : , EQ_OP < > LE_OP GE_OP 
relational_expression -> relational_expression GE_OP shift_expression 	0
OR_OP ? ; ) } ] : , EQ_OP < > LE_OP GE_OP 
shift_expression -> additive_expression 	0
OR_OP ? ; ) ] } : EQ_OP , < LEFT_OP RIGHT_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	0
OR_OP ? ; ) ] } : EQ_OP , < LEFT_OP RIGHT_OP 
additive_expression -> multiplicative_expression 	0
OR_OP ? ; ) } ] : , EQ_OP < + - 
additive_expression -> additive_expression - multiplicative_expression 	0
OR_OP ? ; ) } ] : , EQ_OP < + - 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
OR_OP ? ; ) ] } : EQ_OP , < * / % 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
OR_OP ? ; ) ] } : EQ_OP , < * / % 
cast_expression -> ( type_name ) cast_expression 	0
OR_OP ? ; ) } ] : , EQ_OP < * 

236 59
equality_expression -> equality_expression EQ_OP relational_expression 	0
NE_OP OR_OP ? ; EQ_OP , ) ] : 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
unary_expression -> INC_OP unary_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN OR_OP ? < , ] : * 
unary_expression -> postfix_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN OR_OP ? < , ] : * 
primary_expression -> IDENTIFIER 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
unary_expression -> DEC_OP unary_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN OR_OP ? < , ] : * 
relational_expression -> relational_expression LE_OP shift_expression 	0
? OR_OP ; < , EQ_OP ) ] : > LE_OP GE_OP 
unary_expression -> unary_operator cast_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN OR_OP ? < , ] : * 
expression -> expression , assignment_expression 	2
; , ) ] : 
and_expression -> equality_expression 	0
OR_OP ? ; , ) ] : & 
unary_expression -> SIZEOF ( type_name ) 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN OR_OP ? < , ] : * 
assignment_expression -> conditional_expression 	0
; , ) ] : 
assignment_expression -> unary_expression assignment_operator assignment_expression 	0
; , ) ] : 
postfix_expression -> postfix_expression . IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
conditional_expression -> logical_or_expression 	0
; , ) ] : 
conditional_expression -> logical_or_expression ? expression : conditional_expression 	0
; , ) ] : 
logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression 	0
? OR_OP ; , AND_OP ) ] : 
unary_expression -> SIZEOF unary_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN OR_OP ? < , ] : * 
logical_or_expression -> logical_or_expression OR_OP logical_and_expression 	0
OR_OP ? ; , ) ] : 
cast_expression -> unary_expression 	0
? OR_OP ; < , EQ_OP ) ] : * 
logical_or_expression -> logical_and_expression 	0
OR_OP ? ; , ) ] : 
postfix_expression -> primary_expression 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression ( ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression INC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
equality_expression -> equality_expression NE_OP relational_expression 	0
NE_OP OR_OP ? ; EQ_OP , ) ] : 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
additive_expression -> additive_expression + multiplicative_expression 	0
? OR_OP ; < , EQ_OP ) ] : + - 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
? OR_OP ; EQ_OP , < ) ] : * / % 
logical_and_expression -> inclusive_or_expression 	0
? OR_OP ; , AND_OP ) ] : 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
? OR_OP ; EQ_OP , < ) ] : LEFT_OP RIGHT_OP 
primary_expression -> CONSTANT 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
primary_expression -> ( expression ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
primary_expression -> STRING_LITERAL 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
inclusive_or_expression -> exclusive_or_expression 	0
OR_OP ? ; | , ) ] : 
and_expression -> and_expression & equality_expression 	0
OR_OP ? ; , ) ] : & 
inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression 	0
OR_OP ? ; | , ) ] : 
exclusive_or_expression -> and_expression 	0
? OR_OP ; , ) ] : ^ 
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	0
? OR_OP ; , ) ] : ^ 
equality_expression -> relational_expression 	0
NE_OP OR_OP ? ; EQ_OP , ) ] : 
multiplicative_expression -> cast_expression 	0
? OR_OP ; EQ_OP , < ) ] : * / % 
relational_expression -> shift_expression 	0
? OR_OP ; < , EQ_OP ) ] : > LE_OP GE_OP 
relational_expression -> relational_expression < shift_expression 	0
? OR_OP ; < , EQ_OP ) ] : > LE_OP GE_OP 
relational_expression -> relational_expression > shift_expression 	0
? OR_OP ; < , EQ_OP ) ] : > LE_OP GE_OP 
relational_expression -> relational_expression GE_OP shift_expression 	0
? OR_OP ; < , EQ_OP ) ] : > LE_OP GE_OP 
shift_expression -> additive_expression 	0
? OR_OP ; EQ_OP , < ) ] : LEFT_OP RIGHT_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	0
? OR_OP ; EQ_OP , < ) ] : LEFT_OP RIGHT_OP 
additive_expression -> multiplicative_expression 	0
? OR_OP ; < , EQ_OP ) ] : + - 
additive_expression -> additive_expression - multiplicative_expression 	0
? OR_OP ; < , EQ_OP ) ] : + - 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
? OR_OP ; EQ_OP , < ) ] : * / % 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
? OR_OP ; EQ_OP , < ) ] : * / % 
cast_expression -> ( type_name ) cast_expression 	0
? OR_OP ; < , EQ_OP ) ] : * 

237 1
expression_statement -> expression ; 	2
} BREAK - WHILE CONSTANT SIZEOF { ; ( INC_OP DEC_OP DEFAULT IDENTIFIER & STRING_LITERAL * ~ + ! CONTINUE ) FOR ELSE GOTO CASE RETURN DO IF SWITCH 

238 1
compound_statement -> { statement_list } 	3
FOR ELSE } DEFAULT INT IDENTIFIER WHILE DEC_OP LONG $ STATIC VOLATILE TYPE_NAME SIGNED SHORT FLOAT REGISTER STRUCT DO CONST UNION * CHAR IF UNSIGNED ( STRING_LITERAL TYPEDEF EXTERN AUTO DOUBLE RETURN VOID ENUM GOTO CASE { ; CONTINUE - BREAK SIZEOF INC_OP SWITCH CONSTANT & ~ + ! 

239 1
statement_list -> statement_list statement 	2
FOR } IDENTIFIER DEFAULT WHILE GOTO CASE ; { RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 

240 1
compound_statement -> { declaration_list } 	3
FOR ELSE } DEFAULT INT IDENTIFIER WHILE DEC_OP LONG $ STATIC VOLATILE TYPE_NAME SIGNED SHORT FLOAT REGISTER STRUCT DO CONST UNION * CHAR IF UNSIGNED ( STRING_LITERAL TYPEDEF EXTERN AUTO DOUBLE RETURN VOID ENUM GOTO CASE { ; CONTINUE - BREAK SIZEOF INC_OP SWITCH CONSTANT & ~ + ! 

241 89
logical_and_expression -> inclusive_or_expression 	0
? OR_OP ; AND_OP 
statement -> selection_statement 	0
FOR } IDENTIFIER DEFAULT WHILE GOTO CASE ; { RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
labeled_statement -> CASE constant_expression : statement 	0
} FOR GOTO WHILE IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
compound_statement -> { declaration_list statement_list } 	3
FOR ELSE } DEFAULT INT IDENTIFIER WHILE DEC_OP LONG $ STATIC VOLATILE TYPE_NAME SIGNED SHORT FLOAT REGISTER STRUCT DO CONST UNION * CHAR IF UNSIGNED ( STRING_LITERAL TYPEDEF EXTERN AUTO DOUBLE RETURN VOID ENUM GOTO CASE { ; CONTINUE - BREAK SIZEOF INC_OP SWITCH CONSTANT & ~ + ! 
unary_expression -> DEC_OP unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
primary_expression -> IDENTIFIER 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
compound_statement -> { declaration_list statement_list } 	0
} FOR GOTO WHILE IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
statement_list -> statement_list statement 	1
} FOR GOTO WHILE IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
statement -> labeled_statement 	0
FOR } IDENTIFIER DEFAULT WHILE GOTO CASE ; { RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
statement -> iteration_statement 	0
FOR } IDENTIFIER DEFAULT WHILE GOTO CASE ; { RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
additive_expression -> additive_expression + multiplicative_expression 	0
OR_OP ? + ; < EQ_OP - 
statement -> compound_statement 	0
FOR } IDENTIFIER DEFAULT WHILE GOTO CASE ; { RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
statement -> jump_statement 	0
FOR } IDENTIFIER DEFAULT WHILE GOTO CASE ; { RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
statement -> expression_statement 	0
FOR } IDENTIFIER DEFAULT WHILE GOTO CASE ; { RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
iteration_statement -> DO statement WHILE ( expression ) ; 	0
} FOR GOTO WHILE IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
iteration_statement -> FOR ( expression_statement expression_statement ) statement 	0
} FOR GOTO WHILE IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
iteration_statement -> WHILE ( expression ) statement 	0
} FOR GOTO WHILE IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
iteration_statement -> FOR ( expression_statement expression_statement expression ) statement 	0
} FOR GOTO WHILE IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
compound_statement -> { declaration_list } 	0
} FOR GOTO WHILE IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
primary_expression -> CONSTANT 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
compound_statement -> { statement_list } 	0
} FOR GOTO WHILE IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
labeled_statement -> DEFAULT : statement 	0
} FOR GOTO WHILE IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
compound_statement -> { } 	0
} FOR GOTO WHILE IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
postfix_expression -> primary_expression 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
jump_statement -> GOTO IDENTIFIER ; 	0
} FOR GOTO WHILE IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
postfix_expression -> postfix_expression ( ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
labeled_statement -> IDENTIFIER : statement 	0
} FOR GOTO WHILE IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
jump_statement -> RETURN ; 	0
} FOR GOTO WHILE IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	0
? OR_OP ; ^ 
jump_statement -> CONTINUE ; 	0
} FOR GOTO WHILE IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
jump_statement -> BREAK ; 	0
} FOR GOTO WHILE IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
jump_statement -> RETURN expression ; 	0
} FOR GOTO WHILE IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression 	0
OR_OP ? ; | 
and_expression -> and_expression & equality_expression 	0
OR_OP ? ; & 
expression_statement -> expression ; 	0
} FOR GOTO WHILE IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
expression_statement -> ; 	0
} FOR GOTO WHILE IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
selection_statement -> IF ( expression ) statement ELSE statement 	0
} FOR GOTO WHILE IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
selection_statement -> IF ( expression ) statement 	0
} FOR GOTO WHILE IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
selection_statement -> SWITCH ( expression ) statement 	0
} FOR GOTO WHILE IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
primary_expression -> ( expression ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
expression -> assignment_expression 	0
; , 
primary_expression -> STRING_LITERAL 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
expression -> expression , assignment_expression 	0
; , 
assignment_expression -> conditional_expression 	0
; 
assignment_expression -> unary_expression assignment_operator assignment_expression 	0
; 
conditional_expression -> logical_or_expression ? expression : conditional_expression 	0
; 
postfix_expression -> postfix_expression . IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
conditional_expression -> logical_or_expression 	0
; 
unary_expression -> SIZEOF ( type_name ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
unary_expression -> postfix_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
unary_expression -> INC_OP unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
unary_expression -> unary_operator cast_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression 	0
? OR_OP ; AND_OP 
unary_expression -> SIZEOF unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
logical_or_expression -> logical_or_expression OR_OP logical_and_expression 	0
OR_OP ? ; 
logical_or_expression -> logical_and_expression 	0
OR_OP ? ; 
postfix_expression -> postfix_expression INC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
inclusive_or_expression -> exclusive_or_expression 	0
OR_OP ? ; | 
exclusive_or_expression -> and_expression 	0
? OR_OP ; ^ 
and_expression -> equality_expression 	0
OR_OP ? ; & 
equality_expression -> equality_expression EQ_OP relational_expression 	0
NE_OP ? OR_OP ; EQ_OP 
equality_expression -> relational_expression 	0
NE_OP ? OR_OP ; EQ_OP 
equality_expression -> equality_expression NE_OP relational_expression 	0
NE_OP ? OR_OP ; EQ_OP 
relational_expression -> shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression < shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression > shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression LE_OP shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression GE_OP shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
shift_expression -> additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP < RIGHT_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP < RIGHT_OP 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP < RIGHT_OP 
additive_expression -> multiplicative_expression 	0
OR_OP ? + ; < EQ_OP - 
additive_expression -> additive_expression - multiplicative_expression 	0
OR_OP ? + ; < EQ_OP - 
multiplicative_expression -> cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
cast_expression -> ( type_name ) cast_expression 	0
OR_OP ? ; < EQ_OP * 
cast_expression -> unary_expression 	0
OR_OP ? ; < EQ_OP * 

242 1
enum_specifier -> ENUM IDENTIFIER { enumerator_list } 	5
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; : [ ) , 

243 1
enumerator -> IDENTIFIER = constant_expression 	3
} , 

244 1
enumerator_list -> enumerator_list , enumerator 	3
} , 

245 1
struct_or_union_specifier -> struct_or_union IDENTIFIER { struct_declaration_list } 	5
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; : [ ) , 

246 1
struct_declarator -> : constant_expression 	2
; , 

247 17
struct_declarator_list -> struct_declarator_list , struct_declarator 	2
; , 
struct_declarator -> : constant_expression 	0
; , 
struct_declarator -> declarator 	0
; , 
declarator -> pointer direct_declarator 	0
; , : 
struct_declarator -> declarator : constant_expression 	0
; , 
declarator -> direct_declarator 	0
; , : 
pointer -> * type_qualifier_list 	0
IDENTIFIER ( 
direct_declarator -> direct_declarator ( ) 	0
[ ; , : ( 
pointer -> * 	0
IDENTIFIER ( 
pointer -> * pointer 	0
IDENTIFIER ( 
pointer -> * type_qualifier_list pointer 	0
IDENTIFIER ( 
direct_declarator -> ( declarator ) 	0
[ ; , : ( 
direct_declarator -> IDENTIFIER 	0
[ ; , : ( 
direct_declarator -> direct_declarator ( parameter_type_list ) 	0
[ ; , : ( 
direct_declarator -> direct_declarator [ ] 	0
[ ; , : ( 
direct_declarator -> direct_declarator [ constant_expression ] 	0
[ ; , : ( 
direct_declarator -> direct_declarator ( identifier_list ) 	0
[ ; , : ( 

248 1
struct_declaration -> specifier_qualifier_list struct_declarator_list ; 	3
DOUBLE } FLOAT CHAR SIGNED TYPE_NAME SHORT VOID INT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 

249 58
multiplicative_expression -> multiplicative_expression / cast_expression 	0
/ OR_OP ? ; EQ_OP , < * % 
logical_and_expression -> inclusive_or_expression 	0
? OR_OP ; , AND_OP 
logical_or_expression -> logical_or_expression OR_OP logical_and_expression 	0
OR_OP ? ; , 
relational_expression -> relational_expression GE_OP shift_expression 	0
? OR_OP ; < , EQ_OP > LE_OP GE_OP 
struct_declarator -> declarator : constant_expression 	2
; , 
constant_expression -> conditional_expression 	0
; , 
postfix_expression -> postfix_expression . IDENTIFIER 	0
? OR_OP ; < , EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
conditional_expression -> logical_or_expression 	0
; , 
conditional_expression -> logical_or_expression ? expression : conditional_expression 	0
; , 
cast_expression -> unary_expression 	0
OR_OP ? ; < , EQ_OP * 
logical_or_expression -> logical_and_expression 	0
OR_OP ? ; , 
unary_expression -> SIZEOF unary_expression 	0
? OR_OP ; EQ_OP , < * 
logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression 	0
? OR_OP ; , AND_OP 
inclusive_or_expression -> exclusive_or_expression 	0
OR_OP ? ; | , 
and_expression -> and_expression & equality_expression 	0
OR_OP ? ; , & 
inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression 	0
OR_OP ? ; | , 
exclusive_or_expression -> and_expression 	0
? OR_OP ; , ^ 
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	0
? OR_OP ; , ^ 
unary_expression -> SIZEOF ( type_name ) 	0
? OR_OP ; EQ_OP , < * 
and_expression -> equality_expression 	0
OR_OP ? ; , & 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
? OR_OP ; < , EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
unary_expression -> INC_OP unary_expression 	0
? OR_OP ; EQ_OP , < * 
equality_expression -> equality_expression EQ_OP relational_expression 	0
NE_OP ? OR_OP ; EQ_OP , 
equality_expression -> relational_expression 	0
NE_OP ? OR_OP ; EQ_OP , 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
equality_expression -> equality_expression NE_OP relational_expression 	0
NE_OP ? OR_OP ; EQ_OP , 
multiplicative_expression -> cast_expression 	0
/ OR_OP ? ; EQ_OP , < * % 
relational_expression -> shift_expression 	0
? OR_OP ; < , EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression < shift_expression 	0
? OR_OP ; < , EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression > shift_expression 	0
? OR_OP ; < , EQ_OP > LE_OP GE_OP 
unary_expression -> unary_operator cast_expression 	0
? OR_OP ; EQ_OP , < * 
relational_expression -> relational_expression LE_OP shift_expression 	0
? OR_OP ; < , EQ_OP > LE_OP GE_OP 
shift_expression -> additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP , < RIGHT_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP , < RIGHT_OP 
primary_expression -> CONSTANT 	0
? OR_OP ; EQ_OP , < * . ( 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP , < RIGHT_OP 
additive_expression -> multiplicative_expression 	0
OR_OP ? + ; < , EQ_OP - 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
additive_expression -> additive_expression + multiplicative_expression 	0
OR_OP ? + ; < , EQ_OP - 
additive_expression -> additive_expression - multiplicative_expression 	0
OR_OP ? + ; < , EQ_OP - 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
/ OR_OP ? ; EQ_OP , < * % 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
/ OR_OP ? ; EQ_OP , < * % 
cast_expression -> ( type_name ) cast_expression 	0
OR_OP ? ; < , EQ_OP * 
primary_expression -> IDENTIFIER 	0
? OR_OP ; EQ_OP , < * . ( 
unary_expression -> DEC_OP unary_expression 	0
? OR_OP ; EQ_OP , < * 
unary_expression -> postfix_expression 	0
? OR_OP ; EQ_OP , < * 
postfix_expression -> primary_expression 	0
? OR_OP ; < , EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression ( ) 	0
? OR_OP ; < , EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression INC_OP 	0
? OR_OP ; < , EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
? OR_OP ; < , EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
? OR_OP ; < , EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
? OR_OP ; < , EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
primary_expression -> ( expression ) 	0
? OR_OP ; EQ_OP , < * . ( 
primary_expression -> STRING_LITERAL 	0
? OR_OP ; EQ_OP , < * . ( 

250 1
direct_abstract_declarator -> ( ) 	2
( [ ) , 

251 1
direct_abstract_declarator -> ( parameter_type_list ) 	2
( [ ) , 

252 1
direct_abstract_declarator -> ( abstract_declarator ) 	2
( [ ) , 

253 1
direct_abstract_declarator -> [ ] 	2
( [ ) , 

254 1
direct_abstract_declarator -> [ constant_expression ] 	2
( [ ) , 

255 42
parameter_type_list -> parameter_list , ELLIPSIS 	0
) 
enum_specifier -> ENUM IDENTIFIER 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( [ ) , 
direct_abstract_declarator -> direct_abstract_declarator ( parameter_type_list ) 	2
( [ ) , 
direct_abstract_declarator -> direct_abstract_declarator ( ) 	2
( [ ) , 
declaration_specifiers -> storage_class_specifier declaration_specifiers 	0
IDENTIFIER * ( [ ) , 
parameter_type_list -> parameter_list 	0
) 
parameter_list -> parameter_declaration 	0
) , 
enum_specifier -> ENUM { enumerator_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( [ ) , 
storage_class_specifier -> TYPEDEF 	0
INT IDENTIFIER SIGNED TYPE_NAME SHORT CHAR * ( [ ) , STRUCT REGISTER VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
parameter_declaration -> declaration_specifiers abstract_declarator 	0
) , 
parameter_list -> parameter_list , parameter_declaration 	0
) , 
type_specifier -> LONG 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
type_specifier -> VOID 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
parameter_declaration -> declaration_specifiers declarator 	0
) , 
parameter_declaration -> declaration_specifiers 	0
) , 
declaration_specifiers -> type_specifier declaration_specifiers 	0
IDENTIFIER * ( [ ) , 
declaration_specifiers -> type_specifier 	0
IDENTIFIER * ( [ ) , 
type_specifier -> struct_or_union_specifier 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
declaration_specifiers -> storage_class_specifier 	0
IDENTIFIER * ( [ ) , 
type_specifier -> SIGNED 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
declaration_specifiers -> type_qualifier 	0
IDENTIFIER * ( [ ) , 
declaration_specifiers -> type_qualifier declaration_specifiers 	0
IDENTIFIER * ( [ ) , 
type_specifier -> CHAR 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
storage_class_specifier -> STATIC 	0
INT IDENTIFIER SIGNED TYPE_NAME SHORT CHAR * ( [ ) , STRUCT REGISTER VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
type_specifier -> FLOAT 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
type_specifier -> TYPE_NAME 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
storage_class_specifier -> EXTERN 	0
INT IDENTIFIER SIGNED TYPE_NAME SHORT CHAR * ( [ ) , STRUCT REGISTER VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
type_specifier -> SHORT 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
type_specifier -> INT 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
type_specifier -> DOUBLE 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
type_specifier -> UNSIGNED 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
type_specifier -> enum_specifier 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
type_qualifier -> CONST 	0
INT IDENTIFIER SIGNED TYPE_NAME SHORT CHAR * ( [ ) , STRUCT REGISTER VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
storage_class_specifier -> AUTO 	0
INT IDENTIFIER SIGNED TYPE_NAME SHORT CHAR * ( [ ) , STRUCT REGISTER VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
storage_class_specifier -> REGISTER 	0
INT IDENTIFIER SIGNED TYPE_NAME SHORT CHAR * ( [ ) , STRUCT REGISTER VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
type_qualifier -> VOLATILE 	0
INT IDENTIFIER SIGNED TYPE_NAME SHORT CHAR * ( [ ) , STRUCT REGISTER VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
struct_or_union_specifier -> struct_or_union { struct_declaration_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( [ ) , 
enum_specifier -> ENUM IDENTIFIER { enumerator_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( [ ) , 
struct_or_union_specifier -> struct_or_union IDENTIFIER { struct_declaration_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( [ ) , 
struct_or_union_specifier -> struct_or_union IDENTIFIER 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( [ ) , 
struct_or_union -> STRUCT 	0
{ IDENTIFIER 
struct_or_union -> UNION 	0
{ IDENTIFIER 

256 59
postfix_expression -> postfix_expression . IDENTIFIER 	0
? OR_OP ] < EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
direct_abstract_declarator -> direct_abstract_declarator [ constant_expression ] 	2
( [ ) , 
conditional_expression -> logical_or_expression 	0
] 
conditional_expression -> logical_or_expression ? expression : conditional_expression 	0
] 
cast_expression -> unary_expression 	0
OR_OP ? ] < EQ_OP * 
logical_or_expression -> logical_and_expression 	0
OR_OP ? ] 
unary_expression -> postfix_expression 	0
? OR_OP ] EQ_OP < * 
direct_abstract_declarator -> direct_abstract_declarator [ ] 	2
( [ ) , 
constant_expression -> conditional_expression 	0
] 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
/ ? OR_OP % ] EQ_OP < * 
logical_and_expression -> inclusive_or_expression 	0
? OR_OP ] AND_OP 
logical_or_expression -> logical_or_expression OR_OP logical_and_expression 	0
OR_OP ? ] 
unary_expression -> SIZEOF unary_expression 	0
? OR_OP ] EQ_OP < * 
logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression 	0
? OR_OP ] AND_OP 
inclusive_or_expression -> exclusive_or_expression 	0
OR_OP ? ] | 
and_expression -> and_expression & equality_expression 	0
OR_OP ? ] & 
inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression 	0
OR_OP ? ] | 
exclusive_or_expression -> and_expression 	0
? OR_OP ] ^ 
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	0
? OR_OP ] ^ 
unary_expression -> SIZEOF ( type_name ) 	0
? OR_OP ] EQ_OP < * 
and_expression -> equality_expression 	0
OR_OP ? ] & 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
? OR_OP ] < EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
unary_expression -> INC_OP unary_expression 	0
? OR_OP ] EQ_OP < * 
equality_expression -> equality_expression EQ_OP relational_expression 	0
NE_OP ? OR_OP ] EQ_OP 
equality_expression -> relational_expression 	0
NE_OP ? OR_OP ] EQ_OP 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
equality_expression -> equality_expression NE_OP relational_expression 	0
NE_OP ? OR_OP ] EQ_OP 
multiplicative_expression -> cast_expression 	0
/ ? OR_OP % ] EQ_OP < * 
relational_expression -> shift_expression 	0
OR_OP ? LE_OP ] < EQ_OP > GE_OP 
relational_expression -> relational_expression < shift_expression 	0
OR_OP ? LE_OP ] < EQ_OP > GE_OP 
relational_expression -> relational_expression > shift_expression 	0
OR_OP ? LE_OP ] < EQ_OP > GE_OP 
unary_expression -> unary_operator cast_expression 	0
? OR_OP ] EQ_OP < * 
relational_expression -> relational_expression LE_OP shift_expression 	0
OR_OP ? LE_OP ] < EQ_OP > GE_OP 
relational_expression -> relational_expression GE_OP shift_expression 	0
OR_OP ? LE_OP ] < EQ_OP > GE_OP 
shift_expression -> additive_expression 	0
? OR_OP ] EQ_OP < LEFT_OP RIGHT_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	0
? OR_OP ] EQ_OP < LEFT_OP RIGHT_OP 
primary_expression -> CONSTANT 	0
? OR_OP ] EQ_OP < * . ( 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
? OR_OP ] EQ_OP < LEFT_OP RIGHT_OP 
additive_expression -> multiplicative_expression 	0
OR_OP ? - ] < EQ_OP + 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
additive_expression -> additive_expression + multiplicative_expression 	0
OR_OP ? - ] < EQ_OP + 
additive_expression -> additive_expression - multiplicative_expression 	0
OR_OP ? - ] < EQ_OP + 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
/ ? OR_OP % ] EQ_OP < * 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
/ ? OR_OP % ] EQ_OP < * 
cast_expression -> ( type_name ) cast_expression 	0
OR_OP ? ] < EQ_OP * 
primary_expression -> IDENTIFIER 	0
? OR_OP ] EQ_OP < * . ( 
unary_expression -> DEC_OP unary_expression 	0
? OR_OP ] EQ_OP < * 
postfix_expression -> primary_expression 	0
? OR_OP ] < EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression ( ) 	0
? OR_OP ] < EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression INC_OP 	0
? OR_OP ] < EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
? OR_OP ] < EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
? OR_OP ] < EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
? OR_OP ] < EQ_OP * . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
primary_expression -> ( expression ) 	0
? OR_OP ] EQ_OP < * . ( 
primary_expression -> STRING_LITERAL 	0
? OR_OP ] EQ_OP < * . ( 

257 5
abstract_declarator -> pointer direct_abstract_declarator 	2
) , 
direct_abstract_declarator -> direct_abstract_declarator [ ] 	1
( [ ) , 
direct_abstract_declarator -> direct_abstract_declarator [ constant_expression ] 	1
( [ ) , 
direct_abstract_declarator -> direct_abstract_declarator ( parameter_type_list ) 	1
( [ ) , 
direct_abstract_declarator -> direct_abstract_declarator ( ) 	1
( [ ) , 

258 1
identifier_list -> identifier_list , IDENTIFIER 	3
) , 

259 1
parameter_type_list -> parameter_list , ELLIPSIS 	3
) 

260 1
parameter_list -> parameter_list , parameter_declaration 	3
) , 

261 1
primary_expression -> ( expression ) 	3
? OR_OP ] | < MUL_ASSIGN EQ_OP * . ( DIV_ASSIGN LEFT_ASSIGN ) GE_OP MOD_ASSIGN ADD_ASSIGN = } RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 

262 27
cast_expression -> ( type_name ) cast_expression 	3
OR_OP ? ] MUL_ASSIGN EQ_OP | < : * XOR_ASSIGN ; LEFT_ASSIGN ) = ADD_ASSIGN } , GE_OP MOD_ASSIGN DIV_ASSIGN RIGHT_ASSIGN SUB_ASSIGN AND_ASSIGN OR_ASSIGN / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
cast_expression -> ( type_name ) cast_expression 	0
OR_OP ? ] | < MUL_ASSIGN EQ_OP * : ; XOR_ASSIGN ) LEFT_ASSIGN } ADD_ASSIGN = , MOD_ASSIGN GE_OP DIV_ASSIGN RIGHT_ASSIGN SUB_ASSIGN AND_ASSIGN OR_ASSIGN / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
unary_expression -> unary_operator cast_expression 	0
OR_OP ? ] MUL_ASSIGN EQ_OP | < : * XOR_ASSIGN ; LEFT_ASSIGN ) = ADD_ASSIGN } , GE_OP MOD_ASSIGN DIV_ASSIGN RIGHT_ASSIGN SUB_ASSIGN AND_ASSIGN OR_ASSIGN / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
OR_OP ? ] | < MUL_ASSIGN EQ_OP * : ; XOR_ASSIGN ) LEFT_ASSIGN } ADD_ASSIGN = , MOD_ASSIGN GE_OP DIV_ASSIGN RIGHT_ASSIGN SUB_ASSIGN AND_ASSIGN OR_ASSIGN / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
unary_expression -> INC_OP unary_expression 	0
OR_OP ? ] MUL_ASSIGN EQ_OP | < : * XOR_ASSIGN ; LEFT_ASSIGN ) = ADD_ASSIGN } , GE_OP MOD_ASSIGN DIV_ASSIGN RIGHT_ASSIGN SUB_ASSIGN AND_ASSIGN OR_ASSIGN / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
unary_expression -> postfix_expression 	0
OR_OP ? ] MUL_ASSIGN EQ_OP | < : * XOR_ASSIGN ; LEFT_ASSIGN ) = ADD_ASSIGN } , GE_OP MOD_ASSIGN DIV_ASSIGN RIGHT_ASSIGN SUB_ASSIGN AND_ASSIGN OR_ASSIGN / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
primary_expression -> IDENTIFIER 	0
OR_OP ? ] MUL_ASSIGN EQ_OP | < : * XOR_ASSIGN ; LEFT_ASSIGN ) = ADD_ASSIGN } , GE_OP MOD_ASSIGN DIV_ASSIGN RIGHT_ASSIGN SUB_ASSIGN AND_ASSIGN OR_ASSIGN / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( 
unary_expression -> DEC_OP unary_expression 	0
OR_OP ? ] MUL_ASSIGN EQ_OP | < : * XOR_ASSIGN ; LEFT_ASSIGN ) = ADD_ASSIGN } , GE_OP MOD_ASSIGN DIV_ASSIGN RIGHT_ASSIGN SUB_ASSIGN AND_ASSIGN OR_ASSIGN / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
cast_expression -> unary_expression 	0
OR_OP ? ] | < MUL_ASSIGN EQ_OP * : ; XOR_ASSIGN ) LEFT_ASSIGN } ADD_ASSIGN = , MOD_ASSIGN GE_OP DIV_ASSIGN RIGHT_ASSIGN SUB_ASSIGN AND_ASSIGN OR_ASSIGN / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
unary_expression -> SIZEOF ( type_name ) 	0
OR_OP ? ] MUL_ASSIGN EQ_OP | < : * XOR_ASSIGN ; LEFT_ASSIGN ) = ADD_ASSIGN } , GE_OP MOD_ASSIGN DIV_ASSIGN RIGHT_ASSIGN SUB_ASSIGN AND_ASSIGN OR_ASSIGN / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
unary_expression -> SIZEOF unary_expression 	0
OR_OP ? ] MUL_ASSIGN EQ_OP | < : * XOR_ASSIGN ; LEFT_ASSIGN ) = ADD_ASSIGN } , GE_OP MOD_ASSIGN DIV_ASSIGN RIGHT_ASSIGN SUB_ASSIGN AND_ASSIGN OR_ASSIGN / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
postfix_expression -> postfix_expression . IDENTIFIER 	0
OR_OP ? ] | < MUL_ASSIGN EQ_OP * : ; XOR_ASSIGN ) LEFT_ASSIGN } ADD_ASSIGN = , MOD_ASSIGN GE_OP DIV_ASSIGN RIGHT_ASSIGN SUB_ASSIGN AND_ASSIGN OR_ASSIGN / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> primary_expression 	0
OR_OP ? ] | < MUL_ASSIGN EQ_OP * : ; XOR_ASSIGN ) LEFT_ASSIGN } ADD_ASSIGN = , MOD_ASSIGN GE_OP DIV_ASSIGN RIGHT_ASSIGN SUB_ASSIGN AND_ASSIGN OR_ASSIGN / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression ( ) 	0
OR_OP ? ] | < MUL_ASSIGN EQ_OP * : ; XOR_ASSIGN ) LEFT_ASSIGN } ADD_ASSIGN = , MOD_ASSIGN GE_OP DIV_ASSIGN RIGHT_ASSIGN SUB_ASSIGN AND_ASSIGN OR_ASSIGN / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression INC_OP 	0
OR_OP ? ] | < MUL_ASSIGN EQ_OP * : ; XOR_ASSIGN ) LEFT_ASSIGN } ADD_ASSIGN = , MOD_ASSIGN GE_OP DIV_ASSIGN RIGHT_ASSIGN SUB_ASSIGN AND_ASSIGN OR_ASSIGN / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
OR_OP ? ] | < MUL_ASSIGN EQ_OP * : ; XOR_ASSIGN ) LEFT_ASSIGN } ADD_ASSIGN = , MOD_ASSIGN GE_OP DIV_ASSIGN RIGHT_ASSIGN SUB_ASSIGN AND_ASSIGN OR_ASSIGN / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
OR_OP ? ] | < MUL_ASSIGN EQ_OP * : ; XOR_ASSIGN ) LEFT_ASSIGN } ADD_ASSIGN = , MOD_ASSIGN GE_OP DIV_ASSIGN RIGHT_ASSIGN SUB_ASSIGN AND_ASSIGN OR_ASSIGN / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
OR_OP ? ] | < MUL_ASSIGN EQ_OP * : ; XOR_ASSIGN ) LEFT_ASSIGN } ADD_ASSIGN = , MOD_ASSIGN GE_OP DIV_ASSIGN RIGHT_ASSIGN SUB_ASSIGN AND_ASSIGN OR_ASSIGN / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
primary_expression -> CONSTANT 	0
OR_OP ? ] MUL_ASSIGN EQ_OP | < : * XOR_ASSIGN ; LEFT_ASSIGN ) = ADD_ASSIGN } , GE_OP MOD_ASSIGN DIV_ASSIGN RIGHT_ASSIGN SUB_ASSIGN AND_ASSIGN OR_ASSIGN / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( 
primary_expression -> ( expression ) 	0
OR_OP ? ] MUL_ASSIGN EQ_OP | < : * XOR_ASSIGN ; LEFT_ASSIGN ) = ADD_ASSIGN } , GE_OP MOD_ASSIGN DIV_ASSIGN RIGHT_ASSIGN SUB_ASSIGN AND_ASSIGN OR_ASSIGN / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( 
primary_expression -> STRING_LITERAL 	0
OR_OP ? ] MUL_ASSIGN EQ_OP | < : * XOR_ASSIGN ; LEFT_ASSIGN ) = ADD_ASSIGN } , GE_OP MOD_ASSIGN DIV_ASSIGN RIGHT_ASSIGN SUB_ASSIGN AND_ASSIGN OR_ASSIGN / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP . ( 

263 59
abstract_declarator -> direct_abstract_declarator 	0
) 
parameter_type_list -> parameter_list , ELLIPSIS 	0
) 
enum_specifier -> ENUM IDENTIFIER 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( [ ) , 
direct_abstract_declarator -> ( ) 	1
( [ ) 
declaration_specifiers -> storage_class_specifier declaration_specifiers 	0
IDENTIFIER * ( [ ) , 
parameter_type_list -> parameter_list 	0
) 
type_specifier -> struct_or_union_specifier 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
declaration_specifiers -> storage_class_specifier 	0
IDENTIFIER * ( [ ) , 
direct_abstract_declarator -> ( parameter_type_list ) 	1
( [ ) 
direct_abstract_declarator -> ( abstract_declarator ) 	1
( [ ) 
parameter_list -> parameter_declaration 	0
) , 
abstract_declarator -> pointer direct_abstract_declarator 	0
) 
abstract_declarator -> pointer 	0
) 
parameter_list -> parameter_list , parameter_declaration 	0
) , 
direct_abstract_declarator -> direct_abstract_declarator [ constant_expression ] 	0
) ( [ 
pointer -> * 	0
( [ ) 
pointer -> * type_qualifier_list 	0
( [ ) 
pointer -> * pointer 	0
( [ ) 
direct_abstract_declarator -> ( parameter_type_list ) 	0
) ( [ 
pointer -> * type_qualifier_list pointer 	0
( [ ) 
parameter_declaration -> declaration_specifiers 	0
) , 
direct_abstract_declarator -> direct_abstract_declarator ( parameter_type_list ) 	0
) ( [ 
direct_abstract_declarator -> [ ] 	0
) ( [ 
direct_abstract_declarator -> ( ) 	0
) ( [ 
type_qualifier -> VOLATILE 	0
INT IDENTIFIER SIGNED TYPE_NAME SHORT CHAR * ( [ ) , STRUCT REGISTER VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
direct_abstract_declarator -> [ constant_expression ] 	0
) ( [ 
type_specifier -> CHAR 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
direct_abstract_declarator -> direct_abstract_declarator ( ) 	0
) ( [ 
direct_abstract_declarator -> ( abstract_declarator ) 	0
) ( [ 
enum_specifier -> ENUM { enumerator_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( [ ) , 
storage_class_specifier -> TYPEDEF 	0
INT IDENTIFIER SIGNED TYPE_NAME SHORT CHAR * ( [ ) , STRUCT REGISTER VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
parameter_declaration -> declaration_specifiers abstract_declarator 	0
) , 
direct_abstract_declarator -> direct_abstract_declarator [ ] 	0
) ( [ 
type_specifier -> LONG 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
type_specifier -> VOID 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
parameter_declaration -> declaration_specifiers declarator 	0
) , 
declaration_specifiers -> type_specifier declaration_specifiers 	0
IDENTIFIER * ( [ ) , 
declaration_specifiers -> type_specifier 	0
IDENTIFIER * ( [ ) , 
type_specifier -> SIGNED 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
declaration_specifiers -> type_qualifier 	0
IDENTIFIER * ( [ ) , 
declaration_specifiers -> type_qualifier declaration_specifiers 	0
IDENTIFIER * ( [ ) , 
storage_class_specifier -> STATIC 	0
INT IDENTIFIER SIGNED TYPE_NAME SHORT CHAR * ( [ ) , STRUCT REGISTER VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
type_specifier -> FLOAT 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
type_specifier -> TYPE_NAME 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
storage_class_specifier -> EXTERN 	0
INT IDENTIFIER SIGNED TYPE_NAME SHORT CHAR * ( [ ) , STRUCT REGISTER VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
type_specifier -> SHORT 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
type_specifier -> INT 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
type_specifier -> DOUBLE 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
type_specifier -> UNSIGNED 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
type_specifier -> enum_specifier 	0
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( [ ) , 
type_qualifier -> CONST 	0
INT IDENTIFIER SIGNED TYPE_NAME SHORT CHAR * ( [ ) , STRUCT REGISTER VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
storage_class_specifier -> AUTO 	0
INT IDENTIFIER SIGNED TYPE_NAME SHORT CHAR * ( [ ) , STRUCT REGISTER VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
storage_class_specifier -> REGISTER 	0
INT IDENTIFIER SIGNED TYPE_NAME SHORT CHAR * ( [ ) , STRUCT REGISTER VOLATILE STATIC UNION CONST TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM 
struct_or_union_specifier -> struct_or_union { struct_declaration_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( [ ) , 
enum_specifier -> ENUM IDENTIFIER { enumerator_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( [ ) , 
struct_or_union_specifier -> struct_or_union IDENTIFIER { struct_declaration_list } 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( [ ) , 
struct_or_union_specifier -> struct_or_union IDENTIFIER 	0
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( [ ) , 
struct_or_union -> STRUCT 	0
{ IDENTIFIER 
struct_or_union -> UNION 	0
{ IDENTIFIER 

264 11
abstract_declarator -> pointer direct_abstract_declarator 	1
) 
abstract_declarator -> pointer 	1
) 
direct_abstract_declarator -> [ ] 	0
) ( [ 
direct_abstract_declarator -> direct_abstract_declarator ( parameter_type_list ) 	0
) ( [ 
direct_abstract_declarator -> ( ) 	0
) ( [ 
direct_abstract_declarator -> [ constant_expression ] 	0
) ( [ 
direct_abstract_declarator -> ( abstract_declarator ) 	0
) ( [ 
direct_abstract_declarator -> direct_abstract_declarator ( ) 	0
) ( [ 
direct_abstract_declarator -> direct_abstract_declarator [ constant_expression ] 	0
) ( [ 
direct_abstract_declarator -> direct_abstract_declarator [ ] 	0
) ( [ 
direct_abstract_declarator -> ( parameter_type_list ) 	0
) ( [ 

265 1
type_name -> specifier_qualifier_list abstract_declarator 	2
) 

266 1
unary_expression -> SIZEOF ( type_name ) 	3
? OR_OP ] | < MUL_ASSIGN EQ_OP GE_OP MOD_ASSIGN * ) LEFT_ASSIGN DIV_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 

267 1
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	3
? OR_OP ] MUL_ASSIGN EQ_OP | < * . ( [ PTR_OP INC_OP DEC_OP ) LEFT_ASSIGN DIV_ASSIGN GE_OP MOD_ASSIGN } ADD_ASSIGN = SUB_ASSIGN RIGHT_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 

268 1
postfix_expression -> postfix_expression ( ) 	3
? OR_OP ] MUL_ASSIGN EQ_OP | < * . ( [ PTR_OP INC_OP DEC_OP ) LEFT_ASSIGN DIV_ASSIGN GE_OP MOD_ASSIGN } ADD_ASSIGN = SUB_ASSIGN RIGHT_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 

269 1
argument_expression_list -> assignment_expression 	1
) , 

270 2
postfix_expression -> postfix_expression ( argument_expression_list ) 	3
? OR_OP ] MUL_ASSIGN EQ_OP | < * . ( [ PTR_OP INC_OP DEC_OP ) LEFT_ASSIGN DIV_ASSIGN GE_OP MOD_ASSIGN } ADD_ASSIGN = SUB_ASSIGN RIGHT_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
argument_expression_list -> argument_expression_list , assignment_expression 	1
) , 

271 2
expression -> expression , assignment_expression 	1
] , 
postfix_expression -> postfix_expression [ expression ] 	3
? OR_OP ] MUL_ASSIGN EQ_OP | < * . ( [ PTR_OP INC_OP DEC_OP ) LEFT_ASSIGN DIV_ASSIGN GE_OP MOD_ASSIGN } ADD_ASSIGN = SUB_ASSIGN RIGHT_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 

272 1
postfix_expression -> postfix_expression . IDENTIFIER 	3
? OR_OP ] MUL_ASSIGN EQ_OP | < * . ( [ PTR_OP INC_OP DEC_OP ) LEFT_ASSIGN DIV_ASSIGN GE_OP MOD_ASSIGN } ADD_ASSIGN = SUB_ASSIGN RIGHT_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 

273 1
multiplicative_expression -> multiplicative_expression * cast_expression 	3
? OR_OP / ] % | < EQ_OP * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 

274 1
multiplicative_expression -> multiplicative_expression / cast_expression 	3
? OR_OP / ] % | < EQ_OP * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 

275 1
multiplicative_expression -> multiplicative_expression % cast_expression 	3
? OR_OP / ] % | < EQ_OP * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 

276 4
additive_expression -> additive_expression + multiplicative_expression 	3
OR_OP ? ] - EQ_OP | < ; + ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 
multiplicative_expression -> multiplicative_expression * cast_expression 	1
* OR_OP ? / ] - % EQ_OP | < + ; ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 
multiplicative_expression -> multiplicative_expression / cast_expression 	1
* OR_OP ? / ] - % EQ_OP | < + ; ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 
multiplicative_expression -> multiplicative_expression % cast_expression 	1
* OR_OP ? / ] - % EQ_OP | < + ; ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 

277 4
additive_expression -> additive_expression - multiplicative_expression 	3
OR_OP ? ] - EQ_OP | < ; + ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 
multiplicative_expression -> multiplicative_expression * cast_expression 	1
* OR_OP ? / ] - % EQ_OP | < + ; ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 
multiplicative_expression -> multiplicative_expression / cast_expression 	1
* OR_OP ? / ] - % EQ_OP | < + ; ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 
multiplicative_expression -> multiplicative_expression % cast_expression 	1
* OR_OP ? / ] - % EQ_OP | < + ; ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 

278 3
additive_expression -> additive_expression - multiplicative_expression 	1
; LEFT_OP + ] - ? OR_OP | < EQ_OP RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	3
? OR_OP ] | < EQ_OP ; LEFT_OP RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP 
additive_expression -> additive_expression + multiplicative_expression 	1
; LEFT_OP + ] - ? OR_OP | < EQ_OP RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP 

279 3
shift_expression -> shift_expression RIGHT_OP additive_expression 	3
? OR_OP ] | < EQ_OP ; LEFT_OP RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP 
additive_expression -> additive_expression + multiplicative_expression 	1
; LEFT_OP + ] - ? OR_OP | < EQ_OP RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP 
additive_expression -> additive_expression - multiplicative_expression 	1
; LEFT_OP + ] - ? OR_OP | < EQ_OP RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP 

280 3
relational_expression -> relational_expression > shift_expression 	3
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP 
shift_expression -> shift_expression RIGHT_OP additive_expression 	1
LEFT_OP > RIGHT_OP OR_OP ? ] LE_OP EQ_OP | < GE_OP ; ) : } , NE_OP & ^ AND_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	1
LEFT_OP > RIGHT_OP OR_OP ? ] LE_OP EQ_OP | < GE_OP ; ) : } , NE_OP & ^ AND_OP 

281 3
relational_expression -> relational_expression < shift_expression 	3
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	1
LEFT_OP > RIGHT_OP OR_OP ? ] LE_OP EQ_OP | < GE_OP ; ) : } , NE_OP & ^ AND_OP 
shift_expression -> shift_expression RIGHT_OP additive_expression 	1
LEFT_OP > RIGHT_OP OR_OP ? ] LE_OP EQ_OP | < GE_OP ; ) : } , NE_OP & ^ AND_OP 

282 3
shift_expression -> shift_expression LEFT_OP additive_expression 	1
LEFT_OP > RIGHT_OP OR_OP ? ] LE_OP EQ_OP | < GE_OP ; ) : } , NE_OP & ^ AND_OP 
relational_expression -> relational_expression LE_OP shift_expression 	3
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP 
shift_expression -> shift_expression RIGHT_OP additive_expression 	1
LEFT_OP > RIGHT_OP OR_OP ? ] LE_OP EQ_OP | < GE_OP ; ) : } , NE_OP & ^ AND_OP 

283 3
relational_expression -> relational_expression GE_OP shift_expression 	3
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	1
LEFT_OP > RIGHT_OP OR_OP ? ] LE_OP EQ_OP | < GE_OP ; ) : } , NE_OP & ^ AND_OP 
shift_expression -> shift_expression RIGHT_OP additive_expression 	1
LEFT_OP > RIGHT_OP OR_OP ? ] LE_OP EQ_OP | < GE_OP ; ) : } , NE_OP & ^ AND_OP 

284 5
equality_expression -> equality_expression EQ_OP relational_expression 	3
? OR_OP NE_OP } ] EQ_OP ; ) : , & ^ | AND_OP 
relational_expression -> relational_expression < shift_expression 	1
| < > } ] LE_OP GE_OP ? OR_OP NE_OP EQ_OP ; ) : , & ^ AND_OP 
relational_expression -> relational_expression > shift_expression 	1
| < > } ] LE_OP GE_OP ? OR_OP NE_OP EQ_OP ; ) : , & ^ AND_OP 
relational_expression -> relational_expression LE_OP shift_expression 	1
| < > } ] LE_OP GE_OP ? OR_OP NE_OP EQ_OP ; ) : , & ^ AND_OP 
relational_expression -> relational_expression GE_OP shift_expression 	1
| < > } ] LE_OP GE_OP ? OR_OP NE_OP EQ_OP ; ) : , & ^ AND_OP 

285 5
relational_expression -> relational_expression > shift_expression 	1
| < > } ] LE_OP GE_OP ? OR_OP NE_OP EQ_OP ; ) : , & ^ AND_OP 
equality_expression -> equality_expression NE_OP relational_expression 	3
? OR_OP NE_OP } ] EQ_OP ; ) : , & ^ | AND_OP 
relational_expression -> relational_expression < shift_expression 	1
| < > } ] LE_OP GE_OP ? OR_OP NE_OP EQ_OP ; ) : , & ^ AND_OP 
relational_expression -> relational_expression LE_OP shift_expression 	1
| < > } ] LE_OP GE_OP ? OR_OP NE_OP EQ_OP ; ) : , & ^ AND_OP 
relational_expression -> relational_expression GE_OP shift_expression 	1
| < > } ] LE_OP GE_OP ? OR_OP NE_OP EQ_OP ; ) : , & ^ AND_OP 

286 3
and_expression -> and_expression & equality_expression 	3
OR_OP ? } ] & ; ) : , ^ | AND_OP 
equality_expression -> equality_expression EQ_OP relational_expression 	1
EQ_OP OR_OP ? NE_OP } ] & ; ) : , ^ | AND_OP 
equality_expression -> equality_expression NE_OP relational_expression 	1
EQ_OP OR_OP ? NE_OP } ] & ; ) : , ^ | AND_OP 

287 2
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	3
? OR_OP } ] ^ ; ) : , | AND_OP 
and_expression -> and_expression & equality_expression 	1
^ & ? OR_OP } ] ; ) : , | AND_OP 

288 2
inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression 	3
OR_OP ? } ] , | ; ) : AND_OP 
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	1
^ OR_OP ? } ] , | ; ) : AND_OP 

289 2
logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression 	3
? OR_OP } ] ) AND_OP ; : , 
inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression 	1
| ? OR_OP } ] ) AND_OP ; : , 

290 2
conditional_expression -> logical_or_expression ? expression : conditional_expression 	3
} ] ; ) : , 
expression -> expression , assignment_expression 	1
: , 

291 2
logical_or_expression -> logical_or_expression OR_OP logical_and_expression 	3
? OR_OP } ] ; ) : , 
logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression 	1
) AND_OP OR_OP ? } ] ; : , 

292 1
initializer_list -> initializer 	1
} , 

293 3
initializer -> { initializer_list } 	2
} , ; 
initializer -> { initializer_list , } 	2
} , ; 
initializer_list -> initializer_list , initializer 	1
} , 

294 1
labeled_statement -> IDENTIFIER : statement 	3
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 

295 3
selection_statement -> IF ( expression ) statement ELSE statement 	3
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
selection_statement -> IF ( expression ) statement 	3
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
expression -> expression , assignment_expression 	1
) , 

296 88
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
additive_expression -> additive_expression + multiplicative_expression 	0
OR_OP ? + ; < EQ_OP - 
statement -> compound_statement 	0
} ELSE FOR WHILE GOTO IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
iteration_statement -> FOR ( expression_statement expression_statement expression ) statement 	0
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
labeled_statement -> CASE constant_expression : statement 	3
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
iteration_statement -> FOR ( expression_statement expression_statement ) statement 	0
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
iteration_statement -> WHILE ( expression ) statement 	0
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
statement -> labeled_statement 	0
} ELSE FOR WHILE GOTO IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
statement -> iteration_statement 	0
} ELSE FOR WHILE GOTO IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
statement -> jump_statement 	0
} ELSE FOR WHILE GOTO IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
statement -> expression_statement 	0
} ELSE FOR WHILE GOTO IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
logical_and_expression -> inclusive_or_expression 	0
? OR_OP ; AND_OP 
statement -> selection_statement 	0
} ELSE FOR WHILE GOTO IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
iteration_statement -> DO statement WHILE ( expression ) ; 	0
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
compound_statement -> { declaration_list } 	0
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
primary_expression -> CONSTANT 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
compound_statement -> { statement_list } 	0
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
labeled_statement -> DEFAULT : statement 	0
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
compound_statement -> { } 	0
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
unary_expression -> DEC_OP unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
primary_expression -> IDENTIFIER 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
compound_statement -> { declaration_list statement_list } 	0
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
postfix_expression -> primary_expression 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
jump_statement -> GOTO IDENTIFIER ; 	0
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
postfix_expression -> postfix_expression ( ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
labeled_statement -> IDENTIFIER : statement 	0
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
jump_statement -> RETURN ; 	0
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	0
? OR_OP ; ^ 
jump_statement -> CONTINUE ; 	0
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
jump_statement -> BREAK ; 	0
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
jump_statement -> RETURN expression ; 	0
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
labeled_statement -> CASE constant_expression : statement 	0
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression 	0
OR_OP ? ; | 
and_expression -> and_expression & equality_expression 	0
OR_OP ? ; & 
expression_statement -> expression ; 	0
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
expression_statement -> ; 	0
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
selection_statement -> IF ( expression ) statement ELSE statement 	0
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
selection_statement -> IF ( expression ) statement 	0
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
selection_statement -> SWITCH ( expression ) statement 	0
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
primary_expression -> ( expression ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
expression -> assignment_expression 	0
; , 
primary_expression -> STRING_LITERAL 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
expression -> expression , assignment_expression 	0
; , 
assignment_expression -> conditional_expression 	0
; 
assignment_expression -> unary_expression assignment_operator assignment_expression 	0
; 
conditional_expression -> logical_or_expression ? expression : conditional_expression 	0
; 
postfix_expression -> postfix_expression . IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
conditional_expression -> logical_or_expression 	0
; 
unary_expression -> SIZEOF ( type_name ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
unary_expression -> postfix_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
unary_expression -> INC_OP unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
unary_expression -> unary_operator cast_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression 	0
? OR_OP ; AND_OP 
unary_expression -> SIZEOF unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
logical_or_expression -> logical_or_expression OR_OP logical_and_expression 	0
OR_OP ? ; 
logical_or_expression -> logical_and_expression 	0
OR_OP ? ; 
postfix_expression -> postfix_expression INC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
inclusive_or_expression -> exclusive_or_expression 	0
OR_OP ? ; | 
exclusive_or_expression -> and_expression 	0
? OR_OP ; ^ 
and_expression -> equality_expression 	0
OR_OP ? ; & 
equality_expression -> equality_expression EQ_OP relational_expression 	0
NE_OP ? OR_OP ; EQ_OP 
equality_expression -> relational_expression 	0
NE_OP ? OR_OP ; EQ_OP 
equality_expression -> equality_expression NE_OP relational_expression 	0
NE_OP ? OR_OP ; EQ_OP 
relational_expression -> shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression < shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression > shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression LE_OP shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression GE_OP shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
shift_expression -> additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP < RIGHT_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP < RIGHT_OP 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP < RIGHT_OP 
additive_expression -> multiplicative_expression 	0
OR_OP ? + ; < EQ_OP - 
additive_expression -> additive_expression - multiplicative_expression 	0
OR_OP ? + ; < EQ_OP - 
multiplicative_expression -> cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
cast_expression -> ( type_name ) cast_expression 	0
OR_OP ? ; < EQ_OP * 
cast_expression -> unary_expression 	0
OR_OP ? ; < EQ_OP * 

297 1
labeled_statement -> DEFAULT : statement 	3
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 

298 2
expression -> expression , assignment_expression 	1
) , 
selection_statement -> SWITCH ( expression ) statement 	3
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 

299 2
expression -> expression , assignment_expression 	1
) , 
iteration_statement -> WHILE ( expression ) statement 	3
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 

300 1
iteration_statement -> DO statement WHILE ( expression ) ; 	3
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 

301 64
conditional_expression -> logical_or_expression ? expression : conditional_expression 	0
; 
relational_expression -> relational_expression > shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
iteration_statement -> FOR ( expression_statement expression_statement ) statement 	3
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
and_expression -> and_expression & equality_expression 	0
OR_OP ? ; & 
inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression 	0
OR_OP ? ; | 
expression_statement -> expression ; 	0
) - CONSTANT SIZEOF ( INC_OP DEC_OP IDENTIFIER & STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
iteration_statement -> FOR ( expression_statement expression_statement expression ) statement 	3
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
relational_expression -> relational_expression GE_OP shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
expression_statement -> ; 	0
) - CONSTANT SIZEOF ( INC_OP DEC_OP IDENTIFIER & STRING_LITERAL * ~ + ! 
primary_expression -> STRING_LITERAL 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
expression -> expression , assignment_expression 	0
; , 
primary_expression -> ( expression ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
expression -> assignment_expression 	0
; , 
assignment_expression -> conditional_expression 	0
; 
assignment_expression -> unary_expression assignment_operator assignment_expression 	0
; 
postfix_expression -> postfix_expression . IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
conditional_expression -> logical_or_expression 	0
; 
primary_expression -> IDENTIFIER 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
unary_expression -> DEC_OP unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
and_expression -> equality_expression 	0
OR_OP ? ; & 
unary_expression -> SIZEOF ( type_name ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
unary_expression -> postfix_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
equality_expression -> equality_expression EQ_OP relational_expression 	0
NE_OP ? OR_OP ; EQ_OP 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
unary_expression -> INC_OP unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
relational_expression -> relational_expression LE_OP shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
unary_expression -> unary_operator cast_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression 	0
? OR_OP ; AND_OP 
unary_expression -> SIZEOF unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
logical_or_expression -> logical_or_expression OR_OP logical_and_expression 	0
OR_OP ? ; 
cast_expression -> unary_expression 	0
OR_OP ? ; < EQ_OP * 
logical_or_expression -> logical_and_expression 	0
OR_OP ? ; 
postfix_expression -> primary_expression 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression ( ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression INC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
equality_expression -> equality_expression NE_OP relational_expression 	0
NE_OP ? OR_OP ; EQ_OP 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
additive_expression -> additive_expression + multiplicative_expression 	0
OR_OP ? + ; < EQ_OP - 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
logical_and_expression -> inclusive_or_expression 	0
? OR_OP ; AND_OP 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP < RIGHT_OP 
primary_expression -> CONSTANT 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
inclusive_or_expression -> exclusive_or_expression 	0
OR_OP ? ; | 
exclusive_or_expression -> and_expression 	0
? OR_OP ; ^ 
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	0
? OR_OP ; ^ 
equality_expression -> relational_expression 	0
NE_OP ? OR_OP ; EQ_OP 
multiplicative_expression -> cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
relational_expression -> shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression < shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
shift_expression -> additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP < RIGHT_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP < RIGHT_OP 
additive_expression -> multiplicative_expression 	0
OR_OP ? + ; < EQ_OP - 
additive_expression -> additive_expression - multiplicative_expression 	0
OR_OP ? + ; < EQ_OP - 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
cast_expression -> ( type_name ) cast_expression 	0
OR_OP ? ; < EQ_OP * 

302 1
jump_statement -> GOTO IDENTIFIER ; 	3
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 

303 1
jump_statement -> RETURN expression ; 	3
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 

304 1
assignment_expression -> unary_expression assignment_operator assignment_expression 	3
; ) } ] : , 

305 1
expression -> expression , assignment_expression 	3
; , ) ] : 

306 1
compound_statement -> { declaration_list statement_list } 	4
} FOR ELSE WHILE DEFAULT INT IDENTIFIER STATIC DEC_OP LONG $ VOLATILE SIGNED TYPE_NAME SHORT FLOAT STRUCT REGISTER DO UNION CONST CHAR * IF UNSIGNED ( STRING_LITERAL TYPEDEF EXTERN AUTO DOUBLE RETURN VOID ENUM GOTO CASE ; { CONTINUE BREAK - SIZEOF INC_OP SWITCH CONSTANT & ~ + ! 

307 1
struct_declarator_list -> struct_declarator_list , struct_declarator 	3
; , 

308 1
struct_declarator -> declarator : constant_expression 	3
; , 

309 1
direct_abstract_declarator -> ( parameter_type_list ) 	3
( [ ) , 

310 1
direct_abstract_declarator -> ( abstract_declarator ) 	3
( [ ) , 

311 1
direct_abstract_declarator -> [ constant_expression ] 	3
( [ ) , 

312 1
direct_abstract_declarator -> direct_abstract_declarator ( ) 	3
( [ ) , 

313 1
direct_abstract_declarator -> direct_abstract_declarator ( parameter_type_list ) 	3
( [ ) , 

314 1
direct_abstract_declarator -> direct_abstract_declarator [ ] 	3
( [ ) , 

315 1
direct_abstract_declarator -> direct_abstract_declarator [ constant_expression ] 	3
( [ ) , 

316 1
cast_expression -> ( type_name ) cast_expression 	4
OR_OP ? ] | < MUL_ASSIGN EQ_OP * : XOR_ASSIGN ; LEFT_ASSIGN ) ADD_ASSIGN = } , MOD_ASSIGN GE_OP DIV_ASSIGN RIGHT_ASSIGN SUB_ASSIGN AND_ASSIGN OR_ASSIGN / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 

317 1
unary_expression -> SIZEOF ( type_name ) 	4
? OR_OP ] MUL_ASSIGN EQ_OP | < * GE_OP MOD_ASSIGN LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 

318 1
postfix_expression -> postfix_expression ( argument_expression_list ) 	4
? OR_OP ] | < MUL_ASSIGN EQ_OP * . ( [ PTR_OP INC_OP DEC_OP LEFT_ASSIGN ) DIV_ASSIGN GE_OP MOD_ASSIGN = ADD_ASSIGN } SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 

319 59
unary_expression -> INC_OP unary_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < , * 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
equality_expression -> equality_expression EQ_OP relational_expression 	0
NE_OP ? OR_OP ) EQ_OP , 
unary_expression -> postfix_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < , * 
unary_expression -> DEC_OP unary_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < , * 
primary_expression -> IDENTIFIER 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
argument_expression_list -> argument_expression_list , assignment_expression 	2
) , 
unary_expression -> unary_operator cast_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < , * 
relational_expression -> relational_expression LE_OP shift_expression 	0
? OR_OP ) < , EQ_OP > LE_OP GE_OP 
unary_expression -> SIZEOF ( type_name ) 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < , * 
and_expression -> equality_expression 	0
OR_OP ? ) , & 
assignment_expression -> conditional_expression 	0
) , 
assignment_expression -> unary_expression assignment_operator assignment_expression 	0
) , 
conditional_expression -> logical_or_expression 	0
) , 
postfix_expression -> postfix_expression . IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
conditional_expression -> logical_or_expression ? expression : conditional_expression 	0
) , 
unary_expression -> SIZEOF unary_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < , * 
logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression 	0
? OR_OP AND_OP ) , 
logical_or_expression -> logical_or_expression OR_OP logical_and_expression 	0
OR_OP ? ) , 
logical_or_expression -> logical_and_expression 	0
OR_OP ? ) , 
cast_expression -> unary_expression 	0
OR_OP ? ) < , EQ_OP * 
postfix_expression -> primary_expression 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression ( ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression INC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
equality_expression -> equality_expression NE_OP relational_expression 	0
NE_OP ? OR_OP ) EQ_OP , 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
additive_expression -> additive_expression + multiplicative_expression 	0
OR_OP ? ) < , EQ_OP + - 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
logical_and_expression -> inclusive_or_expression 	0
? OR_OP AND_OP ) , 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
/ OR_OP ? ) EQ_OP , < * % 
primary_expression -> CONSTANT 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
? OR_OP ) EQ_OP , < LEFT_OP RIGHT_OP 
primary_expression -> ( expression ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
primary_expression -> STRING_LITERAL 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
inclusive_or_expression -> exclusive_or_expression 	0
OR_OP ? ) | , 
inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression 	0
OR_OP ? ) | , 
and_expression -> and_expression & equality_expression 	0
OR_OP ? ) , & 
exclusive_or_expression -> and_expression 	0
? OR_OP ) , ^ 
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	0
? OR_OP ) , ^ 
equality_expression -> relational_expression 	0
NE_OP ? OR_OP ) EQ_OP , 
relational_expression -> relational_expression < shift_expression 	0
? OR_OP ) < , EQ_OP > LE_OP GE_OP 
relational_expression -> shift_expression 	0
? OR_OP ) < , EQ_OP > LE_OP GE_OP 
multiplicative_expression -> cast_expression 	0
/ OR_OP ? ) EQ_OP , < * % 
relational_expression -> relational_expression > shift_expression 	0
? OR_OP ) < , EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression GE_OP shift_expression 	0
? OR_OP ) < , EQ_OP > LE_OP GE_OP 
shift_expression -> additive_expression 	0
? OR_OP ) EQ_OP , < LEFT_OP RIGHT_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	0
? OR_OP ) EQ_OP , < LEFT_OP RIGHT_OP 
additive_expression -> multiplicative_expression 	0
OR_OP ? ) < , EQ_OP + - 
additive_expression -> additive_expression - multiplicative_expression 	0
OR_OP ? ) < , EQ_OP + - 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
/ OR_OP ? ) EQ_OP , < * % 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
/ OR_OP ? ) EQ_OP , < * % 
cast_expression -> ( type_name ) cast_expression 	0
OR_OP ? ) < , EQ_OP * 

320 1
postfix_expression -> postfix_expression [ expression ] 	4
? OR_OP ] | < MUL_ASSIGN EQ_OP * . ( [ PTR_OP INC_OP DEC_OP LEFT_ASSIGN ) DIV_ASSIGN GE_OP MOD_ASSIGN = ADD_ASSIGN } SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 

321 57
logical_and_expression -> inclusive_or_expression 	0
OR_OP ? } ] ; AND_OP ) : , 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
OR_OP ? } ] ; ) : EQ_OP , < * / % 
logical_or_expression -> logical_or_expression OR_OP logical_and_expression 	0
OR_OP ? ] } ; ) : , 
conditional_expression -> logical_or_expression ? expression : conditional_expression 	4
] } ; ) : , 
conditional_expression -> logical_or_expression 	0
} ] ; ) : , 
postfix_expression -> postfix_expression . IDENTIFIER 	0
OR_OP ? ] } ; ) : , EQ_OP < * . ( [ PTR_OP INC_OP DEC_OP 
conditional_expression -> logical_or_expression ? expression : conditional_expression 	0
} ] ; ) : , 
logical_or_expression -> logical_and_expression 	0
OR_OP ? ] } ; ) : , 
cast_expression -> unary_expression 	0
OR_OP ? ] } ; ) : , EQ_OP < * 
logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression 	0
OR_OP ? } ] ; AND_OP ) : , 
unary_expression -> SIZEOF unary_expression 	0
OR_OP ? } ] ; ) : EQ_OP , < * 
inclusive_or_expression -> exclusive_or_expression 	0
? OR_OP ] } ; ) : | , 
inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression 	0
? OR_OP ] } ; ) : | , 
and_expression -> and_expression & equality_expression 	0
? OR_OP ] } ; ) : , & 
exclusive_or_expression -> and_expression 	0
OR_OP ? } ] ; ) : , ^ 
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	0
OR_OP ? } ] ; ) : , ^ 
and_expression -> equality_expression 	0
? OR_OP ] } ; ) : , & 
unary_expression -> SIZEOF ( type_name ) 	0
OR_OP ? } ] ; ) : EQ_OP , < * 
equality_expression -> equality_expression EQ_OP relational_expression 	0
OR_OP ? } ] ; ) : EQ_OP , NE_OP 
unary_expression -> INC_OP unary_expression 	0
OR_OP ? } ] ; ) : EQ_OP , < * 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
OR_OP ? ] } ; ) : , EQ_OP < * . ( [ PTR_OP INC_OP DEC_OP 
equality_expression -> relational_expression 	0
OR_OP ? } ] ; ) : EQ_OP , NE_OP 
equality_expression -> equality_expression NE_OP relational_expression 	0
OR_OP ? } ] ; ) : EQ_OP , NE_OP 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
relational_expression -> relational_expression < shift_expression 	0
OR_OP ? ] } ; ) : , EQ_OP < > LE_OP GE_OP 
relational_expression -> shift_expression 	0
OR_OP ? ] } ; ) : , EQ_OP < > LE_OP GE_OP 
multiplicative_expression -> cast_expression 	0
OR_OP ? } ] ; ) : EQ_OP , < * / % 
relational_expression -> relational_expression > shift_expression 	0
OR_OP ? ] } ; ) : , EQ_OP < > LE_OP GE_OP 
relational_expression -> relational_expression LE_OP shift_expression 	0
OR_OP ? ] } ; ) : , EQ_OP < > LE_OP GE_OP 
unary_expression -> unary_operator cast_expression 	0
OR_OP ? } ] ; ) : EQ_OP , < * 
relational_expression -> relational_expression GE_OP shift_expression 	0
OR_OP ? ] } ; ) : , EQ_OP < > LE_OP GE_OP 
shift_expression -> additive_expression 	0
OR_OP ? } ] ; ) : EQ_OP , < LEFT_OP RIGHT_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	0
OR_OP ? } ] ; ) : EQ_OP , < LEFT_OP RIGHT_OP 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
OR_OP ? } ] ; ) : EQ_OP , < LEFT_OP RIGHT_OP 
primary_expression -> CONSTANT 	0
OR_OP ? } ] ; ) : EQ_OP , < * . ( 
additive_expression -> multiplicative_expression 	0
OR_OP ? ] } ; ) : , EQ_OP < + - 
additive_expression -> additive_expression + multiplicative_expression 	0
OR_OP ? ] } ; ) : , EQ_OP < + - 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
additive_expression -> additive_expression - multiplicative_expression 	0
OR_OP ? ] } ; ) : , EQ_OP < + - 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
OR_OP ? } ] ; ) : EQ_OP , < * / % 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
OR_OP ? } ] ; ) : EQ_OP , < * / % 
cast_expression -> ( type_name ) cast_expression 	0
OR_OP ? ] } ; ) : , EQ_OP < * 
unary_expression -> DEC_OP unary_expression 	0
OR_OP ? } ] ; ) : EQ_OP , < * 
primary_expression -> IDENTIFIER 	0
OR_OP ? } ] ; ) : EQ_OP , < * . ( 
unary_expression -> postfix_expression 	0
OR_OP ? } ] ; ) : EQ_OP , < * 
postfix_expression -> primary_expression 	0
OR_OP ? ] } ; ) : , EQ_OP < * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression ( ) 	0
OR_OP ? ] } ; ) : , EQ_OP < * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
OR_OP ? ] } ; ) : , EQ_OP < * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression INC_OP 	0
OR_OP ? ] } ; ) : , EQ_OP < * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
OR_OP ? ] } ; ) : , EQ_OP < * . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
OR_OP ? ] } ; ) : , EQ_OP < * . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
primary_expression -> ( expression ) 	0
OR_OP ? } ] ; ) : EQ_OP , < * . ( 
primary_expression -> STRING_LITERAL 	0
OR_OP ? } ] ; ) : EQ_OP , < * . ( 

322 63
initializer -> { initializer_list , } 	3
} , ; 
assignment_expression -> unary_expression assignment_operator assignment_expression 	0
} , 
initializer_list -> initializer_list , initializer 	2
} , 
initializer -> assignment_expression 	0
} , 
assignment_expression -> conditional_expression 	0
} , 
initializer -> { initializer_list } 	0
} , 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
/ OR_OP ? % } EQ_OP , < * 
conditional_expression -> logical_or_expression 	0
} , 
postfix_expression -> postfix_expression . IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
conditional_expression -> logical_or_expression ? expression : conditional_expression 	0
} , 
initializer -> { initializer_list , } 	0
} , 
postfix_expression -> postfix_expression ( ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
unary_expression -> DEC_OP unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN } = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < , * 
primary_expression -> IDENTIFIER 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
unary_expression -> SIZEOF ( type_name ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN } = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < , * 
and_expression -> equality_expression 	0
OR_OP ? } , & 
unary_expression -> postfix_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN } = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < , * 
unary_expression -> INC_OP unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN } = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < , * 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
equality_expression -> equality_expression EQ_OP relational_expression 	0
NE_OP ? OR_OP } EQ_OP , 
unary_expression -> unary_operator cast_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN } = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < , * 
relational_expression -> relational_expression LE_OP shift_expression 	0
? OR_OP LE_OP } < , EQ_OP > GE_OP 
unary_expression -> SIZEOF unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN } = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < , * 
logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression 	0
? OR_OP } , AND_OP 
logical_or_expression -> logical_or_expression OR_OP logical_and_expression 	0
OR_OP ? } , 
logical_or_expression -> logical_and_expression 	0
OR_OP ? } , 
cast_expression -> unary_expression 	0
OR_OP ? } < , EQ_OP * 
postfix_expression -> primary_expression 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression INC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
equality_expression -> equality_expression NE_OP relational_expression 	0
NE_OP ? OR_OP } EQ_OP , 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
additive_expression -> additive_expression + multiplicative_expression 	0
OR_OP ? - } < , EQ_OP + 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
logical_and_expression -> inclusive_or_expression 	0
? OR_OP } , AND_OP 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
/ OR_OP ? % } EQ_OP , < * 
primary_expression -> CONSTANT 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
? OR_OP } EQ_OP , < LEFT_OP RIGHT_OP 
primary_expression -> ( expression ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
primary_expression -> STRING_LITERAL 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
inclusive_or_expression -> exclusive_or_expression 	0
OR_OP ? } | , 
inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression 	0
OR_OP ? } | , 
and_expression -> and_expression & equality_expression 	0
OR_OP ? } , & 
exclusive_or_expression -> and_expression 	0
? OR_OP } , ^ 
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	0
? OR_OP } , ^ 
equality_expression -> relational_expression 	0
NE_OP ? OR_OP } EQ_OP , 
relational_expression -> relational_expression < shift_expression 	0
? OR_OP LE_OP } < , EQ_OP > GE_OP 
relational_expression -> shift_expression 	0
? OR_OP LE_OP } < , EQ_OP > GE_OP 
multiplicative_expression -> cast_expression 	0
/ OR_OP ? % } EQ_OP , < * 
relational_expression -> relational_expression > shift_expression 	0
? OR_OP LE_OP } < , EQ_OP > GE_OP 
relational_expression -> relational_expression GE_OP shift_expression 	0
? OR_OP LE_OP } < , EQ_OP > GE_OP 
shift_expression -> additive_expression 	0
? OR_OP } EQ_OP , < LEFT_OP RIGHT_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	0
? OR_OP } EQ_OP , < LEFT_OP RIGHT_OP 
additive_expression -> multiplicative_expression 	0
OR_OP ? - } < , EQ_OP + 
additive_expression -> additive_expression - multiplicative_expression 	0
OR_OP ? - } < , EQ_OP + 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
/ OR_OP ? % } EQ_OP , < * 
cast_expression -> ( type_name ) cast_expression 	0
OR_OP ? } < , EQ_OP * 

323 1
initializer -> { initializer_list } 	3
} , ; 

324 89
selection_statement -> IF ( expression ) statement ELSE statement 	4
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
statement -> expression_statement 	0
} ELSE FOR WHILE IDENTIFIER DEFAULT GOTO CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
selection_statement -> IF ( expression ) statement 	4
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
statement -> labeled_statement 	0
} ELSE FOR WHILE IDENTIFIER DEFAULT GOTO CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
statement -> iteration_statement 	0
} ELSE FOR WHILE IDENTIFIER DEFAULT GOTO CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
statement -> compound_statement 	0
} ELSE FOR WHILE IDENTIFIER DEFAULT GOTO CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
additive_expression -> additive_expression + multiplicative_expression 	0
OR_OP ? + ; < EQ_OP - 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
statement -> jump_statement 	0
} ELSE FOR WHILE IDENTIFIER DEFAULT GOTO CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
logical_and_expression -> inclusive_or_expression 	0
? OR_OP ; AND_OP 
statement -> selection_statement 	0
} ELSE FOR WHILE IDENTIFIER DEFAULT GOTO CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
iteration_statement -> DO statement WHILE ( expression ) ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
iteration_statement -> FOR ( expression_statement expression_statement ) statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
iteration_statement -> WHILE ( expression ) statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
iteration_statement -> FOR ( expression_statement expression_statement expression ) statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
compound_statement -> { declaration_list } 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
primary_expression -> CONSTANT 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
labeled_statement -> DEFAULT : statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
compound_statement -> { statement_list } 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
compound_statement -> { } 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
primary_expression -> IDENTIFIER 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
unary_expression -> DEC_OP unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
compound_statement -> { declaration_list statement_list } 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
postfix_expression -> primary_expression 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
jump_statement -> GOTO IDENTIFIER ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
postfix_expression -> postfix_expression ( ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
labeled_statement -> IDENTIFIER : statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
jump_statement -> RETURN ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
jump_statement -> CONTINUE ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	0
? OR_OP ; ^ 
jump_statement -> BREAK ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
jump_statement -> RETURN expression ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
labeled_statement -> CASE constant_expression : statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression 	0
OR_OP ? ; | 
expression_statement -> expression ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
and_expression -> and_expression & equality_expression 	0
OR_OP ? ; & 
expression_statement -> ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
selection_statement -> IF ( expression ) statement ELSE statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
selection_statement -> IF ( expression ) statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
selection_statement -> SWITCH ( expression ) statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
primary_expression -> ( expression ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
expression -> assignment_expression 	0
; , 
primary_expression -> STRING_LITERAL 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
expression -> expression , assignment_expression 	0
; , 
assignment_expression -> conditional_expression 	0
; 
assignment_expression -> unary_expression assignment_operator assignment_expression 	0
; 
conditional_expression -> logical_or_expression ? expression : conditional_expression 	0
; 
postfix_expression -> postfix_expression . IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
conditional_expression -> logical_or_expression 	0
; 
unary_expression -> SIZEOF ( type_name ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
unary_expression -> postfix_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
unary_expression -> INC_OP unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
unary_expression -> unary_operator cast_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression 	0
? OR_OP ; AND_OP 
unary_expression -> SIZEOF unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
logical_or_expression -> logical_or_expression OR_OP logical_and_expression 	0
OR_OP ? ; 
logical_or_expression -> logical_and_expression 	0
OR_OP ? ; 
postfix_expression -> postfix_expression INC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
inclusive_or_expression -> exclusive_or_expression 	0
OR_OP ? ; | 
exclusive_or_expression -> and_expression 	0
? OR_OP ; ^ 
and_expression -> equality_expression 	0
OR_OP ? ; & 
equality_expression -> equality_expression EQ_OP relational_expression 	0
NE_OP ? OR_OP ; EQ_OP 
equality_expression -> relational_expression 	0
NE_OP ? OR_OP ; EQ_OP 
equality_expression -> equality_expression NE_OP relational_expression 	0
NE_OP ? OR_OP ; EQ_OP 
relational_expression -> relational_expression < shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression > shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression LE_OP shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression GE_OP shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
shift_expression -> additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP < RIGHT_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP < RIGHT_OP 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP < RIGHT_OP 
additive_expression -> multiplicative_expression 	0
OR_OP ? + ; < EQ_OP - 
additive_expression -> additive_expression - multiplicative_expression 	0
OR_OP ? + ; < EQ_OP - 
multiplicative_expression -> cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
cast_expression -> ( type_name ) cast_expression 	0
OR_OP ? ; < EQ_OP * 
cast_expression -> unary_expression 	0
OR_OP ? ; < EQ_OP * 

325 1
labeled_statement -> CASE constant_expression : statement 	4
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 

326 88
unary_expression -> postfix_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
selection_statement -> SWITCH ( expression ) statement 	4
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
iteration_statement -> FOR ( expression_statement expression_statement ) statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
iteration_statement -> WHILE ( expression ) statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
statement -> labeled_statement 	0
} ELSE FOR WHILE IDENTIFIER DEFAULT GOTO CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
statement -> iteration_statement 	0
} ELSE FOR WHILE IDENTIFIER DEFAULT GOTO CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
statement -> compound_statement 	0
} ELSE FOR WHILE IDENTIFIER DEFAULT GOTO CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
additive_expression -> additive_expression + multiplicative_expression 	0
OR_OP ? + ; < EQ_OP - 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
statement -> jump_statement 	0
} ELSE FOR WHILE IDENTIFIER DEFAULT GOTO CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
statement -> expression_statement 	0
} ELSE FOR WHILE IDENTIFIER DEFAULT GOTO CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
logical_and_expression -> inclusive_or_expression 	0
? OR_OP ; AND_OP 
statement -> selection_statement 	0
} ELSE FOR WHILE IDENTIFIER DEFAULT GOTO CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
iteration_statement -> DO statement WHILE ( expression ) ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
iteration_statement -> FOR ( expression_statement expression_statement expression ) statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
compound_statement -> { declaration_list } 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
primary_expression -> CONSTANT 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
labeled_statement -> DEFAULT : statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
compound_statement -> { statement_list } 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
compound_statement -> { } 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
primary_expression -> IDENTIFIER 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
unary_expression -> DEC_OP unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
compound_statement -> { declaration_list statement_list } 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
postfix_expression -> primary_expression 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
jump_statement -> GOTO IDENTIFIER ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
postfix_expression -> postfix_expression ( ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
labeled_statement -> IDENTIFIER : statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
jump_statement -> RETURN ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
jump_statement -> CONTINUE ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	0
? OR_OP ; ^ 
jump_statement -> BREAK ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
jump_statement -> RETURN expression ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
labeled_statement -> CASE constant_expression : statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression 	0
OR_OP ? ; | 
expression_statement -> expression ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
and_expression -> and_expression & equality_expression 	0
OR_OP ? ; & 
expression_statement -> ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
selection_statement -> IF ( expression ) statement ELSE statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
selection_statement -> IF ( expression ) statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
selection_statement -> SWITCH ( expression ) statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
primary_expression -> ( expression ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
expression -> assignment_expression 	0
; , 
primary_expression -> STRING_LITERAL 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
expression -> expression , assignment_expression 	0
; , 
assignment_expression -> conditional_expression 	0
; 
assignment_expression -> unary_expression assignment_operator assignment_expression 	0
; 
conditional_expression -> logical_or_expression ? expression : conditional_expression 	0
; 
postfix_expression -> postfix_expression . IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
conditional_expression -> logical_or_expression 	0
; 
unary_expression -> SIZEOF ( type_name ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
unary_expression -> INC_OP unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
unary_expression -> unary_operator cast_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression 	0
? OR_OP ; AND_OP 
unary_expression -> SIZEOF unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
logical_or_expression -> logical_or_expression OR_OP logical_and_expression 	0
OR_OP ? ; 
logical_or_expression -> logical_and_expression 	0
OR_OP ? ; 
postfix_expression -> postfix_expression INC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
inclusive_or_expression -> exclusive_or_expression 	0
OR_OP ? ; | 
exclusive_or_expression -> and_expression 	0
? OR_OP ; ^ 
and_expression -> equality_expression 	0
OR_OP ? ; & 
equality_expression -> equality_expression EQ_OP relational_expression 	0
NE_OP ? OR_OP ; EQ_OP 
equality_expression -> relational_expression 	0
NE_OP ? OR_OP ; EQ_OP 
equality_expression -> equality_expression NE_OP relational_expression 	0
NE_OP ? OR_OP ; EQ_OP 
relational_expression -> relational_expression < shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression > shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression LE_OP shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression GE_OP shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
shift_expression -> additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP < RIGHT_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP < RIGHT_OP 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP < RIGHT_OP 
additive_expression -> multiplicative_expression 	0
OR_OP ? + ; < EQ_OP - 
additive_expression -> additive_expression - multiplicative_expression 	0
OR_OP ? + ; < EQ_OP - 
multiplicative_expression -> cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
cast_expression -> ( type_name ) cast_expression 	0
OR_OP ? ; < EQ_OP * 
cast_expression -> unary_expression 	0
OR_OP ? ; < EQ_OP * 

327 88
logical_or_expression -> logical_and_expression 	0
OR_OP ? ; 
iteration_statement -> WHILE ( expression ) statement 	4
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
iteration_statement -> FOR ( expression_statement expression_statement ) statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
iteration_statement -> WHILE ( expression ) statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
statement -> labeled_statement 	0
} ELSE FOR WHILE IDENTIFIER DEFAULT GOTO CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
statement -> iteration_statement 	0
} ELSE FOR WHILE IDENTIFIER DEFAULT GOTO CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
statement -> compound_statement 	0
} ELSE FOR WHILE IDENTIFIER DEFAULT GOTO CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
additive_expression -> additive_expression + multiplicative_expression 	0
OR_OP ? + ; < EQ_OP - 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
statement -> jump_statement 	0
} ELSE FOR WHILE IDENTIFIER DEFAULT GOTO CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
statement -> expression_statement 	0
} ELSE FOR WHILE IDENTIFIER DEFAULT GOTO CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
logical_and_expression -> inclusive_or_expression 	0
? OR_OP ; AND_OP 
statement -> selection_statement 	0
} ELSE FOR WHILE IDENTIFIER DEFAULT GOTO CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
iteration_statement -> DO statement WHILE ( expression ) ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
iteration_statement -> FOR ( expression_statement expression_statement expression ) statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
compound_statement -> { declaration_list } 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
primary_expression -> CONSTANT 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
labeled_statement -> DEFAULT : statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
compound_statement -> { statement_list } 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
compound_statement -> { } 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
primary_expression -> IDENTIFIER 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
unary_expression -> DEC_OP unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
compound_statement -> { declaration_list statement_list } 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
postfix_expression -> primary_expression 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
jump_statement -> GOTO IDENTIFIER ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
postfix_expression -> postfix_expression ( ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
labeled_statement -> IDENTIFIER : statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
jump_statement -> RETURN ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
jump_statement -> CONTINUE ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	0
? OR_OP ; ^ 
jump_statement -> BREAK ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
jump_statement -> RETURN expression ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
labeled_statement -> CASE constant_expression : statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression 	0
OR_OP ? ; | 
expression_statement -> expression ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
and_expression -> and_expression & equality_expression 	0
OR_OP ? ; & 
expression_statement -> ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
selection_statement -> IF ( expression ) statement ELSE statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
selection_statement -> IF ( expression ) statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
selection_statement -> SWITCH ( expression ) statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
primary_expression -> ( expression ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
expression -> assignment_expression 	0
; , 
primary_expression -> STRING_LITERAL 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
expression -> expression , assignment_expression 	0
; , 
assignment_expression -> conditional_expression 	0
; 
assignment_expression -> unary_expression assignment_operator assignment_expression 	0
; 
conditional_expression -> logical_or_expression ? expression : conditional_expression 	0
; 
postfix_expression -> postfix_expression . IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
conditional_expression -> logical_or_expression 	0
; 
unary_expression -> SIZEOF ( type_name ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
unary_expression -> postfix_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
unary_expression -> INC_OP unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
unary_expression -> unary_operator cast_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression 	0
? OR_OP ; AND_OP 
unary_expression -> SIZEOF unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
logical_or_expression -> logical_or_expression OR_OP logical_and_expression 	0
OR_OP ? ; 
postfix_expression -> postfix_expression INC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
inclusive_or_expression -> exclusive_or_expression 	0
OR_OP ? ; | 
exclusive_or_expression -> and_expression 	0
? OR_OP ; ^ 
and_expression -> equality_expression 	0
OR_OP ? ; & 
equality_expression -> equality_expression EQ_OP relational_expression 	0
NE_OP ? OR_OP ; EQ_OP 
equality_expression -> relational_expression 	0
NE_OP ? OR_OP ; EQ_OP 
equality_expression -> equality_expression NE_OP relational_expression 	0
NE_OP ? OR_OP ; EQ_OP 
relational_expression -> relational_expression < shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression > shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression LE_OP shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression GE_OP shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
shift_expression -> additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP < RIGHT_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP < RIGHT_OP 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP < RIGHT_OP 
additive_expression -> multiplicative_expression 	0
OR_OP ? + ; < EQ_OP - 
additive_expression -> additive_expression - multiplicative_expression 	0
OR_OP ? + ; < EQ_OP - 
multiplicative_expression -> cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
cast_expression -> ( type_name ) cast_expression 	0
OR_OP ? ; < EQ_OP * 
cast_expression -> unary_expression 	0
OR_OP ? ; < EQ_OP * 

328 61
expression -> expression , assignment_expression 	0
) , 
primary_expression -> STRING_LITERAL 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
expression -> assignment_expression 	0
) , 
primary_expression -> ( expression ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
iteration_statement -> DO statement WHILE ( expression ) ; 	4
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_expression -> SIZEOF ( type_name ) 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
and_expression -> equality_expression 	0
OR_OP ? ) & 
assignment_expression -> conditional_expression 	0
) 
assignment_expression -> unary_expression assignment_operator assignment_expression 	0
) 
conditional_expression -> logical_or_expression 	0
) 
postfix_expression -> postfix_expression . IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
conditional_expression -> logical_or_expression ? expression : conditional_expression 	0
) 
unary_expression -> DEC_OP unary_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
primary_expression -> IDENTIFIER 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
unary_expression -> postfix_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
unary_expression -> INC_OP unary_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
equality_expression -> equality_expression EQ_OP relational_expression 	0
NE_OP ? OR_OP ) EQ_OP 
unary_expression -> unary_operator cast_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
relational_expression -> relational_expression LE_OP shift_expression 	0
OR_OP ? ) < EQ_OP > LE_OP GE_OP 
unary_expression -> SIZEOF unary_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression 	0
? OR_OP AND_OP ) 
logical_or_expression -> logical_or_expression OR_OP logical_and_expression 	0
OR_OP ? ) 
logical_or_expression -> logical_and_expression 	0
OR_OP ? ) 
cast_expression -> unary_expression 	0
OR_OP ? ) < EQ_OP * 
postfix_expression -> primary_expression 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression ( ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression INC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
equality_expression -> equality_expression NE_OP relational_expression 	0
NE_OP ? OR_OP ) EQ_OP 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
additive_expression -> additive_expression + multiplicative_expression 	0
OR_OP ? ) < EQ_OP + - 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
logical_and_expression -> inclusive_or_expression 	0
? OR_OP AND_OP ) 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
/ ? OR_OP ) EQ_OP < * % 
primary_expression -> CONSTANT 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
? OR_OP ) EQ_OP < LEFT_OP RIGHT_OP 
inclusive_or_expression -> exclusive_or_expression 	0
OR_OP ? ) | 
inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression 	0
OR_OP ? ) | 
and_expression -> and_expression & equality_expression 	0
OR_OP ? ) & 
exclusive_or_expression -> and_expression 	0
? OR_OP ) ^ 
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	0
? OR_OP ) ^ 
equality_expression -> relational_expression 	0
NE_OP ? OR_OP ) EQ_OP 
relational_expression -> relational_expression < shift_expression 	0
OR_OP ? ) < EQ_OP > LE_OP GE_OP 
relational_expression -> shift_expression 	0
OR_OP ? ) < EQ_OP > LE_OP GE_OP 
multiplicative_expression -> cast_expression 	0
/ ? OR_OP ) EQ_OP < * % 
relational_expression -> relational_expression > shift_expression 	0
OR_OP ? ) < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression GE_OP shift_expression 	0
OR_OP ? ) < EQ_OP > LE_OP GE_OP 
shift_expression -> additive_expression 	0
? OR_OP ) EQ_OP < LEFT_OP RIGHT_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	0
? OR_OP ) EQ_OP < LEFT_OP RIGHT_OP 
additive_expression -> multiplicative_expression 	0
OR_OP ? ) < EQ_OP + - 
additive_expression -> additive_expression - multiplicative_expression 	0
OR_OP ? ) < EQ_OP + - 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
/ ? OR_OP ) EQ_OP < * % 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
/ ? OR_OP ) EQ_OP < * % 
cast_expression -> ( type_name ) cast_expression 	0
OR_OP ? ) < EQ_OP * 

329 62
unary_expression -> DEC_OP unary_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
primary_expression -> IDENTIFIER 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
iteration_statement -> FOR ( expression_statement expression_statement ) statement 	4
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
logical_or_expression -> logical_and_expression 	0
OR_OP ? ) 
cast_expression -> unary_expression 	0
OR_OP ? ) < EQ_OP * 
iteration_statement -> FOR ( expression_statement expression_statement expression ) statement 	4
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
inclusive_or_expression -> exclusive_or_expression 	0
OR_OP ? ) | 
expression -> expression , assignment_expression 	0
) , 
primary_expression -> STRING_LITERAL 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
expression -> assignment_expression 	0
) , 
primary_expression -> ( expression ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
assignment_expression -> conditional_expression 	0
) 
assignment_expression -> unary_expression assignment_operator assignment_expression 	0
) 
conditional_expression -> logical_or_expression 	0
) 
postfix_expression -> postfix_expression . IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
conditional_expression -> logical_or_expression ? expression : conditional_expression 	0
) 
unary_expression -> SIZEOF ( type_name ) 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
and_expression -> equality_expression 	0
OR_OP ? ) & 
unary_expression -> postfix_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
unary_expression -> INC_OP unary_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
equality_expression -> equality_expression EQ_OP relational_expression 	0
NE_OP ? OR_OP ) EQ_OP 
unary_expression -> unary_operator cast_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
relational_expression -> relational_expression LE_OP shift_expression 	0
OR_OP ? ) < EQ_OP > LE_OP GE_OP 
unary_expression -> SIZEOF unary_expression 	0
DIV_ASSIGN ) LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression 	0
? OR_OP AND_OP ) 
logical_or_expression -> logical_or_expression OR_OP logical_and_expression 	0
OR_OP ? ) 
postfix_expression -> primary_expression 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression ( ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression INC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
equality_expression -> equality_expression NE_OP relational_expression 	0
NE_OP ? OR_OP ) EQ_OP 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
additive_expression -> additive_expression + multiplicative_expression 	0
OR_OP ? ) < EQ_OP + - 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
logical_and_expression -> inclusive_or_expression 	0
? OR_OP AND_OP ) 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
/ ? OR_OP ) EQ_OP < * % 
primary_expression -> CONSTANT 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
? OR_OP ) EQ_OP < LEFT_OP RIGHT_OP 
inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression 	0
OR_OP ? ) | 
and_expression -> and_expression & equality_expression 	0
OR_OP ? ) & 
exclusive_or_expression -> and_expression 	0
? OR_OP ) ^ 
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	0
? OR_OP ) ^ 
equality_expression -> relational_expression 	0
NE_OP ? OR_OP ) EQ_OP 
relational_expression -> relational_expression < shift_expression 	0
OR_OP ? ) < EQ_OP > LE_OP GE_OP 
relational_expression -> shift_expression 	0
OR_OP ? ) < EQ_OP > LE_OP GE_OP 
multiplicative_expression -> cast_expression 	0
/ ? OR_OP ) EQ_OP < * % 
relational_expression -> relational_expression > shift_expression 	0
OR_OP ? ) < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression GE_OP shift_expression 	0
OR_OP ? ) < EQ_OP > LE_OP GE_OP 
shift_expression -> additive_expression 	0
? OR_OP ) EQ_OP < LEFT_OP RIGHT_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	0
? OR_OP ) EQ_OP < LEFT_OP RIGHT_OP 
additive_expression -> multiplicative_expression 	0
OR_OP ? ) < EQ_OP + - 
additive_expression -> additive_expression - multiplicative_expression 	0
OR_OP ? ) < EQ_OP + - 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
/ ? OR_OP ) EQ_OP < * % 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
/ ? OR_OP ) EQ_OP < * % 
cast_expression -> ( type_name ) cast_expression 	0
OR_OP ? ) < EQ_OP * 

330 1
direct_abstract_declarator -> direct_abstract_declarator ( parameter_type_list ) 	4
( [ ) , 

331 1
direct_abstract_declarator -> direct_abstract_declarator [ constant_expression ] 	4
( [ ) , 

332 1
argument_expression_list -> argument_expression_list , assignment_expression 	3
) , 

333 1
conditional_expression -> logical_or_expression ? expression : conditional_expression 	5
} ] ; ) : , 

334 1
initializer -> { initializer_list , } 	4
} , ; 

335 1
initializer_list -> initializer_list , initializer 	3
} , 

336 2
selection_statement -> IF ( expression ) statement ELSE statement 	5
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
selection_statement -> IF ( expression ) statement 	5
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 

337 1
selection_statement -> SWITCH ( expression ) statement 	5
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 

338 1
iteration_statement -> WHILE ( expression ) statement 	5
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 

339 2
expression -> expression , assignment_expression 	1
) , 
iteration_statement -> DO statement WHILE ( expression ) ; 	5
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 

340 88
primary_expression -> CONSTANT 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
labeled_statement -> DEFAULT : statement 	0
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
compound_statement -> { statement_list } 	0
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
iteration_statement -> FOR ( expression_statement expression_statement ) statement 	5
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
iteration_statement -> FOR ( expression_statement expression_statement ) statement 	0
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
iteration_statement -> WHILE ( expression ) statement 	0
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
statement -> labeled_statement 	0
} ELSE FOR WHILE GOTO IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
statement -> iteration_statement 	0
} ELSE FOR WHILE GOTO IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
statement -> compound_statement 	0
} ELSE FOR WHILE GOTO IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
additive_expression -> additive_expression + multiplicative_expression 	0
OR_OP ? + ; < EQ_OP - 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
statement -> jump_statement 	0
} ELSE FOR WHILE GOTO IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
statement -> expression_statement 	0
} ELSE FOR WHILE GOTO IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
logical_and_expression -> inclusive_or_expression 	0
? OR_OP ; AND_OP 
statement -> selection_statement 	0
} ELSE FOR WHILE GOTO IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
iteration_statement -> DO statement WHILE ( expression ) ; 	0
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
iteration_statement -> FOR ( expression_statement expression_statement expression ) statement 	0
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
compound_statement -> { declaration_list } 	0
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
compound_statement -> { } 	0
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
primary_expression -> IDENTIFIER 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
unary_expression -> DEC_OP unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
compound_statement -> { declaration_list statement_list } 	0
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
postfix_expression -> primary_expression 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
jump_statement -> GOTO IDENTIFIER ; 	0
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
postfix_expression -> postfix_expression ( ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
labeled_statement -> IDENTIFIER : statement 	0
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
jump_statement -> RETURN ; 	0
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
jump_statement -> CONTINUE ; 	0
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	0
? OR_OP ; ^ 
jump_statement -> BREAK ; 	0
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
jump_statement -> RETURN expression ; 	0
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
labeled_statement -> CASE constant_expression : statement 	0
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression 	0
OR_OP ? ; | 
expression_statement -> expression ; 	0
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
and_expression -> and_expression & equality_expression 	0
OR_OP ? ; & 
expression_statement -> ; 	0
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
selection_statement -> IF ( expression ) statement ELSE statement 	0
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
selection_statement -> IF ( expression ) statement 	0
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
selection_statement -> SWITCH ( expression ) statement 	0
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
primary_expression -> ( expression ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
expression -> assignment_expression 	0
; , 
primary_expression -> STRING_LITERAL 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
expression -> expression , assignment_expression 	0
; , 
assignment_expression -> conditional_expression 	0
; 
assignment_expression -> unary_expression assignment_operator assignment_expression 	0
; 
conditional_expression -> logical_or_expression ? expression : conditional_expression 	0
; 
postfix_expression -> postfix_expression . IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
conditional_expression -> logical_or_expression 	0
; 
unary_expression -> SIZEOF ( type_name ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
unary_expression -> postfix_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
unary_expression -> INC_OP unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
unary_expression -> unary_operator cast_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression 	0
? OR_OP ; AND_OP 
unary_expression -> SIZEOF unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
logical_or_expression -> logical_or_expression OR_OP logical_and_expression 	0
OR_OP ? ; 
logical_or_expression -> logical_and_expression 	0
OR_OP ? ; 
postfix_expression -> postfix_expression INC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
inclusive_or_expression -> exclusive_or_expression 	0
OR_OP ? ; | 
exclusive_or_expression -> and_expression 	0
? OR_OP ; ^ 
and_expression -> equality_expression 	0
OR_OP ? ; & 
equality_expression -> equality_expression EQ_OP relational_expression 	0
NE_OP ? OR_OP ; EQ_OP 
equality_expression -> relational_expression 	0
NE_OP ? OR_OP ; EQ_OP 
equality_expression -> equality_expression NE_OP relational_expression 	0
NE_OP ? OR_OP ; EQ_OP 
relational_expression -> relational_expression < shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression > shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression LE_OP shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression GE_OP shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
shift_expression -> additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP < RIGHT_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP < RIGHT_OP 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP < RIGHT_OP 
additive_expression -> multiplicative_expression 	0
OR_OP ? + ; < EQ_OP - 
additive_expression -> additive_expression - multiplicative_expression 	0
OR_OP ? + ; < EQ_OP - 
multiplicative_expression -> cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
cast_expression -> ( type_name ) cast_expression 	0
OR_OP ? ; < EQ_OP * 
cast_expression -> unary_expression 	0
OR_OP ? ; < EQ_OP * 

341 2
iteration_statement -> FOR ( expression_statement expression_statement expression ) statement 	5
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
expression -> expression , assignment_expression 	1
) , 

342 88
logical_and_expression -> inclusive_or_expression 	0
? OR_OP ; AND_OP 
statement -> selection_statement 	0
} ELSE FOR WHILE IDENTIFIER DEFAULT GOTO CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
selection_statement -> IF ( expression ) statement ELSE statement 	6
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
iteration_statement -> FOR ( expression_statement expression_statement ) statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
iteration_statement -> WHILE ( expression ) statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
statement -> labeled_statement 	0
} ELSE FOR WHILE IDENTIFIER DEFAULT GOTO CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
statement -> iteration_statement 	0
} ELSE FOR WHILE IDENTIFIER DEFAULT GOTO CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
statement -> compound_statement 	0
} ELSE FOR WHILE IDENTIFIER DEFAULT GOTO CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
additive_expression -> additive_expression + multiplicative_expression 	0
OR_OP ? + ; < EQ_OP - 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
statement -> jump_statement 	0
} ELSE FOR WHILE IDENTIFIER DEFAULT GOTO CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
statement -> expression_statement 	0
} ELSE FOR WHILE IDENTIFIER DEFAULT GOTO CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
iteration_statement -> DO statement WHILE ( expression ) ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
iteration_statement -> FOR ( expression_statement expression_statement expression ) statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
compound_statement -> { declaration_list } 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
primary_expression -> CONSTANT 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
labeled_statement -> DEFAULT : statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
compound_statement -> { statement_list } 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
compound_statement -> { } 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
primary_expression -> IDENTIFIER 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
unary_expression -> DEC_OP unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
compound_statement -> { declaration_list statement_list } 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
postfix_expression -> primary_expression 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
jump_statement -> GOTO IDENTIFIER ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
postfix_expression -> postfix_expression ( ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
labeled_statement -> IDENTIFIER : statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
jump_statement -> RETURN ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
jump_statement -> CONTINUE ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	0
? OR_OP ; ^ 
jump_statement -> BREAK ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
jump_statement -> RETURN expression ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
labeled_statement -> CASE constant_expression : statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression 	0
OR_OP ? ; | 
expression_statement -> expression ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
and_expression -> and_expression & equality_expression 	0
OR_OP ? ; & 
expression_statement -> ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
selection_statement -> IF ( expression ) statement ELSE statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
selection_statement -> IF ( expression ) statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
selection_statement -> SWITCH ( expression ) statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
primary_expression -> ( expression ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
expression -> assignment_expression 	0
; , 
primary_expression -> STRING_LITERAL 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
expression -> expression , assignment_expression 	0
; , 
assignment_expression -> conditional_expression 	0
; 
assignment_expression -> unary_expression assignment_operator assignment_expression 	0
; 
conditional_expression -> logical_or_expression ? expression : conditional_expression 	0
; 
postfix_expression -> postfix_expression . IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
conditional_expression -> logical_or_expression 	0
; 
unary_expression -> SIZEOF ( type_name ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
unary_expression -> postfix_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
unary_expression -> INC_OP unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
unary_expression -> unary_operator cast_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression 	0
? OR_OP ; AND_OP 
unary_expression -> SIZEOF unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
logical_or_expression -> logical_or_expression OR_OP logical_and_expression 	0
OR_OP ? ; 
logical_or_expression -> logical_and_expression 	0
OR_OP ? ; 
postfix_expression -> postfix_expression INC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
inclusive_or_expression -> exclusive_or_expression 	0
OR_OP ? ; | 
exclusive_or_expression -> and_expression 	0
? OR_OP ; ^ 
and_expression -> equality_expression 	0
OR_OP ? ; & 
equality_expression -> equality_expression EQ_OP relational_expression 	0
NE_OP ? OR_OP ; EQ_OP 
equality_expression -> relational_expression 	0
NE_OP ? OR_OP ; EQ_OP 
equality_expression -> equality_expression NE_OP relational_expression 	0
NE_OP ? OR_OP ; EQ_OP 
relational_expression -> relational_expression < shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression > shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression LE_OP shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression GE_OP shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
shift_expression -> additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP < RIGHT_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP < RIGHT_OP 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP < RIGHT_OP 
additive_expression -> multiplicative_expression 	0
OR_OP ? + ; < EQ_OP - 
additive_expression -> additive_expression - multiplicative_expression 	0
OR_OP ? + ; < EQ_OP - 
multiplicative_expression -> cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
cast_expression -> ( type_name ) cast_expression 	0
OR_OP ? ; < EQ_OP * 
cast_expression -> unary_expression 	0
OR_OP ? ; < EQ_OP * 

343 1
iteration_statement -> DO statement WHILE ( expression ) ; 	6
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 

344 1
iteration_statement -> FOR ( expression_statement expression_statement ) statement 	6
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 

345 88
iteration_statement -> FOR ( expression_statement expression_statement ) statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
iteration_statement -> WHILE ( expression ) statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
statement -> labeled_statement 	0
} ELSE FOR WHILE IDENTIFIER DEFAULT GOTO CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
statement -> iteration_statement 	0
} ELSE FOR WHILE IDENTIFIER DEFAULT GOTO CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
multiplicative_expression -> multiplicative_expression * cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
assignment_expression -> unary_expression assignment_operator assignment_expression 	0
; 
iteration_statement -> FOR ( expression_statement expression_statement expression ) statement 	6
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
unary_operator -> & 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
statement -> compound_statement 	0
} ELSE FOR WHILE IDENTIFIER DEFAULT GOTO CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
additive_expression -> additive_expression + multiplicative_expression 	0
OR_OP ? + ; < EQ_OP - 
unary_operator -> - 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
statement -> jump_statement 	0
} ELSE FOR WHILE IDENTIFIER DEFAULT GOTO CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
statement -> expression_statement 	0
} ELSE FOR WHILE IDENTIFIER DEFAULT GOTO CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
logical_and_expression -> inclusive_or_expression 	0
? OR_OP ; AND_OP 
statement -> selection_statement 	0
} ELSE FOR WHILE IDENTIFIER DEFAULT GOTO CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
unary_operator -> * 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
iteration_statement -> DO statement WHILE ( expression ) ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
iteration_statement -> FOR ( expression_statement expression_statement expression ) statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
compound_statement -> { declaration_list } 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
primary_expression -> CONSTANT 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
labeled_statement -> DEFAULT : statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
compound_statement -> { statement_list } 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
compound_statement -> { } 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
primary_expression -> IDENTIFIER 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
unary_expression -> DEC_OP unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
compound_statement -> { declaration_list statement_list } 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
postfix_expression -> primary_expression 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
jump_statement -> GOTO IDENTIFIER ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
postfix_expression -> postfix_expression ( ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
labeled_statement -> IDENTIFIER : statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
jump_statement -> RETURN ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
jump_statement -> CONTINUE ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	0
? OR_OP ; ^ 
jump_statement -> BREAK ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
jump_statement -> RETURN expression ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
labeled_statement -> CASE constant_expression : statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression 	0
OR_OP ? ; | 
expression_statement -> expression ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
and_expression -> and_expression & equality_expression 	0
OR_OP ? ; & 
expression_statement -> ; 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
selection_statement -> IF ( expression ) statement ELSE statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
selection_statement -> IF ( expression ) statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
selection_statement -> SWITCH ( expression ) statement 	0
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
primary_expression -> ( expression ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
expression -> assignment_expression 	0
; , 
primary_expression -> STRING_LITERAL 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 
expression -> expression , assignment_expression 	0
; , 
assignment_expression -> conditional_expression 	0
; 
conditional_expression -> logical_or_expression ? expression : conditional_expression 	0
; 
postfix_expression -> postfix_expression . IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
conditional_expression -> logical_or_expression 	0
; 
unary_expression -> SIZEOF ( type_name ) 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
unary_expression -> postfix_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
postfix_expression -> postfix_expression ( argument_expression_list ) 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
unary_expression -> INC_OP unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
unary_expression -> unary_operator cast_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression 	0
? OR_OP ; AND_OP 
unary_expression -> SIZEOF unary_expression 	0
DIV_ASSIGN LEFT_ASSIGN MOD_ASSIGN = ADD_ASSIGN EQ_OP MUL_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN ? OR_OP < * 
logical_or_expression -> logical_or_expression OR_OP logical_and_expression 	0
OR_OP ? ; 
logical_or_expression -> logical_and_expression 	0
OR_OP ? ; 
postfix_expression -> postfix_expression INC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression [ expression ] 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
postfix_expression -> postfix_expression DEC_OP 	0
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( [ PTR_OP INC_OP DEC_OP 
unary_operator -> + 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ~ 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
unary_operator -> ! 	0
& INC_OP ( CONSTANT SIZEOF - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 
inclusive_or_expression -> exclusive_or_expression 	0
OR_OP ? ; | 
exclusive_or_expression -> and_expression 	0
? OR_OP ; ^ 
and_expression -> equality_expression 	0
OR_OP ? ; & 
equality_expression -> equality_expression EQ_OP relational_expression 	0
NE_OP ? OR_OP ; EQ_OP 
equality_expression -> relational_expression 	0
NE_OP ? OR_OP ; EQ_OP 
equality_expression -> equality_expression NE_OP relational_expression 	0
NE_OP ? OR_OP ; EQ_OP 
relational_expression -> relational_expression < shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression > shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression LE_OP shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
relational_expression -> relational_expression GE_OP shift_expression 	0
OR_OP ? ; < EQ_OP > LE_OP GE_OP 
shift_expression -> additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP < RIGHT_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP < RIGHT_OP 
shift_expression -> shift_expression RIGHT_OP additive_expression 	0
? OR_OP LEFT_OP ; EQ_OP < RIGHT_OP 
additive_expression -> multiplicative_expression 	0
OR_OP ? + ; < EQ_OP - 
additive_expression -> additive_expression - multiplicative_expression 	0
OR_OP ? + ; < EQ_OP - 
multiplicative_expression -> cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
multiplicative_expression -> multiplicative_expression / cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
multiplicative_expression -> multiplicative_expression % cast_expression 	0
/ ? OR_OP ; EQ_OP < * % 
cast_expression -> ( type_name ) cast_expression 	0
OR_OP ? ; < EQ_OP * 
cast_expression -> unary_expression 	0
OR_OP ? ; < EQ_OP * 

346 1
selection_statement -> IF ( expression ) statement ELSE statement 	7
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 

347 1
iteration_statement -> DO statement WHILE ( expression ) ; 	7
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 

348 1
iteration_statement -> FOR ( expression_statement expression_statement expression ) statement 	7
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 

