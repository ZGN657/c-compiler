status number: 0
1
argumented_translation_unit -> translation_unit 	0
$ 


status number: 1
1
type_specifier -> LONG 	1
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; : [ ) , 


status number: 2
1
type_specifier -> INT 	1
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; : [ ) , 


status number: 3
1
direct_declarator -> IDENTIFIER 	1
; { VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ ) = , : 


status number: 4
1
storage_class_specifier -> TYPEDEF 	1
INT IDENTIFIER CHAR * SHORT SIGNED TYPE_NAME VOLATILE ( ; REGISTER STRUCT STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM [ ) , 


status number: 5
1
direct_declarator -> ( declarator ) 	1
; { VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ ) = , : 


status number: 6
1
type_specifier -> DOUBLE 	1
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; : [ ) , 


status number: 7
1
type_specifier -> CHAR 	1
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; : [ ) , 


status number: 8
4
pointer -> * 	1
IDENTIFIER ( [ ) , 
pointer -> * type_qualifier_list 	1
IDENTIFIER ( [ ) , 
pointer -> * pointer 	1
IDENTIFIER ( [ ) , 
pointer -> * type_qualifier_list pointer 	1
IDENTIFIER ( [ ) , 


status number: 9
1
storage_class_specifier -> STATIC 	1
INT IDENTIFIER CHAR * SHORT SIGNED TYPE_NAME VOLATILE ( ; REGISTER STRUCT STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM [ ) , 


status number: 10
1
type_specifier -> SHORT 	1
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; : [ ) , 


status number: 11
1
storage_class_specifier -> EXTERN 	1
INT IDENTIFIER CHAR * SHORT SIGNED TYPE_NAME VOLATILE ( ; REGISTER STRUCT STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM [ ) , 


status number: 12
1
storage_class_specifier -> AUTO 	1
INT IDENTIFIER CHAR * SHORT SIGNED TYPE_NAME VOLATILE ( ; REGISTER STRUCT STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM [ ) , 


status number: 13
1
storage_class_specifier -> REGISTER 	1
INT IDENTIFIER CHAR * SHORT SIGNED TYPE_NAME VOLATILE ( ; REGISTER STRUCT STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM [ ) , 


status number: 14
1
type_specifier -> VOID 	1
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; : [ ) , 


status number: 15
1
type_specifier -> FLOAT 	1
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; : [ ) , 


status number: 16
1
type_specifier -> TYPE_NAME 	1
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; : [ ) , 


status number: 17
1
type_specifier -> SIGNED 	1
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; : [ ) , 


status number: 18
1
type_specifier -> UNSIGNED 	1
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; : [ ) , 


status number: 19
1
struct_or_union -> STRUCT 	1
{ IDENTIFIER 


status number: 20
1
struct_or_union -> UNION 	1
{ IDENTIFIER 


status number: 21
3
enum_specifier -> ENUM { enumerator_list } 	1
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; : [ ) , 
enum_specifier -> ENUM IDENTIFIER { enumerator_list } 	1
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; : [ ) , 
enum_specifier -> ENUM IDENTIFIER 	1
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; : [ ) , 


status number: 22
1
type_qualifier -> CONST 	1
INT IDENTIFIER CHAR * SHORT SIGNED TYPE_NAME VOLATILE ( ; REGISTER STRUCT STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM : [ ) , 


status number: 23
1
type_qualifier -> VOLATILE 	1
INT IDENTIFIER CHAR * SHORT SIGNED TYPE_NAME VOLATILE ( ; REGISTER STRUCT STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID FLOAT LONG UNSIGNED ENUM : [ ) , 


status number: 24
3
struct_or_union_specifier -> struct_or_union IDENTIFIER 	1
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; : [ ) , 
struct_or_union_specifier -> struct_or_union { struct_declaration_list } 	1
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; : [ ) , 
struct_or_union_specifier -> struct_or_union IDENTIFIER { struct_declaration_list } 	1
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; : [ ) , 


status number: 25
2
argumented_translation_unit -> translation_unit 	1
$ 
translation_unit -> translation_unit external_declaration 	1
STATIC INT IDENTIFIER FLOAT SHORT SIGNED TYPE_NAME VOLATILE REGISTER STRUCT CONST UNION * CHAR UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID $ LONG ENUM 


status number: 26
2
declaration_specifiers -> storage_class_specifier declaration_specifiers 	1
IDENTIFIER * ( [ ; ) , 
declaration_specifiers -> storage_class_specifier 	1
IDENTIFIER * ( [ ; ) , 


status number: 27
6
direct_declarator -> direct_declarator ( ) 	1
; { VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ ) = , : 
direct_declarator -> direct_declarator [ ] 	1
; { VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ ) = , : 
declarator -> direct_declarator 	1
; { SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC TYPEDEF CONST UNION EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ) = , : 
direct_declarator -> direct_declarator ( identifier_list ) 	1
; { VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ ) = , : 
direct_declarator -> direct_declarator ( parameter_type_list ) 	1
; { VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ ) = , : 
direct_declarator -> direct_declarator [ constant_expression ] 	1
; { VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ ) = , : 


status number: 28
1
external_declaration -> declaration 	1
STATIC LONG $ INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT FLOAT STRUCT REGISTER UNION CONST CHAR * UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID ENUM 


status number: 29
1
external_declaration -> function_definition 	1
STATIC LONG $ INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT FLOAT STRUCT REGISTER UNION CONST CHAR * UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID ENUM 


status number: 30
4
declaration -> declaration_specifiers ; 	1
STATIC LONG $ INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT FLOAT STRUCT REGISTER UNION CONST CHAR * UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID ENUM 
declaration -> declaration_specifiers init_declarator_list ; 	1
STATIC LONG $ INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT FLOAT STRUCT REGISTER UNION CONST CHAR * UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID ENUM 
function_definition -> declaration_specifiers declarator compound_statement 	1
STATIC LONG $ INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT FLOAT STRUCT REGISTER UNION CONST CHAR * UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID ENUM 
function_definition -> declaration_specifiers declarator declaration_list compound_statement 	1
STATIC LONG $ INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT FLOAT STRUCT REGISTER UNION CONST CHAR * UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID ENUM 


status number: 31
2
declaration_specifiers -> type_specifier declaration_specifiers 	1
IDENTIFIER * ( [ ; ) , 
declaration_specifiers -> type_specifier 	1
IDENTIFIER * ( [ ; ) , 


status number: 32
2
declaration_specifiers -> type_qualifier 	1
IDENTIFIER * ( [ ; ) , 
declaration_specifiers -> type_qualifier declaration_specifiers 	1
IDENTIFIER * ( [ ; ) , 


status number: 33
2
function_definition -> declarator compound_statement 	1
STATIC LONG $ INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT FLOAT STRUCT REGISTER UNION CONST CHAR * UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID ENUM 
function_definition -> declarator declaration_list compound_statement 	1
STATIC LONG $ INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT FLOAT STRUCT REGISTER UNION CONST CHAR * UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID ENUM 


status number: 34
1
type_specifier -> struct_or_union_specifier 	1
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; : [ ) , 


status number: 35
1
type_specifier -> enum_specifier 	1
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; : [ ) , 


status number: 36
1
declarator -> pointer direct_declarator 	1
; { SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC TYPEDEF CONST UNION EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ) = , : 


status number: 37
1
translation_unit -> external_declaration 	1
STATIC INT IDENTIFIER FLOAT SHORT SIGNED TYPE_NAME VOLATILE REGISTER STRUCT CONST UNION * CHAR UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID $ LONG ENUM 


status number: 38
1
direct_declarator -> ( declarator ) 	2
; { SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC TYPEDEF CONST UNION EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ ) = , : 


status number: 39
1
type_qualifier_list -> type_qualifier 	1
* VOLATILE ) CONST IDENTIFIER ( [ , 


status number: 40
1
pointer -> * pointer 	2
IDENTIFIER ( [ ) , 


status number: 41
3
pointer -> * type_qualifier_list 	2
IDENTIFIER ( [ ) , 
pointer -> * type_qualifier_list pointer 	2
IDENTIFIER ( [ ) , 
type_qualifier_list -> type_qualifier_list type_qualifier 	1
* VOLATILE ) CONST IDENTIFIER ( [ , 


status number: 42
2
enum_specifier -> ENUM IDENTIFIER { enumerator_list } 	2
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; : [ ) , 
enum_specifier -> ENUM IDENTIFIER 	2
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; : [ ) , 


status number: 43
1
enum_specifier -> ENUM { enumerator_list } 	2
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; : [ ) , 


status number: 44
2
struct_or_union_specifier -> struct_or_union IDENTIFIER 	2
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; : [ ) , 
struct_or_union_specifier -> struct_or_union IDENTIFIER { struct_declaration_list } 	2
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; : [ ) , 


status number: 45
1
struct_or_union_specifier -> struct_or_union { struct_declaration_list } 	2
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; : [ ) , 


status number: 46
1
translation_unit -> translation_unit external_declaration 	2
STATIC INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT FLOAT STRUCT REGISTER UNION CONST CHAR * UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID LONG $ ENUM 


status number: 47
1
declaration_specifiers -> storage_class_specifier declaration_specifiers 	2
IDENTIFIER * ( ; [ ) , 


status number: 48
3
direct_declarator -> direct_declarator ( ) 	2
; { SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC TYPEDEF CONST UNION EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ ) = , : 
direct_declarator -> direct_declarator ( identifier_list ) 	2
; { SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC TYPEDEF CONST UNION EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ ) = , : 
direct_declarator -> direct_declarator ( parameter_type_list ) 	2
; { SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC TYPEDEF CONST UNION EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ ) = , : 


status number: 49
2
direct_declarator -> direct_declarator [ ] 	2
; { SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC TYPEDEF CONST UNION EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ ) = , : 
direct_declarator -> direct_declarator [ constant_expression ] 	2
; { SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC TYPEDEF CONST UNION EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ ) = , : 


status number: 50
1
declaration -> declaration_specifiers ; 	2
DEC_OP LONG $ STATIC DEFAULT INT IDENTIFIER SHORT SIGNED TYPE_NAME VOLATILE FLOAT REGISTER STRUCT DO CONST UNION * CHAR IF UNSIGNED ( STRING_LITERAL TYPEDEF EXTERN AUTO DOUBLE RETURN VOID ENUM ; { - BREAK } WHILE GOTO CASE FOR CONTINUE SIZEOF INC_OP SWITCH CONSTANT & ~ + ! 


status number: 51
1
init_declarator_list -> init_declarator 	1
; , 


status number: 52
2
declaration -> declaration_specifiers init_declarator_list ; 	2
DEC_OP LONG $ STATIC DEFAULT INT IDENTIFIER SHORT SIGNED TYPE_NAME VOLATILE FLOAT REGISTER STRUCT DO CONST UNION * CHAR IF UNSIGNED ( STRING_LITERAL TYPEDEF EXTERN AUTO DOUBLE RETURN VOID ENUM ; { - BREAK } WHILE GOTO CASE FOR CONTINUE SIZEOF INC_OP SWITCH CONSTANT & ~ + ! 
init_declarator_list -> init_declarator_list , init_declarator 	1
; , 


status number: 53
4
function_definition -> declaration_specifiers declarator compound_statement 	2
LONG $ STATIC INT IDENTIFIER SHORT SIGNED TYPE_NAME VOLATILE FLOAT REGISTER STRUCT CONST UNION * CHAR UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID ENUM 
init_declarator -> declarator 	1
; 
function_definition -> declaration_specifiers declarator declaration_list compound_statement 	2
LONG $ STATIC INT IDENTIFIER SHORT SIGNED TYPE_NAME VOLATILE FLOAT REGISTER STRUCT CONST UNION * CHAR UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID ENUM 
init_declarator -> declarator = initializer 	1
; 


status number: 54
1
declaration_specifiers -> type_specifier declaration_specifiers 	2
IDENTIFIER * ( ; [ ) , 


status number: 55
1
declaration_specifiers -> type_qualifier declaration_specifiers 	2
IDENTIFIER * ( ; [ ) , 


status number: 56
4
compound_statement -> { statement_list } 	1
FOR ELSE } DEFAULT INT IDENTIFIER WHILE DEC_OP LONG $ STATIC VOLATILE TYPE_NAME SIGNED SHORT FLOAT REGISTER STRUCT DO CONST UNION * CHAR IF UNSIGNED ( STRING_LITERAL TYPEDEF EXTERN AUTO DOUBLE RETURN VOID ENUM GOTO CASE { ; CONTINUE - BREAK SIZEOF INC_OP SWITCH CONSTANT & ~ + ! 
compound_statement -> { declaration_list } 	1
FOR ELSE } DEFAULT INT IDENTIFIER WHILE DEC_OP LONG $ STATIC VOLATILE TYPE_NAME SIGNED SHORT FLOAT REGISTER STRUCT DO CONST UNION * CHAR IF UNSIGNED ( STRING_LITERAL TYPEDEF EXTERN AUTO DOUBLE RETURN VOID ENUM GOTO CASE { ; CONTINUE - BREAK SIZEOF INC_OP SWITCH CONSTANT & ~ + ! 
compound_statement -> { } 	1
FOR ELSE } DEFAULT INT IDENTIFIER WHILE DEC_OP LONG $ STATIC VOLATILE TYPE_NAME SIGNED SHORT FLOAT REGISTER STRUCT DO CONST UNION * CHAR IF UNSIGNED ( STRING_LITERAL TYPEDEF EXTERN AUTO DOUBLE RETURN VOID ENUM GOTO CASE { ; CONTINUE - BREAK SIZEOF INC_OP SWITCH CONSTANT & ~ + ! 
compound_statement -> { declaration_list statement_list } 	1
FOR ELSE } DEFAULT INT IDENTIFIER WHILE DEC_OP LONG $ STATIC VOLATILE TYPE_NAME SIGNED SHORT FLOAT REGISTER STRUCT DO CONST UNION * CHAR IF UNSIGNED ( STRING_LITERAL TYPEDEF EXTERN AUTO DOUBLE RETURN VOID ENUM GOTO CASE { ; CONTINUE - BREAK SIZEOF INC_OP SWITCH CONSTANT & ~ + ! 


status number: 57
1
function_definition -> declarator compound_statement 	2
LONG $ STATIC INT IDENTIFIER SHORT SIGNED TYPE_NAME VOLATILE FLOAT REGISTER STRUCT CONST UNION * CHAR UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID ENUM 


status number: 58
1
declaration_list -> declaration 	1
; { STRUCT REGISTER SHORT SIGNED TYPE_NAME VOLATILE STATIC STRING_LITERAL TYPEDEF DO CONST UNION EXTERN AUTO DOUBLE RETURN VOID * CHAR FLOAT DEFAULT IDENTIFIER INT DEC_OP LONG IF UNSIGNED ENUM } WHILE GOTO CASE BREAK - FOR CONTINUE SIZEOF INC_OP SWITCH CONSTANT ( & ~ + ! 


status number: 59
2
declaration -> declaration_specifiers init_declarator_list ; 	1
{ ; BREAK - } INT IDENTIFIER DEFAULT WHILE GOTO CASE FOR VOID RETURN CONTINUE UNION CONST DO SIZEOF INC_OP LONG DEC_OP TYPEDEF STRING_LITERAL UNSIGNED IF SWITCH CONSTANT ( & CHAR * ~ + ! REGISTER STRUCT SHORT TYPE_NAME SIGNED VOLATILE STATIC EXTERN AUTO DOUBLE FLOAT ENUM 
declaration -> declaration_specifiers ; 	1
{ ; BREAK - } INT IDENTIFIER DEFAULT WHILE GOTO CASE FOR VOID RETURN CONTINUE UNION CONST DO SIZEOF INC_OP LONG DEC_OP TYPEDEF STRING_LITERAL UNSIGNED IF SWITCH CONSTANT ( & CHAR * ~ + ! REGISTER STRUCT SHORT TYPE_NAME SIGNED VOLATILE STATIC EXTERN AUTO DOUBLE FLOAT ENUM 


status number: 60
2
function_definition -> declarator declaration_list compound_statement 	2
LONG $ STATIC INT IDENTIFIER SHORT SIGNED TYPE_NAME VOLATILE FLOAT REGISTER STRUCT CONST UNION * CHAR UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID ENUM 
declaration_list -> declaration_list declaration 	1
{ STRUCT REGISTER SHORT SIGNED TYPE_NAME VOLATILE STATIC TYPEDEF CONST UNION EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM 


status number: 61
6
declarator -> pointer direct_declarator 	2
; { VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ) = , : 
direct_declarator -> direct_declarator ( parameter_type_list ) 	1
( ; { [ VOLATILE SIGNED TYPE_NAME SHORT REGISTER STRUCT STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ) = , : 
direct_declarator -> direct_declarator [ ] 	1
( ; { [ VOLATILE SIGNED TYPE_NAME SHORT REGISTER STRUCT STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ) = , : 
direct_declarator -> direct_declarator [ constant_expression ] 	1
( ; { [ VOLATILE SIGNED TYPE_NAME SHORT REGISTER STRUCT STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ) = , : 
direct_declarator -> direct_declarator ( identifier_list ) 	1
( ; { [ VOLATILE SIGNED TYPE_NAME SHORT REGISTER STRUCT STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ) = , : 
direct_declarator -> direct_declarator ( ) 	1
( ; { [ VOLATILE SIGNED TYPE_NAME SHORT REGISTER STRUCT STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ) = , : 


status number: 62
1
direct_declarator -> ( declarator ) 	3
; { VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ ) = , : 


status number: 63
1
type_qualifier_list -> type_qualifier_list type_qualifier 	2
VOLATILE * CONST ) IDENTIFIER ( [ , 


status number: 64
1
pointer -> * type_qualifier_list pointer 	3
IDENTIFIER ( [ ) , 


status number: 65
1
enum_specifier -> ENUM IDENTIFIER { enumerator_list } 	3
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; : [ ) , 


status number: 66
2
enumerator -> IDENTIFIER = constant_expression 	1
} , 
enumerator -> IDENTIFIER 	1
} , 


status number: 67
2
enumerator_list -> enumerator_list , enumerator 	1
} , 
enum_specifier -> ENUM { enumerator_list } 	3
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; : [ ) , 


status number: 68
1
enumerator_list -> enumerator 	1
} , 


status number: 69
1
struct_or_union_specifier -> struct_or_union IDENTIFIER { struct_declaration_list } 	3
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; : [ ) , 


status number: 70
1
struct_declaration_list -> struct_declaration 	1
} DOUBLE SHORT SIGNED TYPE_NAME CHAR FLOAT VOID INT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 


status number: 71
2
specifier_qualifier_list -> type_specifier specifier_qualifier_list 	1
: * IDENTIFIER ( [ ) 
specifier_qualifier_list -> type_specifier 	1
: * IDENTIFIER ( [ ) 


status number: 72
2
specifier_qualifier_list -> type_qualifier 	1
: * IDENTIFIER ( [ ) 
specifier_qualifier_list -> type_qualifier specifier_qualifier_list 	1
: * IDENTIFIER ( [ ) 


status number: 73
2
struct_or_union_specifier -> struct_or_union { struct_declaration_list } 	3
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; : [ ) , 
struct_declaration_list -> struct_declaration_list struct_declaration 	1
} DOUBLE SHORT SIGNED TYPE_NAME CHAR FLOAT VOID INT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 


status number: 74
1
struct_declaration -> specifier_qualifier_list struct_declarator_list ; 	1
DOUBLE } FLOAT CHAR SIGNED TYPE_NAME SHORT VOID INT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 


status number: 75
1
identifier_list -> IDENTIFIER 	1
) , 


status number: 76
1
direct_declarator -> direct_declarator ( ) 	3
; { VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ ) = , : 


status number: 77
3
parameter_declaration -> declaration_specifiers declarator 	1
) , 
parameter_declaration -> declaration_specifiers abstract_declarator 	1
) , 
parameter_declaration -> declaration_specifiers 	1
) , 


status number: 78
2
identifier_list -> identifier_list , IDENTIFIER 	1
) , 
direct_declarator -> direct_declarator ( identifier_list ) 	3
; { VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ ) = , : 


status number: 79
1
direct_declarator -> direct_declarator ( parameter_type_list ) 	3
; { VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ ) = , : 


status number: 80
3
parameter_type_list -> parameter_list 	1
) 
parameter_type_list -> parameter_list , ELLIPSIS 	1
) 
parameter_list -> parameter_list , parameter_declaration 	1
) , 


status number: 81
1
parameter_list -> parameter_declaration 	1
) , 


status number: 82
1
unary_expression -> DEC_OP unary_expression 	1
? OR_OP ] | < MUL_ASSIGN EQ_OP GE_OP MOD_ASSIGN * ) LEFT_ASSIGN DIV_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 


status number: 83
1
primary_expression -> IDENTIFIER 	1
? OR_OP ] | < MUL_ASSIGN EQ_OP * . ( DIV_ASSIGN ) LEFT_ASSIGN GE_OP MOD_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 


status number: 84
1
primary_expression -> CONSTANT 	1
? OR_OP ] | < MUL_ASSIGN EQ_OP * . ( DIV_ASSIGN ) LEFT_ASSIGN GE_OP MOD_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 


status number: 85
1
primary_expression -> STRING_LITERAL 	1
? OR_OP ] | < MUL_ASSIGN EQ_OP * . ( DIV_ASSIGN ) LEFT_ASSIGN GE_OP MOD_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 


status number: 86
2
cast_expression -> ( type_name ) cast_expression 	1
OR_OP ? ] MUL_ASSIGN EQ_OP | < : * XOR_ASSIGN ; LEFT_ASSIGN ) = ADD_ASSIGN } , GE_OP MOD_ASSIGN DIV_ASSIGN RIGHT_ASSIGN SUB_ASSIGN AND_ASSIGN OR_ASSIGN / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
primary_expression -> ( expression ) 	1
? OR_OP ] | < MUL_ASSIGN EQ_OP * . ( DIV_ASSIGN ) LEFT_ASSIGN GE_OP MOD_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 


status number: 87
1
direct_declarator -> direct_declarator [ ] 	3
; { VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ ) = , : 


status number: 88
1
unary_expression -> INC_OP unary_expression 	1
? OR_OP ] | < MUL_ASSIGN EQ_OP GE_OP MOD_ASSIGN * ) LEFT_ASSIGN DIV_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 


status number: 89
2
unary_expression -> SIZEOF unary_expression 	1
? OR_OP ] | < MUL_ASSIGN EQ_OP GE_OP MOD_ASSIGN * ) LEFT_ASSIGN DIV_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
unary_expression -> SIZEOF ( type_name ) 	1
? OR_OP ] | < MUL_ASSIGN EQ_OP GE_OP MOD_ASSIGN * ) LEFT_ASSIGN DIV_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 


status number: 90
1
unary_operator -> & 	1
& ( INC_OP SIZEOF CONSTANT - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 


status number: 91
1
unary_operator -> * 	1
& ( INC_OP SIZEOF CONSTANT - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 


status number: 92
1
unary_operator -> + 	1
& ( INC_OP SIZEOF CONSTANT - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 


status number: 93
1
unary_operator -> - 	1
& ( INC_OP SIZEOF CONSTANT - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 


status number: 94
1
unary_operator -> ~ 	1
& ( INC_OP SIZEOF CONSTANT - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 


status number: 95
1
unary_operator -> ! 	1
& ( INC_OP SIZEOF CONSTANT - DEC_OP IDENTIFIER STRING_LITERAL * ~ + ! 


status number: 96
1
postfix_expression -> primary_expression 	1
? OR_OP ] MUL_ASSIGN EQ_OP | < * . ( [ PTR_OP INC_OP DEC_OP ) LEFT_ASSIGN DIV_ASSIGN GE_OP MOD_ASSIGN } ADD_ASSIGN = SUB_ASSIGN RIGHT_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 


status number: 97
1
cast_expression -> unary_expression 	1
OR_OP ? ] EQ_OP MUL_ASSIGN | < GE_OP MOD_ASSIGN : * LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 


status number: 98
8
postfix_expression -> postfix_expression ( ) 	1
? OR_OP ] MUL_ASSIGN EQ_OP | < * . ( [ PTR_OP INC_OP DEC_OP ) LEFT_ASSIGN DIV_ASSIGN GE_OP MOD_ASSIGN } ADD_ASSIGN = SUB_ASSIGN RIGHT_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
postfix_expression -> postfix_expression . IDENTIFIER 	1
? OR_OP ] MUL_ASSIGN EQ_OP | < * . ( [ PTR_OP INC_OP DEC_OP ) LEFT_ASSIGN DIV_ASSIGN GE_OP MOD_ASSIGN } ADD_ASSIGN = SUB_ASSIGN RIGHT_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
postfix_expression -> postfix_expression DEC_OP 	1
? OR_OP ] MUL_ASSIGN EQ_OP | < * . ( [ PTR_OP INC_OP DEC_OP ) LEFT_ASSIGN DIV_ASSIGN GE_OP MOD_ASSIGN } ADD_ASSIGN = SUB_ASSIGN RIGHT_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
unary_expression -> postfix_expression 	1
? OR_OP ] | < MUL_ASSIGN EQ_OP GE_OP MOD_ASSIGN * ) LEFT_ASSIGN DIV_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
postfix_expression -> postfix_expression ( argument_expression_list ) 	1
? OR_OP ] MUL_ASSIGN EQ_OP | < * . ( [ PTR_OP INC_OP DEC_OP ) LEFT_ASSIGN DIV_ASSIGN GE_OP MOD_ASSIGN } ADD_ASSIGN = SUB_ASSIGN RIGHT_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
postfix_expression -> postfix_expression [ expression ] 	1
? OR_OP ] MUL_ASSIGN EQ_OP | < * . ( [ PTR_OP INC_OP DEC_OP ) LEFT_ASSIGN DIV_ASSIGN GE_OP MOD_ASSIGN } ADD_ASSIGN = SUB_ASSIGN RIGHT_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
postfix_expression -> postfix_expression INC_OP 	1
? OR_OP ] MUL_ASSIGN EQ_OP | < * . ( [ PTR_OP INC_OP DEC_OP ) LEFT_ASSIGN DIV_ASSIGN GE_OP MOD_ASSIGN } ADD_ASSIGN = SUB_ASSIGN RIGHT_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	1
? OR_OP ] MUL_ASSIGN EQ_OP | < * . ( [ PTR_OP INC_OP DEC_OP ) LEFT_ASSIGN DIV_ASSIGN GE_OP MOD_ASSIGN } ADD_ASSIGN = SUB_ASSIGN RIGHT_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 


status number: 99
1
multiplicative_expression -> cast_expression 	1
? OR_OP / ] % | < EQ_OP * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 


status number: 100
1
unary_expression -> unary_operator cast_expression 	1
? OR_OP ] | < MUL_ASSIGN EQ_OP GE_OP MOD_ASSIGN * ) LEFT_ASSIGN DIV_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 


status number: 101
4
multiplicative_expression -> multiplicative_expression / cast_expression 	1
? OR_OP / ] % | < EQ_OP * ; ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 
additive_expression -> multiplicative_expression 	1
OR_OP ? ] - EQ_OP | < ; + ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 
multiplicative_expression -> multiplicative_expression * cast_expression 	1
? OR_OP / ] % | < EQ_OP * ; ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 
multiplicative_expression -> multiplicative_expression % cast_expression 	1
? OR_OP / ] % | < EQ_OP * ; ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 


status number: 102
1
constant_expression -> conditional_expression 	1
} ] : ; , 


status number: 103
3
shift_expression -> additive_expression 	1
? OR_OP ] | < EQ_OP ; LEFT_OP RIGHT_OP ) : } , LE_OP > GE_OP NE_OP & ^ AND_OP 
additive_expression -> additive_expression + multiplicative_expression 	1
OR_OP ? ] - EQ_OP | < ; + ) : } , LE_OP > GE_OP NE_OP & ^ AND_OP 
additive_expression -> additive_expression - multiplicative_expression 	1
OR_OP ? ] - EQ_OP | < ; + ) : } , LE_OP > GE_OP NE_OP & ^ AND_OP 


status number: 104
1
direct_declarator -> direct_declarator [ constant_expression ] 	3
; { VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC TYPEDEF UNION CONST EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ ) = , : 


status number: 105
3
shift_expression -> shift_expression RIGHT_OP additive_expression 	1
? OR_OP ] | < EQ_OP ; LEFT_OP RIGHT_OP ) : } , NE_OP & ^ AND_OP 
relational_expression -> shift_expression 	1
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	1
? OR_OP ] | < EQ_OP ; LEFT_OP RIGHT_OP ) : } , NE_OP & ^ AND_OP 


status number: 106
5
equality_expression -> relational_expression 	1
? OR_OP NE_OP } ] EQ_OP ; ) : , & ^ | AND_OP 
relational_expression -> relational_expression < shift_expression 	1
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , & ^ AND_OP 
relational_expression -> relational_expression > shift_expression 	1
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , & ^ AND_OP 
relational_expression -> relational_expression LE_OP shift_expression 	1
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , & ^ AND_OP 
relational_expression -> relational_expression GE_OP shift_expression 	1
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , & ^ AND_OP 


status number: 107
3
equality_expression -> equality_expression NE_OP relational_expression 	1
? OR_OP NE_OP } ] EQ_OP ; ) : , ^ | AND_OP 
and_expression -> equality_expression 	1
OR_OP ? } ] & ; ) : , ^ | AND_OP 
equality_expression -> equality_expression EQ_OP relational_expression 	1
? OR_OP NE_OP } ] EQ_OP ; ) : , ^ | AND_OP 


status number: 108
2
and_expression -> and_expression & equality_expression 	1
OR_OP ? } ] & ; ) : , | AND_OP 
exclusive_or_expression -> and_expression 	1
? OR_OP } ] ^ ; ) : , | AND_OP 


status number: 109
2
inclusive_or_expression -> exclusive_or_expression 	1
OR_OP ? } ] , | ; ) : AND_OP 
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	1
? OR_OP } ] ^ ; ) : , AND_OP 


status number: 110
2
logical_and_expression -> inclusive_or_expression 	1
? OR_OP } ] ) AND_OP ; : , 
inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression 	1
OR_OP ? } ] , | ; ) : 


status number: 111
2
logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression 	1
? OR_OP } ] ) AND_OP ; : , 
logical_or_expression -> logical_and_expression 	1
? OR_OP } ] ; ) : , 


status number: 112
3
conditional_expression -> logical_or_expression ? expression : conditional_expression 	1
} ] ; ) : , 
conditional_expression -> logical_or_expression 	1
} ] ; ) : , 
logical_or_expression -> logical_or_expression OR_OP logical_and_expression 	1
? OR_OP } ] ; ) : , 


status number: 113
1
init_declarator_list -> init_declarator_list , init_declarator 	2
; , 


status number: 114
1
declaration -> declaration_specifiers init_declarator_list ; 	3
STATIC DEC_OP LONG $ DEFAULT INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT FLOAT STRUCT REGISTER DO UNION CONST CHAR * IF UNSIGNED ( STRING_LITERAL TYPEDEF EXTERN AUTO DOUBLE RETURN VOID ENUM { ; BREAK - } WHILE GOTO CASE FOR CONTINUE SIZEOF INC_OP SWITCH CONSTANT & ~ + ! 


status number: 115
1
init_declarator -> declarator = initializer 	2
; , 


status number: 116
1
function_definition -> declaration_specifiers declarator compound_statement 	3
STATIC LONG $ INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT FLOAT STRUCT REGISTER UNION CONST CHAR * UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID ENUM 


status number: 117
2
function_definition -> declaration_specifiers declarator declaration_list compound_statement 	3
STATIC LONG $ INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT FLOAT STRUCT REGISTER UNION CONST CHAR * UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID ENUM 
declaration_list -> declaration_list declaration 	1
{ STRUCT REGISTER SHORT SIGNED TYPE_NAME VOLATILE STATIC TYPEDEF CONST UNION EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM 


status number: 118
2
labeled_statement -> IDENTIFIER : statement 	1
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
primary_expression -> IDENTIFIER 	1
LEFT_ASSIGN DIV_ASSIGN MOD_ASSIGN = ADD_ASSIGN MUL_ASSIGN SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN AND_ASSIGN OR_ASSIGN . ( 


status number: 119
1
jump_statement -> CONTINUE ; 	1
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 120
1
compound_statement -> { } 	2
} FOR ELSE WHILE DEFAULT INT IDENTIFIER STATIC DEC_OP LONG $ VOLATILE SIGNED TYPE_NAME SHORT FLOAT STRUCT REGISTER DO UNION CONST CHAR * IF UNSIGNED ( STRING_LITERAL TYPEDEF EXTERN AUTO DOUBLE RETURN VOID ENUM GOTO CASE ; { CONTINUE BREAK - SIZEOF INC_OP SWITCH CONSTANT & ~ + ! 


status number: 121
1
expression_statement -> ; 	1
BREAK - } WHILE SIZEOF CONSTANT { ; INC_OP ( DEC_OP DEFAULT IDENTIFIER & STRING_LITERAL * ~ + ! CONTINUE ) FOR ELSE GOTO CASE RETURN DO IF SWITCH 


status number: 122
2
selection_statement -> IF ( expression ) statement ELSE statement 	1
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
selection_statement -> IF ( expression ) statement 	1
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 123
1
labeled_statement -> CASE constant_expression : statement 	1
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 124
1
labeled_statement -> DEFAULT : statement 	1
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 125
1
selection_statement -> SWITCH ( expression ) statement 	1
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 126
1
iteration_statement -> WHILE ( expression ) statement 	1
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 127
1
iteration_statement -> DO statement WHILE ( expression ) ; 	1
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 128
2
iteration_statement -> FOR ( expression_statement expression_statement ) statement 	1
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
iteration_statement -> FOR ( expression_statement expression_statement expression ) statement 	1
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 129
1
jump_statement -> GOTO IDENTIFIER ; 	1
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 130
1
jump_statement -> BREAK ; 	1
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 131
2
jump_statement -> RETURN ; 	1
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
jump_statement -> RETURN expression ; 	1
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 132
2
assignment_expression -> unary_expression assignment_operator assignment_expression 	1
; ) } ] : , 
cast_expression -> unary_expression 	1
OR_OP ? ; EQ_OP < : * ) ] } , 


status number: 133
1
expression -> assignment_expression 	1
; , ) ] : 


status number: 134
2
expression_statement -> expression ; 	1
BREAK - } WHILE SIZEOF CONSTANT { ; INC_OP ( DEC_OP DEFAULT IDENTIFIER & STRING_LITERAL * ~ + ! CONTINUE ) FOR ELSE GOTO CASE RETURN DO IF SWITCH 
expression -> expression , assignment_expression 	1
; , 


status number: 135
1
statement -> expression_statement 	1
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 136
1
assignment_expression -> conditional_expression 	1
; ) } ] : , 


status number: 137
1
statement_list -> statement 	1
} FOR GOTO WHILE IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 138
1
statement -> compound_statement 	1
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 139
2
compound_statement -> { statement_list } 	2
} FOR ELSE WHILE DEFAULT INT IDENTIFIER STATIC DEC_OP LONG $ VOLATILE SIGNED TYPE_NAME SHORT FLOAT STRUCT REGISTER DO UNION CONST CHAR * IF UNSIGNED ( STRING_LITERAL TYPEDEF EXTERN AUTO DOUBLE RETURN VOID ENUM GOTO CASE ; { CONTINUE BREAK - SIZEOF INC_OP SWITCH CONSTANT & ~ + ! 
statement_list -> statement_list statement 	1
} FOR GOTO WHILE IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 140
3
compound_statement -> { declaration_list } 	2
} FOR ELSE WHILE DEFAULT INT IDENTIFIER STATIC DEC_OP LONG $ VOLATILE SIGNED TYPE_NAME SHORT FLOAT STRUCT REGISTER DO UNION CONST CHAR * IF UNSIGNED ( STRING_LITERAL TYPEDEF EXTERN AUTO DOUBLE RETURN VOID ENUM GOTO CASE ; { CONTINUE BREAK - SIZEOF INC_OP SWITCH CONSTANT & ~ + ! 
compound_statement -> { declaration_list statement_list } 	2
} FOR ELSE WHILE DEFAULT INT IDENTIFIER STATIC DEC_OP LONG $ VOLATILE SIGNED TYPE_NAME SHORT FLOAT STRUCT REGISTER DO UNION CONST CHAR * IF UNSIGNED ( STRING_LITERAL TYPEDEF EXTERN AUTO DOUBLE RETURN VOID ENUM GOTO CASE ; { CONTINUE BREAK - SIZEOF INC_OP SWITCH CONSTANT & ~ + ! 
declaration_list -> declaration_list declaration 	1
} STRUCT REGISTER SHORT SIGNED TYPE_NAME VOLATILE STATIC STRING_LITERAL TYPEDEF DO CONST UNION EXTERN AUTO DOUBLE RETURN VOID * CHAR FLOAT DEFAULT IDENTIFIER INT DEC_OP LONG IF UNSIGNED ENUM WHILE GOTO CASE { ; BREAK - FOR CONTINUE SIZEOF INC_OP SWITCH CONSTANT ( & ~ + ! 


status number: 141
1
statement -> jump_statement 	1
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 142
1
statement -> labeled_statement 	1
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 143
1
statement -> selection_statement 	1
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 144
1
statement -> iteration_statement 	1
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 145
2
init_declarator -> declarator 	1
; , 
init_declarator -> declarator = initializer 	1
; , 


status number: 146
1
function_definition -> declarator declaration_list compound_statement 	3
STATIC LONG $ INT IDENTIFIER VOLATILE SIGNED TYPE_NAME SHORT FLOAT STRUCT REGISTER UNION CONST CHAR * UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID ENUM 


status number: 147
1
declaration_list -> declaration_list declaration 	2
; { STRUCT REGISTER VOLATILE SIGNED TYPE_NAME SHORT STATIC STRING_LITERAL TYPEDEF DO UNION CONST EXTERN AUTO DOUBLE RETURN VOID * CHAR FLOAT IDENTIFIER DEFAULT INT DEC_OP LONG IF UNSIGNED ENUM } WHILE GOTO CASE - BREAK FOR CONTINUE SIZEOF INC_OP SWITCH CONSTANT ( & ~ + ! 


status number: 148
2
enumerator_list -> enumerator_list , enumerator 	1
} , 
enum_specifier -> ENUM IDENTIFIER { enumerator_list } 	4
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; : [ ) , 


status number: 149
1
enumerator -> IDENTIFIER = constant_expression 	2
} , 


status number: 150
1
enumerator_list -> enumerator_list , enumerator 	2
} , 


status number: 151
1
enum_specifier -> ENUM { enumerator_list } 	4
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; : [ ) , 


status number: 152
2
struct_or_union_specifier -> struct_or_union IDENTIFIER { struct_declaration_list } 	4
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; : [ ) , 
struct_declaration_list -> struct_declaration_list struct_declaration 	1
} DOUBLE SHORT SIGNED TYPE_NAME CHAR FLOAT VOID INT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 


status number: 153
1
specifier_qualifier_list -> type_specifier specifier_qualifier_list 	2
* : IDENTIFIER ( [ ) 


status number: 154
1
specifier_qualifier_list -> type_qualifier specifier_qualifier_list 	2
* : IDENTIFIER ( [ ) 


status number: 155
1
struct_or_union_specifier -> struct_or_union { struct_declaration_list } 	4
SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID CHAR * FLOAT INT IDENTIFIER LONG UNSIGNED ENUM ( ; : [ ) , 


status number: 156
1
struct_declaration_list -> struct_declaration_list struct_declaration 	2
DOUBLE } FLOAT CHAR SIGNED TYPE_NAME SHORT VOID INT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 


status number: 157
1
struct_declarator -> : constant_expression 	1
; , 


status number: 158
1
struct_declarator_list -> struct_declarator 	1
; , 


status number: 159
2
struct_declaration -> specifier_qualifier_list struct_declarator_list ; 	2
} DOUBLE SHORT SIGNED TYPE_NAME CHAR FLOAT VOID INT LONG UNSIGNED ENUM VOLATILE CONST UNION STRUCT 
struct_declarator_list -> struct_declarator_list , struct_declarator 	1
; , 


status number: 160
2
struct_declarator -> declarator : constant_expression 	1
; , 
struct_declarator -> declarator 	1
; , 


status number: 161
4
direct_abstract_declarator -> ( ) 	1
( [ ) , 
direct_declarator -> ( declarator ) 	1
( [ ) , 
direct_abstract_declarator -> ( parameter_type_list ) 	1
( [ ) , 
direct_abstract_declarator -> ( abstract_declarator ) 	1
( [ ) , 


status number: 162
2
direct_abstract_declarator -> [ ] 	1
( [ ) , 
direct_abstract_declarator -> [ constant_expression ] 	1
( [ ) , 


status number: 163
1
parameter_declaration -> declaration_specifiers declarator 	2
) , 


status number: 164
5
abstract_declarator -> direct_abstract_declarator 	1
) , 
direct_abstract_declarator -> direct_abstract_declarator [ constant_expression ] 	1
( [ ) , 
direct_abstract_declarator -> direct_abstract_declarator [ ] 	1
( [ ) , 
direct_abstract_declarator -> direct_abstract_declarator ( parameter_type_list ) 	1
( [ ) , 
direct_abstract_declarator -> direct_abstract_declarator ( ) 	1
( [ ) , 


status number: 165
3
declarator -> pointer direct_declarator 	1
) , 
abstract_declarator -> pointer direct_abstract_declarator 	1
) , 
abstract_declarator -> pointer 	1
) , 


status number: 166
1
parameter_declaration -> declaration_specifiers abstract_declarator 	2
) , 


status number: 167
1
direct_declarator -> direct_declarator ( identifier_list ) 	4
; { SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC TYPEDEF CONST UNION EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ ) = , : 


status number: 168
1
identifier_list -> identifier_list , IDENTIFIER 	2
) , 


status number: 169
1
direct_declarator -> direct_declarator ( parameter_type_list ) 	4
; { SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC TYPEDEF CONST UNION EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ ) = , : 


status number: 170
2
parameter_type_list -> parameter_list , ELLIPSIS 	2
) 
parameter_list -> parameter_list , parameter_declaration 	2
) , 


status number: 171
1
primary_expression -> ( expression ) 	1
. ( ? OR_OP ] MUL_ASSIGN EQ_OP | < GE_OP MOD_ASSIGN * LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 


status number: 172
1
unary_expression -> DEC_OP unary_expression 	2
? OR_OP ] MUL_ASSIGN EQ_OP | < * GE_OP MOD_ASSIGN LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 


status number: 173
2
primary_expression -> ( expression ) 	2
? OR_OP ] MUL_ASSIGN EQ_OP | < * . ( DIV_ASSIGN ) LEFT_ASSIGN GE_OP MOD_ASSIGN } = ADD_ASSIGN RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
expression -> expression , assignment_expression 	1
) , 


status number: 174
1
cast_expression -> ( type_name ) cast_expression 	2
OR_OP ? ] | < MUL_ASSIGN EQ_OP * : XOR_ASSIGN ; LEFT_ASSIGN ) ADD_ASSIGN = } , MOD_ASSIGN GE_OP DIV_ASSIGN RIGHT_ASSIGN SUB_ASSIGN AND_ASSIGN OR_ASSIGN / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 


status number: 175
2
type_name -> specifier_qualifier_list 	1
) 
type_name -> specifier_qualifier_list abstract_declarator 	1
) 


status number: 176
1
unary_expression -> INC_OP unary_expression 	2
? OR_OP ] MUL_ASSIGN EQ_OP | < * GE_OP MOD_ASSIGN LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 


status number: 177
2
unary_expression -> SIZEOF ( type_name ) 	2
? OR_OP ] MUL_ASSIGN EQ_OP | < * GE_OP MOD_ASSIGN LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
primary_expression -> ( expression ) 	1
. ( ? OR_OP ] MUL_ASSIGN EQ_OP | < GE_OP MOD_ASSIGN * LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 


status number: 178
1
unary_expression -> SIZEOF unary_expression 	2
? OR_OP ] MUL_ASSIGN EQ_OP | < * GE_OP MOD_ASSIGN LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 


status number: 179
1
postfix_expression -> postfix_expression DEC_OP 	2
? OR_OP ] | < MUL_ASSIGN EQ_OP * . ( [ PTR_OP INC_OP DEC_OP LEFT_ASSIGN ) DIV_ASSIGN GE_OP MOD_ASSIGN = ADD_ASSIGN } SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 


status number: 180
1
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	2
? OR_OP ] | < MUL_ASSIGN EQ_OP * . ( [ PTR_OP INC_OP DEC_OP LEFT_ASSIGN ) DIV_ASSIGN GE_OP MOD_ASSIGN = ADD_ASSIGN } SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 


status number: 181
2
postfix_expression -> postfix_expression ( ) 	2
? OR_OP ] | < MUL_ASSIGN EQ_OP * . ( [ PTR_OP INC_OP DEC_OP LEFT_ASSIGN ) DIV_ASSIGN GE_OP MOD_ASSIGN = ADD_ASSIGN } SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
postfix_expression -> postfix_expression ( argument_expression_list ) 	2
? OR_OP ] | < MUL_ASSIGN EQ_OP * . ( [ PTR_OP INC_OP DEC_OP LEFT_ASSIGN ) DIV_ASSIGN GE_OP MOD_ASSIGN = ADD_ASSIGN } SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 


status number: 182
1
postfix_expression -> postfix_expression [ expression ] 	2
? OR_OP ] | < MUL_ASSIGN EQ_OP * . ( [ PTR_OP INC_OP DEC_OP LEFT_ASSIGN ) DIV_ASSIGN GE_OP MOD_ASSIGN = ADD_ASSIGN } SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 


status number: 183
1
postfix_expression -> postfix_expression . IDENTIFIER 	2
? OR_OP ] | < MUL_ASSIGN EQ_OP * . ( [ PTR_OP INC_OP DEC_OP LEFT_ASSIGN ) DIV_ASSIGN GE_OP MOD_ASSIGN = ADD_ASSIGN } SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 


status number: 184
1
postfix_expression -> postfix_expression INC_OP 	2
? OR_OP ] | < MUL_ASSIGN EQ_OP * . ( [ PTR_OP INC_OP DEC_OP LEFT_ASSIGN ) DIV_ASSIGN GE_OP MOD_ASSIGN = ADD_ASSIGN } SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 


status number: 185
1
unary_expression -> unary_operator cast_expression 	2
? OR_OP ] MUL_ASSIGN EQ_OP | < * GE_OP MOD_ASSIGN LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 


status number: 186
1
multiplicative_expression -> multiplicative_expression * cast_expression 	2
/ ? OR_OP % ] EQ_OP | < * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 


status number: 187
1
multiplicative_expression -> multiplicative_expression / cast_expression 	2
/ ? OR_OP % ] EQ_OP | < * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 


status number: 188
1
multiplicative_expression -> multiplicative_expression % cast_expression 	2
/ ? OR_OP % ] EQ_OP | < * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 


status number: 189
1
additive_expression -> additive_expression + multiplicative_expression 	2
OR_OP ? - ] | < EQ_OP + ; ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 


status number: 190
1
additive_expression -> additive_expression - multiplicative_expression 	2
OR_OP ? - ] | < EQ_OP + ; ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 


status number: 191
1
direct_declarator -> direct_declarator [ constant_expression ] 	4
; { SHORT SIGNED TYPE_NAME VOLATILE STRUCT REGISTER STATIC TYPEDEF CONST UNION EXTERN AUTO DOUBLE VOID CHAR FLOAT INT LONG UNSIGNED ENUM ( [ ) = , : 


status number: 192
1
shift_expression -> shift_expression LEFT_OP additive_expression 	2
? OR_OP ] EQ_OP | < LEFT_OP ; RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP 


status number: 193
1
shift_expression -> shift_expression RIGHT_OP additive_expression 	2
? OR_OP ] EQ_OP | < LEFT_OP ; RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP 


status number: 194
1
relational_expression -> relational_expression > shift_expression 	2
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP 


status number: 195
1
relational_expression -> relational_expression < shift_expression 	2
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP 


status number: 196
1
relational_expression -> relational_expression LE_OP shift_expression 	2
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP 


status number: 197
1
relational_expression -> relational_expression GE_OP shift_expression 	2
OR_OP ? LE_OP ] | < EQ_OP > GE_OP ; ) : } , NE_OP & ^ AND_OP 


status number: 198
1
equality_expression -> equality_expression EQ_OP relational_expression 	2
NE_OP ? OR_OP ] } EQ_OP ; ) : , & ^ | AND_OP 


status number: 199
1
equality_expression -> equality_expression NE_OP relational_expression 	2
NE_OP ? OR_OP ] } EQ_OP ; ) : , & ^ | AND_OP 


status number: 200
1
and_expression -> and_expression & equality_expression 	2
OR_OP ? ] } & ; ) : , ^ | AND_OP 


status number: 201
1
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	2
? OR_OP ] } ^ ; ) : , | AND_OP 


status number: 202
1
inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression 	2
OR_OP ? ] } | , ; ) : AND_OP 


status number: 203
1
logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression 	2
? OR_OP ] } AND_OP ) ; : , 


status number: 204
1
conditional_expression -> logical_or_expression ? expression : conditional_expression 	2
] } ; ) : , 


status number: 205
1
logical_or_expression -> logical_or_expression OR_OP logical_and_expression 	2
OR_OP ? ] } ; ) : , 


status number: 206
1
init_declarator_list -> init_declarator_list , init_declarator 	3
; , 


status number: 207
2
initializer -> { initializer_list } 	1
} , ; 
initializer -> { initializer_list , } 	1
} , ; 


status number: 208
1
initializer -> assignment_expression 	1
} , ; 


status number: 209
1
init_declarator -> declarator = initializer 	3
; , 


status number: 210
1
function_definition -> declaration_specifiers declarator declaration_list compound_statement 	4
LONG $ STATIC INT IDENTIFIER SHORT SIGNED TYPE_NAME VOLATILE FLOAT REGISTER STRUCT CONST UNION * CHAR UNSIGNED ( TYPEDEF EXTERN AUTO DOUBLE VOID ENUM 


status number: 211
1
labeled_statement -> IDENTIFIER : statement 	2
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 212
1
jump_statement -> CONTINUE ; 	2
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 213
2
selection_statement -> IF ( expression ) statement ELSE statement 	2
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
selection_statement -> IF ( expression ) statement 	2
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 214
1
labeled_statement -> CASE constant_expression : statement 	2
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 215
1
labeled_statement -> DEFAULT : statement 	2
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 216
1
selection_statement -> SWITCH ( expression ) statement 	2
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 217
1
iteration_statement -> WHILE ( expression ) statement 	2
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 218
1
iteration_statement -> DO statement WHILE ( expression ) ; 	2
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 219
2
iteration_statement -> FOR ( expression_statement expression_statement ) statement 	2
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
iteration_statement -> FOR ( expression_statement expression_statement expression ) statement 	2
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 220
1
jump_statement -> GOTO IDENTIFIER ; 	2
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 221
1
jump_statement -> BREAK ; 	2
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 222
1
jump_statement -> RETURN ; 	2
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 223
2
jump_statement -> RETURN expression ; 	2
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
expression -> expression , assignment_expression 	1
; , 


status number: 224
1
assignment_operator -> LEFT_ASSIGN 	1
SIZEOF CONSTANT - INC_OP ( DEC_OP IDENTIFIER & STRING_LITERAL * ~ + ! 


status number: 225
1
assignment_operator -> MOD_ASSIGN 	1
SIZEOF CONSTANT - INC_OP ( DEC_OP IDENTIFIER & STRING_LITERAL * ~ + ! 


status number: 226
1
assignment_operator -> MUL_ASSIGN 	1
SIZEOF CONSTANT - INC_OP ( DEC_OP IDENTIFIER & STRING_LITERAL * ~ + ! 


status number: 227
1
assignment_operator -> ADD_ASSIGN 	1
SIZEOF CONSTANT - INC_OP ( DEC_OP IDENTIFIER & STRING_LITERAL * ~ + ! 


status number: 228
1
assignment_operator -> = 	1
SIZEOF CONSTANT - INC_OP ( DEC_OP IDENTIFIER & STRING_LITERAL * ~ + ! 


status number: 229
1
assignment_operator -> DIV_ASSIGN 	1
SIZEOF CONSTANT - INC_OP ( DEC_OP IDENTIFIER & STRING_LITERAL * ~ + ! 


status number: 230
1
assignment_operator -> SUB_ASSIGN 	1
SIZEOF CONSTANT - INC_OP ( DEC_OP IDENTIFIER & STRING_LITERAL * ~ + ! 


status number: 231
1
assignment_operator -> RIGHT_ASSIGN 	1
SIZEOF CONSTANT - INC_OP ( DEC_OP IDENTIFIER & STRING_LITERAL * ~ + ! 


status number: 232
1
assignment_operator -> AND_ASSIGN 	1
SIZEOF CONSTANT - INC_OP ( DEC_OP IDENTIFIER & STRING_LITERAL * ~ + ! 


status number: 233
1
assignment_operator -> XOR_ASSIGN 	1
SIZEOF CONSTANT - INC_OP ( DEC_OP IDENTIFIER & STRING_LITERAL * ~ + ! 


status number: 234
1
assignment_operator -> OR_ASSIGN 	1
SIZEOF CONSTANT - INC_OP ( DEC_OP IDENTIFIER & STRING_LITERAL * ~ + ! 


status number: 235
1
assignment_expression -> unary_expression assignment_operator assignment_expression 	2
; ) ] } : , 


status number: 236
1
expression -> expression , assignment_expression 	2
; , ) ] : 


status number: 237
1
expression_statement -> expression ; 	2
} BREAK - WHILE CONSTANT SIZEOF { ; ( INC_OP DEC_OP DEFAULT IDENTIFIER & STRING_LITERAL * ~ + ! CONTINUE ) FOR ELSE GOTO CASE RETURN DO IF SWITCH 


status number: 238
1
compound_statement -> { statement_list } 	3
FOR ELSE } DEFAULT INT IDENTIFIER WHILE DEC_OP LONG $ STATIC VOLATILE TYPE_NAME SIGNED SHORT FLOAT REGISTER STRUCT DO CONST UNION * CHAR IF UNSIGNED ( STRING_LITERAL TYPEDEF EXTERN AUTO DOUBLE RETURN VOID ENUM GOTO CASE { ; CONTINUE - BREAK SIZEOF INC_OP SWITCH CONSTANT & ~ + ! 


status number: 239
1
statement_list -> statement_list statement 	2
FOR } IDENTIFIER DEFAULT WHILE GOTO CASE ; { RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 240
1
compound_statement -> { declaration_list } 	3
FOR ELSE } DEFAULT INT IDENTIFIER WHILE DEC_OP LONG $ STATIC VOLATILE TYPE_NAME SIGNED SHORT FLOAT REGISTER STRUCT DO CONST UNION * CHAR IF UNSIGNED ( STRING_LITERAL TYPEDEF EXTERN AUTO DOUBLE RETURN VOID ENUM GOTO CASE { ; CONTINUE - BREAK SIZEOF INC_OP SWITCH CONSTANT & ~ + ! 


status number: 241
2
compound_statement -> { declaration_list statement_list } 	3
FOR ELSE } DEFAULT INT IDENTIFIER WHILE DEC_OP LONG $ STATIC VOLATILE TYPE_NAME SIGNED SHORT FLOAT REGISTER STRUCT DO CONST UNION * CHAR IF UNSIGNED ( STRING_LITERAL TYPEDEF EXTERN AUTO DOUBLE RETURN VOID ENUM GOTO CASE { ; CONTINUE - BREAK SIZEOF INC_OP SWITCH CONSTANT & ~ + ! 
statement_list -> statement_list statement 	1
} FOR GOTO WHILE IDENTIFIER DEFAULT CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 242
1
enum_specifier -> ENUM IDENTIFIER { enumerator_list } 	5
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; : [ ) , 


status number: 243
1
enumerator -> IDENTIFIER = constant_expression 	3
} , 


status number: 244
1
enumerator_list -> enumerator_list , enumerator 	3
} , 


status number: 245
1
struct_or_union_specifier -> struct_or_union IDENTIFIER { struct_declaration_list } 	5
VOLATILE SIGNED TYPE_NAME SHORT STRUCT REGISTER STATIC CONST UNION TYPEDEF EXTERN AUTO DOUBLE VOID * CHAR FLOAT IDENTIFIER INT LONG UNSIGNED ENUM ( ; : [ ) , 


status number: 246
1
struct_declarator -> : constant_expression 	2
; , 


status number: 247
1
struct_declarator_list -> struct_declarator_list , struct_declarator 	2
; , 


status number: 248
1
struct_declaration -> specifier_qualifier_list struct_declarator_list ; 	3
DOUBLE } FLOAT CHAR SIGNED TYPE_NAME SHORT VOID INT LONG UNSIGNED ENUM VOLATILE UNION CONST STRUCT 


status number: 249
1
struct_declarator -> declarator : constant_expression 	2
; , 


status number: 250
1
direct_abstract_declarator -> ( ) 	2
( [ ) , 


status number: 251
1
direct_abstract_declarator -> ( parameter_type_list ) 	2
( [ ) , 


status number: 252
1
direct_abstract_declarator -> ( abstract_declarator ) 	2
( [ ) , 


status number: 253
1
direct_abstract_declarator -> [ ] 	2
( [ ) , 


status number: 254
1
direct_abstract_declarator -> [ constant_expression ] 	2
( [ ) , 


status number: 255
2
direct_abstract_declarator -> direct_abstract_declarator ( parameter_type_list ) 	2
( [ ) , 
direct_abstract_declarator -> direct_abstract_declarator ( ) 	2
( [ ) , 


status number: 256
2
direct_abstract_declarator -> direct_abstract_declarator [ constant_expression ] 	2
( [ ) , 
direct_abstract_declarator -> direct_abstract_declarator [ ] 	2
( [ ) , 


status number: 257
5
abstract_declarator -> pointer direct_abstract_declarator 	2
) , 
direct_abstract_declarator -> direct_abstract_declarator [ ] 	1
( [ ) , 
direct_abstract_declarator -> direct_abstract_declarator [ constant_expression ] 	1
( [ ) , 
direct_abstract_declarator -> direct_abstract_declarator ( parameter_type_list ) 	1
( [ ) , 
direct_abstract_declarator -> direct_abstract_declarator ( ) 	1
( [ ) , 


status number: 258
1
identifier_list -> identifier_list , IDENTIFIER 	3
) , 


status number: 259
1
parameter_type_list -> parameter_list , ELLIPSIS 	3
) 


status number: 260
1
parameter_list -> parameter_list , parameter_declaration 	3
) , 


status number: 261
1
primary_expression -> ( expression ) 	3
? OR_OP ] | < MUL_ASSIGN EQ_OP * . ( DIV_ASSIGN LEFT_ASSIGN ) GE_OP MOD_ASSIGN ADD_ASSIGN = } RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 


status number: 262
1
cast_expression -> ( type_name ) cast_expression 	3
OR_OP ? ] MUL_ASSIGN EQ_OP | < : * XOR_ASSIGN ; LEFT_ASSIGN ) = ADD_ASSIGN } , GE_OP MOD_ASSIGN DIV_ASSIGN RIGHT_ASSIGN SUB_ASSIGN AND_ASSIGN OR_ASSIGN / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 


status number: 263
3
direct_abstract_declarator -> ( ) 	1
( [ ) 
direct_abstract_declarator -> ( parameter_type_list ) 	1
( [ ) 
direct_abstract_declarator -> ( abstract_declarator ) 	1
( [ ) 


status number: 264
2
abstract_declarator -> pointer direct_abstract_declarator 	1
) 
abstract_declarator -> pointer 	1
) 


status number: 265
1
type_name -> specifier_qualifier_list abstract_declarator 	2
) 


status number: 266
1
unary_expression -> SIZEOF ( type_name ) 	3
? OR_OP ] | < MUL_ASSIGN EQ_OP GE_OP MOD_ASSIGN * ) LEFT_ASSIGN DIV_ASSIGN } ADD_ASSIGN = RIGHT_ASSIGN SUB_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 


status number: 267
1
postfix_expression -> postfix_expression PTR_OP IDENTIFIER 	3
? OR_OP ] MUL_ASSIGN EQ_OP | < * . ( [ PTR_OP INC_OP DEC_OP ) LEFT_ASSIGN DIV_ASSIGN GE_OP MOD_ASSIGN } ADD_ASSIGN = SUB_ASSIGN RIGHT_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 


status number: 268
1
postfix_expression -> postfix_expression ( ) 	3
? OR_OP ] MUL_ASSIGN EQ_OP | < * . ( [ PTR_OP INC_OP DEC_OP ) LEFT_ASSIGN DIV_ASSIGN GE_OP MOD_ASSIGN } ADD_ASSIGN = SUB_ASSIGN RIGHT_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 


status number: 269
1
argument_expression_list -> assignment_expression 	1
) , 


status number: 270
2
postfix_expression -> postfix_expression ( argument_expression_list ) 	3
? OR_OP ] MUL_ASSIGN EQ_OP | < * . ( [ PTR_OP INC_OP DEC_OP ) LEFT_ASSIGN DIV_ASSIGN GE_OP MOD_ASSIGN } ADD_ASSIGN = SUB_ASSIGN RIGHT_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
argument_expression_list -> argument_expression_list , assignment_expression 	1
) , 


status number: 271
2
postfix_expression -> postfix_expression [ expression ] 	3
? OR_OP ] MUL_ASSIGN EQ_OP | < * . ( [ PTR_OP INC_OP DEC_OP ) LEFT_ASSIGN DIV_ASSIGN GE_OP MOD_ASSIGN } ADD_ASSIGN = SUB_ASSIGN RIGHT_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 
expression -> expression , assignment_expression 	1
] , 


status number: 272
1
postfix_expression -> postfix_expression . IDENTIFIER 	3
? OR_OP ] MUL_ASSIGN EQ_OP | < * . ( [ PTR_OP INC_OP DEC_OP ) LEFT_ASSIGN DIV_ASSIGN GE_OP MOD_ASSIGN } ADD_ASSIGN = SUB_ASSIGN RIGHT_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 


status number: 273
1
multiplicative_expression -> multiplicative_expression * cast_expression 	3
? OR_OP / ] % | < EQ_OP * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 


status number: 274
1
multiplicative_expression -> multiplicative_expression / cast_expression 	3
? OR_OP / ] % | < EQ_OP * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 


status number: 275
1
multiplicative_expression -> multiplicative_expression % cast_expression 	3
? OR_OP / ] % | < EQ_OP * ; ) : } , - + LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 


status number: 276
4
additive_expression -> additive_expression + multiplicative_expression 	3
OR_OP ? ] - EQ_OP | < ; + ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 
multiplicative_expression -> multiplicative_expression * cast_expression 	1
* OR_OP ? / ] - % EQ_OP | < + ; ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 
multiplicative_expression -> multiplicative_expression / cast_expression 	1
* OR_OP ? / ] - % EQ_OP | < + ; ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 
multiplicative_expression -> multiplicative_expression % cast_expression 	1
* OR_OP ? / ] - % EQ_OP | < + ; ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 


status number: 277
4
additive_expression -> additive_expression - multiplicative_expression 	3
OR_OP ? ] - EQ_OP | < ; + ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 
multiplicative_expression -> multiplicative_expression * cast_expression 	1
* OR_OP ? / ] - % EQ_OP | < + ; ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 
multiplicative_expression -> multiplicative_expression / cast_expression 	1
* OR_OP ? / ] - % EQ_OP | < + ; ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 
multiplicative_expression -> multiplicative_expression % cast_expression 	1
* OR_OP ? / ] - % EQ_OP | < + ; ) : } , LEFT_OP RIGHT_OP LE_OP > GE_OP NE_OP & ^ AND_OP 


status number: 278
3
shift_expression -> shift_expression LEFT_OP additive_expression 	3
? OR_OP ] | < EQ_OP ; LEFT_OP RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP 
additive_expression -> additive_expression - multiplicative_expression 	1
; LEFT_OP + ] - ? OR_OP | < EQ_OP RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP 
additive_expression -> additive_expression + multiplicative_expression 	1
; LEFT_OP + ] - ? OR_OP | < EQ_OP RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP 


status number: 279
3
shift_expression -> shift_expression RIGHT_OP additive_expression 	3
? OR_OP ] | < EQ_OP ; LEFT_OP RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP 
additive_expression -> additive_expression + multiplicative_expression 	1
; LEFT_OP + ] - ? OR_OP | < EQ_OP RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP 
additive_expression -> additive_expression - multiplicative_expression 	1
; LEFT_OP + ] - ? OR_OP | < EQ_OP RIGHT_OP ) : } , > LE_OP GE_OP NE_OP & ^ AND_OP 


status number: 280
3
shift_expression -> shift_expression RIGHT_OP additive_expression 	1
LEFT_OP > RIGHT_OP OR_OP ? ] LE_OP EQ_OP | < GE_OP ; ) : } , NE_OP & ^ AND_OP 
relational_expression -> relational_expression > shift_expression 	3
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	1
LEFT_OP > RIGHT_OP OR_OP ? ] LE_OP EQ_OP | < GE_OP ; ) : } , NE_OP & ^ AND_OP 


status number: 281
3
relational_expression -> relational_expression < shift_expression 	3
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	1
LEFT_OP > RIGHT_OP OR_OP ? ] LE_OP EQ_OP | < GE_OP ; ) : } , NE_OP & ^ AND_OP 
shift_expression -> shift_expression RIGHT_OP additive_expression 	1
LEFT_OP > RIGHT_OP OR_OP ? ] LE_OP EQ_OP | < GE_OP ; ) : } , NE_OP & ^ AND_OP 


status number: 282
3
relational_expression -> relational_expression LE_OP shift_expression 	3
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	1
LEFT_OP > RIGHT_OP OR_OP ? ] LE_OP EQ_OP | < GE_OP ; ) : } , NE_OP & ^ AND_OP 
shift_expression -> shift_expression RIGHT_OP additive_expression 	1
LEFT_OP > RIGHT_OP OR_OP ? ] LE_OP EQ_OP | < GE_OP ; ) : } , NE_OP & ^ AND_OP 


status number: 283
3
relational_expression -> relational_expression GE_OP shift_expression 	3
OR_OP ? ] LE_OP EQ_OP | < > GE_OP ; ) : } , NE_OP & ^ AND_OP 
shift_expression -> shift_expression LEFT_OP additive_expression 	1
LEFT_OP > RIGHT_OP OR_OP ? ] LE_OP EQ_OP | < GE_OP ; ) : } , NE_OP & ^ AND_OP 
shift_expression -> shift_expression RIGHT_OP additive_expression 	1
LEFT_OP > RIGHT_OP OR_OP ? ] LE_OP EQ_OP | < GE_OP ; ) : } , NE_OP & ^ AND_OP 


status number: 284
5
equality_expression -> equality_expression EQ_OP relational_expression 	3
? OR_OP NE_OP } ] EQ_OP ; ) : , & ^ | AND_OP 
relational_expression -> relational_expression < shift_expression 	1
| < > } ] LE_OP GE_OP ? OR_OP NE_OP EQ_OP ; ) : , & ^ AND_OP 
relational_expression -> relational_expression > shift_expression 	1
| < > } ] LE_OP GE_OP ? OR_OP NE_OP EQ_OP ; ) : , & ^ AND_OP 
relational_expression -> relational_expression LE_OP shift_expression 	1
| < > } ] LE_OP GE_OP ? OR_OP NE_OP EQ_OP ; ) : , & ^ AND_OP 
relational_expression -> relational_expression GE_OP shift_expression 	1
| < > } ] LE_OP GE_OP ? OR_OP NE_OP EQ_OP ; ) : , & ^ AND_OP 


status number: 285
5
equality_expression -> equality_expression NE_OP relational_expression 	3
? OR_OP NE_OP } ] EQ_OP ; ) : , & ^ | AND_OP 
relational_expression -> relational_expression > shift_expression 	1
| < > } ] LE_OP GE_OP ? OR_OP NE_OP EQ_OP ; ) : , & ^ AND_OP 
relational_expression -> relational_expression < shift_expression 	1
| < > } ] LE_OP GE_OP ? OR_OP NE_OP EQ_OP ; ) : , & ^ AND_OP 
relational_expression -> relational_expression LE_OP shift_expression 	1
| < > } ] LE_OP GE_OP ? OR_OP NE_OP EQ_OP ; ) : , & ^ AND_OP 
relational_expression -> relational_expression GE_OP shift_expression 	1
| < > } ] LE_OP GE_OP ? OR_OP NE_OP EQ_OP ; ) : , & ^ AND_OP 


status number: 286
3
and_expression -> and_expression & equality_expression 	3
OR_OP ? } ] & ; ) : , ^ | AND_OP 
equality_expression -> equality_expression EQ_OP relational_expression 	1
EQ_OP OR_OP ? NE_OP } ] & ; ) : , ^ | AND_OP 
equality_expression -> equality_expression NE_OP relational_expression 	1
EQ_OP OR_OP ? NE_OP } ] & ; ) : , ^ | AND_OP 


status number: 287
2
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	3
? OR_OP } ] ^ ; ) : , | AND_OP 
and_expression -> and_expression & equality_expression 	1
^ & ? OR_OP } ] ; ) : , | AND_OP 


status number: 288
2
inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression 	3
OR_OP ? } ] , | ; ) : AND_OP 
exclusive_or_expression -> exclusive_or_expression ^ and_expression 	1
^ OR_OP ? } ] , | ; ) : AND_OP 


status number: 289
2
logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression 	3
? OR_OP } ] ) AND_OP ; : , 
inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression 	1
| ? OR_OP } ] ) AND_OP ; : , 


status number: 290
2
conditional_expression -> logical_or_expression ? expression : conditional_expression 	3
} ] ; ) : , 
expression -> expression , assignment_expression 	1
: , 


status number: 291
2
logical_or_expression -> logical_or_expression OR_OP logical_and_expression 	3
? OR_OP } ] ; ) : , 
logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression 	1
) AND_OP OR_OP ? } ] ; : , 


status number: 292
1
initializer_list -> initializer 	1
} , 


status number: 293
3
initializer -> { initializer_list } 	2
} , ; 
initializer -> { initializer_list , } 	2
} , ; 
initializer_list -> initializer_list , initializer 	1
} , 


status number: 294
1
labeled_statement -> IDENTIFIER : statement 	3
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 295
3
selection_statement -> IF ( expression ) statement ELSE statement 	3
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
selection_statement -> IF ( expression ) statement 	3
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
expression -> expression , assignment_expression 	1
) , 


status number: 296
1
labeled_statement -> CASE constant_expression : statement 	3
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 297
1
labeled_statement -> DEFAULT : statement 	3
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 298
2
selection_statement -> SWITCH ( expression ) statement 	3
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
expression -> expression , assignment_expression 	1
) , 


status number: 299
2
iteration_statement -> WHILE ( expression ) statement 	3
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
expression -> expression , assignment_expression 	1
) , 


status number: 300
1
iteration_statement -> DO statement WHILE ( expression ) ; 	3
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 301
2
iteration_statement -> FOR ( expression_statement expression_statement ) statement 	3
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
iteration_statement -> FOR ( expression_statement expression_statement expression ) statement 	3
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 302
1
jump_statement -> GOTO IDENTIFIER ; 	3
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 303
1
jump_statement -> RETURN expression ; 	3
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 304
1
assignment_expression -> unary_expression assignment_operator assignment_expression 	3
; ) } ] : , 


status number: 305
1
expression -> expression , assignment_expression 	3
; , ) ] : 


status number: 306
1
compound_statement -> { declaration_list statement_list } 	4
} FOR ELSE WHILE DEFAULT INT IDENTIFIER STATIC DEC_OP LONG $ VOLATILE SIGNED TYPE_NAME SHORT FLOAT STRUCT REGISTER DO UNION CONST CHAR * IF UNSIGNED ( STRING_LITERAL TYPEDEF EXTERN AUTO DOUBLE RETURN VOID ENUM GOTO CASE ; { CONTINUE BREAK - SIZEOF INC_OP SWITCH CONSTANT & ~ + ! 


status number: 307
1
struct_declarator_list -> struct_declarator_list , struct_declarator 	3
; , 


status number: 308
1
struct_declarator -> declarator : constant_expression 	3
; , 


status number: 309
1
direct_abstract_declarator -> ( parameter_type_list ) 	3
( [ ) , 


status number: 310
1
direct_abstract_declarator -> ( abstract_declarator ) 	3
( [ ) , 


status number: 311
1
direct_abstract_declarator -> [ constant_expression ] 	3
( [ ) , 


status number: 312
1
direct_abstract_declarator -> direct_abstract_declarator ( ) 	3
( [ ) , 


status number: 313
1
direct_abstract_declarator -> direct_abstract_declarator ( parameter_type_list ) 	3
( [ ) , 


status number: 314
1
direct_abstract_declarator -> direct_abstract_declarator [ ] 	3
( [ ) , 


status number: 315
1
direct_abstract_declarator -> direct_abstract_declarator [ constant_expression ] 	3
( [ ) , 


status number: 316
1
cast_expression -> ( type_name ) cast_expression 	4
OR_OP ? ] | < MUL_ASSIGN EQ_OP * : XOR_ASSIGN ; LEFT_ASSIGN ) ADD_ASSIGN = } , MOD_ASSIGN GE_OP DIV_ASSIGN RIGHT_ASSIGN SUB_ASSIGN AND_ASSIGN OR_ASSIGN / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 


status number: 317
1
unary_expression -> SIZEOF ( type_name ) 	4
? OR_OP ] MUL_ASSIGN EQ_OP | < * GE_OP MOD_ASSIGN LEFT_ASSIGN ) DIV_ASSIGN = ADD_ASSIGN } RIGHT_ASSIGN SUB_ASSIGN ; XOR_ASSIGN AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 


status number: 318
1
postfix_expression -> postfix_expression ( argument_expression_list ) 	4
? OR_OP ] | < MUL_ASSIGN EQ_OP * . ( [ PTR_OP INC_OP DEC_OP LEFT_ASSIGN ) DIV_ASSIGN GE_OP MOD_ASSIGN = ADD_ASSIGN } SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 


status number: 319
1
argument_expression_list -> argument_expression_list , assignment_expression 	2
) , 


status number: 320
1
postfix_expression -> postfix_expression [ expression ] 	4
? OR_OP ] | < MUL_ASSIGN EQ_OP * . ( [ PTR_OP INC_OP DEC_OP LEFT_ASSIGN ) DIV_ASSIGN GE_OP MOD_ASSIGN = ADD_ASSIGN } SUB_ASSIGN RIGHT_ASSIGN XOR_ASSIGN ; AND_ASSIGN OR_ASSIGN : , / % - + LEFT_OP RIGHT_OP LE_OP > NE_OP & ^ AND_OP 


status number: 321
1
conditional_expression -> logical_or_expression ? expression : conditional_expression 	4
] } ; ) : , 


status number: 322
2
initializer -> { initializer_list , } 	3
} , ; 
initializer_list -> initializer_list , initializer 	2
} , 


status number: 323
1
initializer -> { initializer_list } 	3
} , ; 


status number: 324
2
selection_statement -> IF ( expression ) statement ELSE statement 	4
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
selection_statement -> IF ( expression ) statement 	4
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 325
1
labeled_statement -> CASE constant_expression : statement 	4
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 326
1
selection_statement -> SWITCH ( expression ) statement 	4
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 327
1
iteration_statement -> WHILE ( expression ) statement 	4
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 328
1
iteration_statement -> DO statement WHILE ( expression ) ; 	4
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 329
2
iteration_statement -> FOR ( expression_statement expression_statement ) statement 	4
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
iteration_statement -> FOR ( expression_statement expression_statement expression ) statement 	4
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 330
1
direct_abstract_declarator -> direct_abstract_declarator ( parameter_type_list ) 	4
( [ ) , 


status number: 331
1
direct_abstract_declarator -> direct_abstract_declarator [ constant_expression ] 	4
( [ ) , 


status number: 332
1
argument_expression_list -> argument_expression_list , assignment_expression 	3
) , 


status number: 333
1
conditional_expression -> logical_or_expression ? expression : conditional_expression 	5
} ] ; ) : , 


status number: 334
1
initializer -> { initializer_list , } 	4
} , ; 


status number: 335
1
initializer_list -> initializer_list , initializer 	3
} , 


status number: 336
2
selection_statement -> IF ( expression ) statement ELSE statement 	5
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
selection_statement -> IF ( expression ) statement 	5
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 337
1
selection_statement -> SWITCH ( expression ) statement 	5
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 338
1
iteration_statement -> WHILE ( expression ) statement 	5
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 339
2
expression -> expression , assignment_expression 	1
) , 
iteration_statement -> DO statement WHILE ( expression ) ; 	5
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 340
1
iteration_statement -> FOR ( expression_statement expression_statement ) statement 	5
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 341
2
iteration_statement -> FOR ( expression_statement expression_statement expression ) statement 	5
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 
expression -> expression , assignment_expression 	1
) , 


status number: 342
1
selection_statement -> IF ( expression ) statement ELSE statement 	6
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 343
1
iteration_statement -> DO statement WHILE ( expression ) ; 	6
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 344
1
iteration_statement -> FOR ( expression_statement expression_statement ) statement 	6
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 345
1
iteration_statement -> FOR ( expression_statement expression_statement expression ) statement 	6
ELSE FOR } GOTO IDENTIFIER DEFAULT WHILE CASE ; { RETURN CONTINUE BREAK - DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 346
1
selection_statement -> IF ( expression ) statement ELSE statement 	7
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 347
1
iteration_statement -> DO statement WHILE ( expression ) ; 	7
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


status number: 348
1
iteration_statement -> FOR ( expression_statement expression_statement expression ) statement 	7
ELSE FOR } IDENTIFIER DEFAULT GOTO WHILE CASE { ; RETURN CONTINUE - BREAK DO SIZEOF INC_OP DEC_OP STRING_LITERAL IF SWITCH CONSTANT ( & * ~ + ! 


