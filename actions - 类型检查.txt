primary_expression
->
IDENTIFIER
                                                            {
                                                                postfix_expression.array = top.get( IDENTIFIER.morpheme ).address
                                                                gen( 'JZ'   1          -               0) //强行生成一条三地址指令当跳板
                                                            }
->
CONSTANT
                                                            {
                                                                primary_expression.addr = new Temp()
                                                                gen( primary_expression.addr '=' CONSTANT.morpheme )
                                                            }
->
( expression )
                                                            {
                                                                primary_expression.addr = expression.addr
                                                            }
;;


postfix_expression
->
primary_expression
                                                            {
                                                                postfix_expression.addr = primary_expression.addr
                                                            }
->
IDENTIFIER [ expression ]
                                                            {
                                                                if ( top.get( IDENTIFIER.morpheme ).type != "array") {
                                                                    //需要处理以下原本的type，去掉array元素的类型再判断
                                                                    报错
                                                                }
                                                                if ( expression.type != "int" ) {  //expression.type 要查表
                                                                    报错
                                                                }
                                                                postfix_expression.type = postfix_expression.array.elem_type //postfix_expression.type 要查表
                                                                if (postfix_expression.type == "int") { //postfix_expression.type 要查表
                                                                    postfix_expression.addr = new Temp()
                                                                    postfix_expression.array.name = top.get( IDENTIFIER.morpheme ).address
                                                                    postfix_expression.array.pos =  expression.addr '*' postfix_expression.array.width //改成偏移量
                                                                }
                                                                else if (postfix_expression.type == "struct ..$..") { //postfix_expression.type 要查表
                                                                    name = IDENTIFIER.morpheme + "$" + expression.addr
                                                                    postfix_expression.addr = top.get(name).address
                                                                }
                                                            }
->
postfix_expression1 ( )
                                                            {
                                                                tem_type = function_table.get(postfix_expression1.addr).return_type
                                                                postfix_expression.addr = new Temp(temp_type)
                                                                gen( postfix_expression.addr '=' call(postfix_expression1.addr, 0) )
                                                            }
->
postfix_expression1 ( argument_expression_list )
                                                            {
                                                                tem_type = function_table.get(postfix_expression1.addr).return_type
                                                                postfix_expression.addr = new Temp(temp_type)
                                                                checkType(postfix_expression.addr, paramList) //参数类型检查
                                                                clean(paramList) //清空参数类型检查列表
                                                                gen( postfix_expression.addr '=' call(postfix_expression1.addr, argument_expression_list.size) )
                                                            }
->
IDENTIFIER1 . IDENTIFIER2
                                                            {
                                                                t = top.get(IDENTIFIER1.morpheme).address
/////////////////////////////////////////////////////////// start /////////////////////////////////////////////////////////////////////
                                                                if(top.get(IDENTIFIER1.morpheme).type.find("struct") == -1){
                                                                    报错 不是结构体
                                                                }
///////////////////////////////////////////////////////////  end  /////////////////////////////////////////////////////////////////////
                                                                postfix_expression.addr = top.get( get_struct_var_name(t, IDENTIFIER.morpheme) ).address
                                                            }
->
postfix_expression1 INC_OP
                                                            {
/////////////////////////////////////////////////////////// start /////////////////////////////////////////////////////////////////////
                                                                if(postfix_expression1.type != "int"){
                                                                    报错 不是int变量
                                                                }
///////////////////////////////////////////////////////////  end  /////////////////////////////////////////////////////////////////////
                                                                postfix_expression.addr = new Temp()
                                                                gen( postfix_expression.addr '=' postfix_expression1.addr )
                                                                gen( postfix_expression1.addr '=' postfix_expression1.addr '+' 1 )
                                                            }
->
postfix_expression1 DEC_OP
                                                            {
/////////////////////////////////////////////////////////// start /////////////////////////////////////////////////////////////////////
                                                                if(postfix_expression1.type != "int"){
                                                                    报错 不是int变量
                                                                }
///////////////////////////////////////////////////////////  end  /////////////////////////////////////////////////////////////////////
                                                                postfix_expression.addr = new Temp()
                                                                gen( postfix_expression.addr '=' postfix_expression1.addr )
                                                                gen( postfix_expression1.addr '=' postfix_expression1.addr '-' 1 )
                                                            }
;;


argument_expression_list
->
assignment_expression
                                                            {
                                                                gen( 'param' assignment_expression.addr )
                                                                paramList.push( assignment_expression.addr )  //将参数加入一个列表以便类型检查
                                                                argument_expression_list.size = 1
                                                            }
->
argument_expression_list , assignment_expression
                                                            {
                                                                gen( 'param' assignment_expression.addr )
                                                                paramList.push( assignment_expression.addr )  //
                                                                argument_expression_list.size += 1
                                                            }
;;


unary_expression
->
postfix_expression
                                                            {
                                                                unary_expression.addr = postfix_expression.addr
                                                            }
->
INC_OP unary_expression1
                                                            {
/////////////////////////////////////////////////////////// start /////////////////////////////////////////////////////////////////////
                                                                if(unary_expression1.type != "int"){
                                                                    报错 不是int变量
                                                                }
///////////////////////////////////////////////////////////  end  /////////////////////////////////////////////////////////////////////
                                                                unary_expression.addr = new Temp()
                                                                gen( unary_expression1.addr '=' unary_expression1.addr '+' 1 )
                                                                gen( unary_expression.addr '=' unary_expression1.addr )
                                                            }
->
DEC_OP unary_expression1
                                                            {
/////////////////////////////////////////////////////////// start /////////////////////////////////////////////////////////////////////
                                                                if(unary_expression1.type != "int"){
                                                                    报错 不是int变量
                                                                }
///////////////////////////////////////////////////////////  end  /////////////////////////////////////////////////////////////////////
                                                                unary_expression.addr = new Temp()
                                                                gen( unary_expression1.addr '=' unary_expression1.addr '-' 1 )
                                                                gen( unary_expression.addr '=' unary_expression1.addr )
                                                            }
->
unary_operator cast_expression
                                                            {
/////////////////////////////////////////////////////////// start /////////////////////////////////////////////////////////////////////
                                                                if(cast_expression.type != "int"){
                                                                    报错 不是int变量
                                                                }
///////////////////////////////////////////////////////////  end  /////////////////////////////////////////////////////////////////////
                                                                unary_expression.addr = new Temp()
                                                                gen( unary_expression.addr '=' unary(unary_operator.value, cast_expression.addr) )
                                                            }

->
SIZEOF unary_expression1
                                                            {
                                                                unary_expression.addr = new Temp(int)
                                                                gen( unary_expression.addr '=' unary_expression1.width )
                                                            }
->
SIZEOF ( type_name )
                                                            {
                                                                unary_expression.addr = new Temp(int)
                                                                gen( unary_expression.addr '=' type_name.width )
                                                            }
;;


unary_operator
->
&
                                                            {
                                                                unary_operator.value = "&"
                                                            }
->
*
                                                            {
                                                                unary_operator.value = "*"
                                                            }
->                                                            
+
                                                            {
                                                                unary_operator.value = "+"
                                                            }
->
-
                                                            {
                                                                unary_operator.value = "-"
                                                            }
->
~
                                                            {
                                                                unary_operator.value = "~"
                                                            }
->
!
                                                            {
                                                                unary_operator.value = "!"
                                                            }
;;


cast_expression
->
unary_expression
                                                            {
                                                                cast_expression.addr = unary_expression.addr
                                                            }
->
( type_name ) cast_expression1
                                                            {
                                                                cast_expression.addr = new Temp(type_name.type)
                                                                gen( cast_expression.addr '=' cast_expression1.addr )
                                                            }
;;


multiplicative_expression
->
cast_expression
                                                            {
                                                                multiplicative_expression.addr = cast_expression.addr
                                                            }
->
multiplicative_expression1 * cast_expression
                                                            {
/////////////////////////////////////////////////////////// start /////////////////////////////////////////////////////////////////////
                                                                if(cast_expression.type != "int" || multiplicative_expression1.type != "int"){
                                                                    报错 不是int变量
                                                                }
///////////////////////////////////////////////////////////  end  /////////////////////////////////////////////////////////////////////
                                                                multiplicative_expression.addr = new Temp()
                                                                gen( multiplicative_expression.addr '=' cast_expression.addr '*' multiplicative_expression1.addr )
                                                            }
->
multiplicative_expression1 / cast_expression
                                                            {
/////////////////////////////////////////////////////////// start /////////////////////////////////////////////////////////////////////
                                                                if(cast_expression.type != "int" || multiplicative_expression1.type != "int"){
                                                                    报错 不是int变量
                                                                }
///////////////////////////////////////////////////////////  end  /////////////////////////////////////////////////////////////////////
                                                                multiplicative_expression.addr = new Temp()
                                                                gen( multiplicative_expression.addr '=' cast_expression.addr '/' multiplicative_expression1.addr )
                                                            }
->
multiplicative_expression1 % cast_expression
                                                            {
/////////////////////////////////////////////////////////// start /////////////////////////////////////////////////////////////////////
                                                                if(cast_expression.type != "int" || multiplicative_expression1.type != "int"){
                                                                    报错 不是int变量
                                                                }
///////////////////////////////////////////////////////////  end  /////////////////////////////////////////////////////////////////////
                                                                multiplicative_expression.addr = new Temp()
                                                                gen( multiplicative_expression.addr '=' cast_expression.addr '%' multiplicative_expression1.addr )
                                                            }
;;


additive_expression
->
multiplicative_expression
                                                            {
                                                                additive_expression.addr = multiplicative_expression.addr
                                                            }
->
additive_expression1 + multiplicative_expression
                                                            {
/////////////////////////////////////////////////////////// start /////////////////////////////////////////////////////////////////////
                                                                if(multiplicative_expression.type != "int" || additive_expression1.type != "int"){
                                                                    报错 不是int变量
                                                                }
///////////////////////////////////////////////////////////  end  /////////////////////////////////////////////////////////////////////
                                                                multiplicative_expression.addr = new Temp()
                                                                gen( additive_expression.addr '=' additive_expression1.addr '+' multiplicative_expression.addr )
                                                            }
->
additive_expression1 - multiplicative_expression
                                                            {
/////////////////////////////////////////////////////////// start /////////////////////////////////////////////////////////////////////
                                                                if(multiplicative_expression.type != "int" || additive_expression1.type != "int"){
                                                                    报错 不是int变量
                                                                }
///////////////////////////////////////////////////////////  end  /////////////////////////////////////////////////////////////////////
                                                                multiplicative_expression.addr = new Temp()
                                                                gen( additive_expression.addr '=' additive_expression1.addr '-' multiplicative_expression.addr )
                                                            }
;;


shift_expression
->
additive_expression
                                                            {
                                                                shift_expression.addr = additive_expression.addr
                                                            }
;;


relational_expression
->
shift_expression
                                                            {
                                                                relational_expression.addr = shift_expression.addr
                                                            }
->
relational_expression1 < shift_expression
                                                            {
/////////////////////////////////////////////////////////// start /////////////////////////////////////////////////////////////////////
                                                                if(shift_expression.type != "int" || relational_expression1.type != "int"){
                                                                    报错 不是int变量
                                                                }
///////////////////////////////////////////////////////////  end  /////////////////////////////////////////////////////////////////////
                                                                relational_expression.addr = new Temp()
                                                                gen( 'JL'   relational_expression1.addr           shift_expression.addr               +3           )
                                                                gen( =          0                                -                       relational_expression.addr)
                                                                gen( 'JMP'      -                                -                                   +2            )
                                                                gen( =          1                                -                       relational_expression.addr)
                                                            }
->
relational_expression1 > shift_expression
                                                            {
/////////////////////////////////////////////////////////// start /////////////////////////////////////////////////////////////////////
                                                                if(shift_expression.type != "int" || relational_expression1.type != "int"){
                                                                    报错 不是int变量
                                                                }
///////////////////////////////////////////////////////////  end  /////////////////////////////////////////////////////////////////////
                                                                relational_expression.addr = new Temp()
                                                                gen( 'JG'   relational_expression1.addr           shift_expression.addr               +3           F)
                                                                gen( =          0                                -                       relational_expression.addr)
                                                                gen( 'JMP'      -                                -                                   +2            )
                                                                gen( =          1                                -                       relational_expression.addr)
                                                            }
->
relational_expression1 LE_OP shift_expression
                                                            {
/////////////////////////////////////////////////////////// start /////////////////////////////////////////////////////////////////////
                                                                if(shift_expression.type != "int" || relational_expression1.type != "int"){
                                                                    报错 不是int变量
                                                                }
///////////////////////////////////////////////////////////  end  /////////////////////////////////////////////////////////////////////
                                                                relational_expression.addr = new Temp()
                                                                gen( 'JLE'   relational_expression.addr          shift_expression.addr               +3            )
                                                                gen( =          0                                -                       relational_expression.addr)
                                                                gen( 'JMP'      -                                -                                   +2            )
                                                                gen( =          1                                -                       relational_expression.addr)
                                                            }
relational_expression1 GE_OP shift_expression
                                                            {
/////////////////////////////////////////////////////////// start /////////////////////////////////////////////////////////////////////
                                                                if(shift_expression.type != "int" || relational_expression1.type != "int"){
                                                                    报错 不是int变量
                                                                }
///////////////////////////////////////////////////////////  end  /////////////////////////////////////////////////////////////////////
                                                                relational_expression.addr = new Temp()
                                                                gen( 'JGE'   relational_expression.addr          shift_expression.addr               +3            )
                                                                gen( =          0                                -                       relational_expression.addr)
                                                                gen( 'JMP'      -                                -                                   +2            )
                                                                gen( =          1                                -                       relational_expression.addr)
                                                            }
;;


equality_expression
->
relational_expression
                                                            {
                                                                equality_expression.addr = relational_expression.addr
                                                            }
->
equality_expression1 EQ_OP relational_expression
                                                            {
/////////////////////////////////////////////////////////// start /////////////////////////////////////////////////////////////////////
                                                                if(equality_expression1.type != "int" || relational_expression.type != "int"){
                                                                    报错 不是int变量
                                                                }
///////////////////////////////////////////////////////////  end  /////////////////////////////////////////////////////////////////////
                                                                equality_expression.addr = new Temp()
                                                                gen( 'JE'   equality_expression1.addr          relational_expression.addr            +3           )
                                                                gen( =          0                                -                       equality_expression1.addr)
                                                                gen( 'JMP'      -                                -                                   +2           )
                                                                gen( =          1                                -                       equality_expression1.addr)
                                                            }
->
equality_expression1 NE_OP relational_expression
                                                            {
/////////////////////////////////////////////////////////// start /////////////////////////////////////////////////////////////////////
                                                                if(equality_expression1.type != "int" || relational_expression.type != "int"){
                                                                    报错 不是int变量
                                                                }
///////////////////////////////////////////////////////////  end  /////////////////////////////////////////////////////////////////////
                                                                equality_expression.addr = new Temp()
                                                                gen( 'JNE'   equality_expression1.addr          relational_expression.addr            +3           )
                                                                gen( =          0                                -                       equality_expression1.addr)
                                                                gen( 'JMP'      -                                -                                   +2           )
                                                                gen( =          1                                -                       equality_expression1.addr)
                                                            }
;;


exclusive_or_expression
->
equality_expression
                                                            {
                                                                exclusive_or_expression.addr = equality_expression.addr
                                                            }
->
exclusive_or_expression1 ^ equality_expression
                                                            {
/////////////////////////////////////////////////////////// start /////////////////////////////////////////////////////////////////////
                                                                if(exclusive_or_expression1.type != "int" || equality_expression.type != "int"){
                                                                    报错 不是int变量
                                                                }
///////////////////////////////////////////////////////////  end  /////////////////////////////////////////////////////////////////////
                                                                exclusive_or_expression.addr = new Temp()
                                                                gen(exclusive_or_expression.addr '=' exclusive_or_expression1.addr '^' equality_expression)
                                                            }
;;


logical_and_expression
->
exclusive_or_expression
                                                            {
                                                                logical_and_expression.addr = exclusive_or_expression.addr
                                                            }
->
logical_and_expression1 AND_OP exclusive_or_expression
                                                            {
/////////////////////////////////////////////////////////// start /////////////////////////////////////////////////////////////////////
                                                                if(logical_and_expression1.type != "int" || exclusive_or_expression.type != "int"){
                                                                    报错 不是int变量
                                                                }
///////////////////////////////////////////////////////////  end  /////////////////////////////////////////////////////////////////////
                                                                logical_and_expression.addr = new Temp()
                                                                gen( 'JZ'   logical_and_expression1.addr         -           +4                            )
                                                                gen( 'JZ'   exclusive_or_expression.addr         -           +3                            )
                                                                gen( '='                 1                       -       logical_and_expression.addr       )
                                                                gen( 'JMP'               -                       -           +2                            )
                                                                gen( '='                 0                       -       logical_and_expression.addr       )

                                                            }
;;


logical_or_expression
->
logical_and_expression
                                                            {
                                                                logical_or_expression.addr = logical_and_expression.addr
                                                            }
->
logical_or_expression1 OR_OP logical_and_expression
                                                            {
/////////////////////////////////////////////////////////// start /////////////////////////////////////////////////////////////////////
                                                                if(logical_or_expression1.type != "int" || logical_and_expression.type != "int"){
                                                                    报错 不是int变量
                                                                }
///////////////////////////////////////////////////////////  end  /////////////////////////////////////////////////////////////////////
                                                                logical_or_expression.addr = new Temp()
                                                                gen( 'JNZ'   logical_or_expression1.addr         -           +4                            )
                                                                gen( 'JNZ'   logical_and_expression.addr         -           +3                            )
                                                                gen( '='                 0                       -       logical_or_expression.addr        )
                                                                gen( 'JMP'               -                       -           +2                            )
                                                                gen( '='                 1                       -       logical_or_expression.addr        )
                                                            }
;;


assignment_expression
->
logical_or_expression
                                                            {
                                                                assignment_expression.addr = logical_or_expression.addr
                                                            }
->
unary_expression = assignment_expression1
                                                            {
                                                                assignment_expression.addr = new Temp()
                                                                if (unary_expression.type != assignment_expression1.type) { //都要查表
                                                                    报错
                                                                }
                                                                if (unary_expression.array.name == "") {
                                                                    if (assignment_expression1.array.name == "") {
                                                                        gen( unary_expression.addr '=' assignment_expression1.addr )
                                                                        gen( assignment_expression.addr '=' assignment_expression1.addr )
                                                                    }
                                                                    else {
                                                                        gen("=[]", assignment_expression1.array.name, assignment_expression1.array.pos, unary_expression.addr)
                                                                        gen("=[]", assignment_expression1.array.name, assignment_expression1.array.pos, assignment_expression.addr)
                                                                    }
                                                                }
                                                                else {
                                                                    if (assignment_expression1.array.name == "") {
                                                                        gen( "[]=", unary_expression.array.name, unary_expression.array.pos, assignment_expression1.addr)
                                                                        gen( assignment_expression.addr '=' assignment_expression1.addr )
                                                                    }
                                                                    else {
                                                                        t = new Temp()
                                                                        gen("=[]", assignment_expression1.array.name, assignment_expression1.array.pos, t.addr)
                                                                        gen("[]=", unary_expression.array.name, unary_expression.array.pos, t.addr)
                                                                        gen(assignment_expression.addr '=' t.addr)
                                                                    }
                                                                }
                                                                
                                                            }
;;


expression
->
assignment_expression
                                                            {
                                                                expression.addr = assignment_expression.addr
                                                            }
->
expression1 , assignment_expression
                                                            {
                                                                expression.addr = assignment_expression.addr
                                                            }
;;


declaration
type_specifier ;
->
type_specifier
                                                            {
                                                                if(type_specifier.ifStruct) {
                                                                    init_declarator_list.struct = type_specifier.struct
                                                                }
                                                                init_declarator_list.type = type_specifier.type
                                                                init_declarator_list.ifStruct = type_specifier.ifStruct
                                                                init_declarator_list.offset = 0
                                                                init_declarator_list.width = type_specifier.width
                                                            }
init_declarator_list ;
;;


init_declarator_list
->
                                                            {
                                                                if (init_declarator_list.ifStruct) {
                                                                    init_declarator.struct = init_declarator_list.struct
                                                                }
                                                                init_declarator.type = init_declarator_list.type
                                                                init_declarator.ifStruct = init_declarator_list.ifStruct
                                                                init_declarator.offset = init_declarator_list.offset
	 														    init_declarator.width = init_declarator_list.width
                                                            }
init_declarator
                                                            {
                                                                init_declarator_list.syn_offset = init_declarator.syn_offset
                                                            }
->
                                                            {
                                                                if(init_declarator_list.ifStruct) {
                                                                    init_declarator_list1.struct = init_declarator_list.struct
                                                                }
                                                                init_declarator_list1.ifStruct = init_declarator_list.ifStruct
                                                                init_declarator_list1.type = init_declarator_list.type
                                                                init_declarator_list1.offset = init_declarator_list.offset
	  														    init_declarator_list1.width = init_declarator_list.width
                                                            }
init_declarator_list1 , 
                                                            {
                                                                if(init_declarator_list.ifStruct) {
                                                                    init_declarator.struct = init_declarator_list.struct
                                                                }
                                                                init_declarator.type = init_declarator_list.type
                                                                init_declarator.ifStruct = init_declarator_list.ifStruct
                                                                init_declarator.offset = init_declarator_list1.syn_offset
															    init_declarator.width = init_declarator_list1.width,
                                                            }
init_declarator
                                                            {
                                                                init_declarator_list.syn_offset = init_declarator.syn_offset
                                                            }
;;


init_declarator
->
                                                            {
                                                                if (init_declarator.ifStruct) {
                                                                    declarator.struct = init_declarator.struct
                                                                }
                                                                declarator.ifStruct = init_declarator.ifStruct
                                                                declarator.type = init_declarator.type
															    declarator.offset = init_declarator.offset
															    declarator.width = init_declarator.width
                                                            }
declarator
                                                            {
                                                                if (declarator.ifStruct) {
                                                                    init_declarator.syn_offset = create_a_struct_var(declarator.lexeme, declarator.struct)
                                                                    // 调用符号表插入结构体变量的函数
                                                                    // 记得累加偏移量并返回（hlh说偏移量没用了，随便了）
                                                                }
                                                                else {
                                                                    GENERATE(node???????????) declarator.lexeme, declarator.syn_type(指针类型)（数组类型）
                                                                    init_declarator.syn_offset = declarator.offset + declarator.syn_width（默认无参初始化）
                                                                }
                                                            }
->
                                                            {
                                                                if (init_declarator.ifStruct) {
                                                                    declarator.struct = init_declarator.struct
                                                                }
                                                                declarator.ifStruct = init_declarator.ifStruct
                                                                declarator.type = init_declarator.type
															    declarator.offset = init_declarator.offset
															    declarator.width = init_declarator.width
                                                            }
declarator = initializer
                                                            {
                                                                if (declarator.type != initializer.type) {
                                                                    报错
                                                                }
                                                                else {
                                                                    if (declarator.type == "struct ..$..") {
                                                                        // 用已有结构体变量给新结构体变量初始化
                                                                        top.put_symbol(hbst::SymbolItem(declarator.lexeme, declarator.type, 0, declarator.syn_width))
                                                                        initializer_lexeme = std::string(initializer.addr, 0, initializer.addr.rfind('$'))
                                                                        for each (n in declarator.struct.symbol) {
                                                                            string name1 = declarator.lexeme + "$" + n.name
                                                                            string name2 = initializer_lexeme + "$" + n.name
                                                                            gen(top.get(name1).addr, '=', top.get(name2).addr)
                                                                        }
                                                                    }
                                                                    else (declarator.type == "struct ..$..[..]") {
                                                                        // 结构体数组
                                                                        报错
                                                                    }
                                                                    else if(declarator.type[3] = '[') {
                                                                        if (initializer.list.size == 0) {
                                                                            报错
                                                                        }
                                                                        else {
                                                                            // int[]类型，还是调用你写的那个判断类型为数组函数比较好
                                                                            if (declarator.width/4 != initializer.list.size){
                                                                                报错 //数组赋值 元素个数不对
                                                                            }
                                                                            else {
                                                                                for (int i = 0; i < initializer.list.size; i++) {
                                                                                    gen("[]=", declarator.addr, i, initializer.list[i])
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                    else {
                                                                        //普通 int 类型
                                                                        GENERATE(node???????????) declarator.lexeme, declarator.syn_type(指针类型)（数组类型）
                                                                        init_declarator.syn_offset = declarator.offset + declarator.syn_width
                                                                    }
                                                                }
                                                            }
;;



type_specifier
->
VOID                            
                                                            {
                                                                type_specifier.type = void,
															    type_specifier.width = 0
                                                                type_specifier.ifStruct = false
                                                            }
->
INT
                                                            {
                                                                type_specifier.type = int,
															    type_specifier.width = 4
                                                                type_specifier.ifStruct = false
                                                            }
->
struct_or_union_specifier
                                                            {
															    type_specifier.width = struct_or_union_specifier.width
                                                                type_specifier.ifStruct = true
                                                                type_specifier.struct = struct_or_union_specifier.struct
                                                            }
;;


// 关于结构体里面的符号表的构建，因为不太懂符号表的东西，所以之前你写的有关符号表的动作我都没改
struct_or_union_specifier
->
                                                            {
                                                                struct_declaration_list.offset = 0;
                                                            }
STRUCT IDENTIFIER { struct_declaration_list }      
                                                            {
                                                                struct_or_union_specifier.width = struct_declaration_list.syn_offset

                                                                struct_or_union_specifier.ifStruct = true
                                                                struct_or_union_specifier.struct = newStruct( IDENTIFIER.morpheme, top )
                                                                // top是struct_declaration_list大括号域中的符号表
                                                                // 将( name = IDENTIFIER.morpheme, type = "struct", size = struct_or_union_specifier.width, offset = struct_or_union_specifier.offset )插入符号表
                                                                // t = top.get( IDENTIFIER.morpheme ).address 这里的t作为全局中该结构体的唯一标识成为该struct的名字
                                                                // 将结构体名字（t）、属性符号列表信息存入structTable中, 何部长说插入会直接返回structItem的引用，这里直接作为newStruct的返回值
                                                                struct_or_union_specifier.type = "struct " + struct_or_union_specifier.struct.name
                                                            }
->
                                                            {
                                                                struct_declaration_list.offset = 0;
                                                            }
STRUCT { struct_declaration_list }
                                                            {
                                                                struct_or_union_specifier.width = struct_declaration_list.syn_offset

                                                                struct_or_union_specifier.ifStruct = true
                                                                struct_or_union_specifier.struct = newStruct( "", top )
                                                                //与上面类似，在符号表中hbz会自动为这个结构体生成名字
                                                                struct_or_union_specifier.type = "struct " + struct_or_union_specifier.struct.name
                                                            }
->
STRUCT IDENTIFIER
                                                            {
                                                                struct_or_union_specifier.ifStruct = true
                                                                t = top.get( IDENTIFIER.morpheme ).addr
                                                                struct_or_union_specifier.struct = getStruct(t)
                                                                struct_or_union_specifier.type = "struct " + struct_or_union_specifier.struct.name
                                                                struct_or_union_specifier.width = top.get( IDENTIFIER.morpheme ).width
                                                            }
;;


struct_declaration_list
->
                                                            {
                                                                struct_declaration.offset = struct_declaration_list.offset
                                                            }
struct_declaration
                                                            {
                                                                struct_declaration_list.syn_offset = struct_declaration.syn_offset
                                                            }
->
                                                            {
                                                                struct_declaration_list1.offset = struct_declaration_list.offset
                                                            }
struct_declaration_list1
                                                            {
                                                                struct_declaration.offset = struct_declaration_list1.syn_offset
                                                            }
struct_declaration
                                                            {
                                                                struct_declaration_list.syn_offset = struct_declaration.syn_offset
                                                            }
;;

struct_declaration
->
type_specifier 
                                                            {
                                                                if (type_specifier.ifStruct) {
                                                                    报错 结构体不做嵌套
                                                                }
                                                                else {
                                                                    struct_declarator_list.offset = struct_declaration.offset
                                                                    struct_declarator_list.type = type_specifier.type
                                                                    struct_declarator_list.width = type_specifier.width
                                                                }
                                                            }
struct_declarator_list ;
                                                            {
                                                                struct_declaration.syn_offset = struct_declarator_list.syn_offset
                                                                struct_declaration.syn_type = struct_declarator_list.syn_type
                                                                struct_declaration.syn_width = struct_declarator_list.syn_width
                                                            }
;;


struct_declarator_list
->
                                                            {
                                                                declarator.offset = struct_declarator_list.offset
                                                                declarator.type = struct_declarator_list.type
                                                                declarator.width = struct_declarator_list.width
                                                            }
declarator
                                                            {
                                                                struct_declarator_list.syn_offset = declarator.syn_offset
                                                                struct_declarator_list.syn_type = declarator.syn_type
                                                                struct_declarator_list.syn_width = declarator.syn_width
                                                            }
->
                                                            {
                                                                struct_declarator_list1.offset = struct_declarator_list.offset
                                                                struct_declarator_list1.type = struct_declarator_list.type
                                                                struct_declarator_list1.width = struct_declarator_list.width
                                                            }
struct_declarator_list1 , 
                                                            {
                                                                declarator.offset = struct_declarator_list1.syn_offset
                                                                declarator.type = struct_declarator_list1.syn_type
                                                                declarator.width = struct_declarator_list1.syn_width
                                                            }
declarator
                                                            {
                                                                struct_declarator_list.syn_offset = declarator.syn_offset
                                                                struct_declarator_list.syn_type = declarator.syn_type
                                                                struct_declarator_list.syn_width = declarator.syn_width
                                                            }
;;


declarator
->
                                                            {
                                                                direct_declarator.type = declarator.type
                                                                direct_declarator.width = declarator.width
                                                            }
direct_declarator
                                                            {
                                                                declarator.syn_width = direct_declarator.syn_width
                                                                declarator.syn_type = direct_declarator.syn_type
                                                            }
;;


direct_declarator
->
IDENTIFIER                                                          
                                                            {
                                                                direct_declarator.lexeme = IDENTIFIER.lexeme,
                                                                direct_declarator.syn_type = direct_declarator.type,
                                                                direct_declarator.syn_width = direct_declarator.width
                                                            }
->
( direct_declarator1 )
                                                            {
                                                                direct_declarator.lexeme = direct_declarator1.lexeme,
                                                                direct_declarator.syn_type = direct_declarator1.syn_type,
                                                                direct_declarator.syn_width = direct_declarator1.syn_width
                                                            }
->                                            
IDENTIFIER [ assignment_expression ]
                                                            {
                                                                direct_declarator.syn_type = array(assignment_expression.value, direct_declarator.type),
                                                                direct_declarator.syn_width = direct_declarator.width * assignment_expression.value
                                                            }

->
                                                            {
                                                                direct_declarator1.type = direct_declarator.type
                                                            }
direct_declarator1
                                                            {
                                                                hbst::SymbolItem tem
                                                                try {
                                                                    tem = top.get(direct_declarator1.addr)
                                                                }
                                                                catch (std::string s) {
                                                                    hbst::SymbolItem b(direct_declarator1.lexeme, "function", 0, 0)
                                                                    top.put_symbol(b)
                                                                    tem = b
                                                                }
                                                                hbst::FuntionItem fun = (tem.name, direct_declarator1.typr)
                                                                function_table.put_function(fun)
                                                                parameter_list.function_name = tem.name
                                                            }
( parameter_list )
->
                                                            {
                                                                direct_declarator1.type = direct_declarator.type
                                                            }
direct_declarator1 ( )
                                                            {
                                                                hbst::SymbolItem tem
                                                                try {
                                                                    tem = top.get(direct_declarator1.addr)
                                                                }
                                                                catch (std::string s) {
                                                                    hbst::SymbolItem b(direct_declarator1.lexeme, "function", 0, 0)
                                                                    top.put_symbol(b)
                                                                    tem = b
                                                                }
                                                                hbst::FuntionItem fun = (tem.name, direct_declarator1.typr)
                                                                function_table.put_function(fun)
                                                            }
;;



parameter_list
->
parameter_declaration
                                                            {
                                                                function_table.get_function(parameter_list.function_name).add_parameter(parameter_declaration.type)
                                                                var_width_list.push_back(parameter_declaration.width)
                                                                var_name_list.push_back(parameter_declaration.name)
                                                            }
->
parameter_list1 , parameter_declaration
                                                            {
                                                                function_table.get_function(parameter_list.function_name).add_parameter(parameter_declaration.type)
                                                                var_width_list.push_back(parameter_declaration.width)
                                                                var_name_list.push_back(parameter_declaration.name)
                                                            }
;;



parameter_declaration
->
type_specifier declarator
                                                            {
                                                                parameter_declaration.type = type_specifier.type
                                                                parameter_declaration.width = type_specifier.width
                                                                parameter_declaration.name = declarator.lexeme
                                                            }
->
type_specifier
                                                            {
                                                                parameter_declaration.type = type_specifier.type
                                                                parameter_declaration.width = type_specifier.width
                                                                parameter_declaration.name = ""
                                                            }
;;


type_name
->
type_specifier
                                                            {
                                                                type_name.type = type_specifier.type
                                                            }
;;


initializer
->
assignment_expression
                                                            {
                                                                initializer.addr = assignment_expression.addr
                                                                initializer.type = assignment_expression.type
                                                            }
->
{ initializer_list }
                                                            {
                                                                initializer.list = initializer_list.list
                                                                initializer.type = "int[" + to_string(initializer_list.list.size()) + "]"
                                                            }
->
{ initializer_list , }
;;

initializer_list
->
assignment_expression
                                                            {
                                                                initializer_list.list.push_back(assignment_expression.addr)
                                                                if (assignment_expression.type != "int") {
                                                                    报错 // 
                                                                }
                                                            }
->
initializer_list1 , assignment_expression
                                                            {
                                                                initializer_list.list = initializer_list1.list
                                                                initializer_list.list.push_back(assignment_expression.addr)
                                                                if (assignment_expression.type != "int") {
                                                                    报错 // 
                                                                }
                                                            }
;;



statement //nothing to do
->
compound_statement
->
expression_statement
->
selection_statement
->
iteration_statement
->
                                                            {
                                                                jump_statement.con_dest = statement.con_dest
                                                                jump_statement.break_dest = statement.break_dest
                                                            }
jump_statement                                                          
;;



compound_statement
->
{ }
->
{
                                                            {
                                                                建符号表
                                                            }
statement_list }
->
{
                                                            {
                                                                建符号表
                                                            }
declaration_list }
->
{
                                                            {
                                                                建符号表
                                                            }
declaration_list statement_list }
;;


function_compound_statement // TODO 将参数加入函数作用域的符号表
->
{ }
->
{
                                                            {
                                                                cur_func_name = function_compound_statement.lexeme
                                                                gen("FUNC", function_compound_statement.lexeme, '-', '-')
                                                                建符号表
                                                                vector types = function_table.get_function(function_compound_statement.lexeme).parameter_vector
                                                                for (int i = 0; i < var_name_list.size; i++) {
                                                                    top.put_symbol(hbst::SymbolItem(var_name_list[i], types[i], 0, var_width_list[i]))
                                                                }
                                                            } 
statement_list
                                                            {
                                                                gen("ENDF", function_compound_statement.lexeme, '-', '-')
                                                            }
}
->
{
                                                            {
                                                                cur_func_name = function_compound_statement.lexeme
                                                                gen("FUNC", function_compound_statement.lexeme, '-', '-')
                                                                建符号表
                                                                vector types = function_table.get_function(function_compound_statement.lexeme).parameter_vector
                                                                for (int i = 0; i < var_name_list.size; i++) {
                                                                    top.put_symbol(hbst::SymbolItem(var_name_list[i], types[i], 0, var_width_list[i]))
                                                                }
                                                            }
declaration_list
                                                            {
                                                                gen("ENDF", function_compound_statement.lexeme, '-', '-')
                                                            }
}
->
{
                                                            {
                                                                cur_func_name = function_compound_statement.lexeme
                                                                gen("FUNC", function_compound_statement.lexeme, '-', '-')
                                                                建符号表
                                                                vector types = function_table.get_function(function_compound_statement.lexeme).parameter_vector
                                                                for (int i = 0; i < var_name_list.size; i++) {
                                                                    top.put_symbol(hbst::SymbolItem(var_name_list[i], types[i], 0, var_width_list[i]))
                                                                }
                                                            }
declaration_list statement_list 
                                                            {
                                                                gen("ENDF", function_compound_statement.lexeme, '-', '-')
                                                            }
}
;;


declaration_list //nothing to do
->
declaration                                                 
->
declaration_list1 declaration
;;



statement_list // nothing to do
statement
statement_list statement
;;



expression_statement //nothing to do
;
expression ;
;;



selection_statement
->
IF  ( expression 
                                                            {
/////////////////////////////////////////////////////////// start /////////////////////////////////////////////////////////////////////
                                                                if(expression.type != "int"){
                                                                    报错 类型不匹配
                                                                }
///////////////////////////////////////////////////////////  end  /////////////////////////////////////////////////////////////////////
                                                                expression.true = _
                                                                expression.false = _
                                                            }
    )
                                                            {
                                                                statement.instr = newInstr();
                                                                    backpatch(expression.true, statement.instr)
                                                            } 
    statement
                                                            {
                                                            
                                                                statement.next = newInstr();
                                                                backpatch(expression.false, statement.next)
                                                                backpatch(selection_statement.next, statement.next)
                                                            }
->
IF ( expression ) 
                                                            {
/////////////////////////////////////////////////////////// start /////////////////////////////////////////////////////////////////////
                                                                if(expression.type != "int"){
                                                                    报错 类型不匹配
                                                                }
///////////////////////////////////////////////////////////  end  /////////////////////////////////////////////////////////////////////
                                                                statement1.instr = newInstr();
                                                                backpatch(expression.true, statement1.instr)
                                                            } 
statement1 
                                                            {
                                                                
                                                                statement1.next = _
                                                            }
ELSE 
                                                            {
                                                                statement2.instr = newInstr();
                                                                    backpatch(expression.false, statement2.instr)
                                                            } 
statement2
                                                            {
                                                                
                                                                statement2.next = newInstr
                                                                backpatch(statement1.next, statement2.next)
                                                                backpatch(selection_statement.next, statement2.next)
                                                            }
->
SWITCH ( expression ) 
                                                            {
                                                                statement.preValue = expression.value
                                                                statement.break_dest = _
                                                            }
statement

                                                            {
                                                                temp_label = newInstr
                                                                backpatch(statement.break_dest, temp_label)
                                                            }
;;



iteration_statement
->
WHILE ( 
                                                            {
                                                                expression.instr = newInstr
                                                            }
expression 
                                                            {
/////////////////////////////////////////////////////////// start /////////////////////////////////////////////////////////////////////
                                                                if(expression.type != "int"){
                                                                    报错 类型不匹配
                                                                }
///////////////////////////////////////////////////////////  end  /////////////////////////////////////////////////////////////////////
                                                                expression.true = 
                                                                expression.false = 
                                                            }
) 
                                                            {
                                                                statement.instr = newInstr
                                                                backpatch(expression.true, statement.instr)
                                                                statement.con_dest = expression_statement2.instr
                                                                statement.break_dest = _
                                                            }
statement
                                                            {
                                                                statement.next = _
                                                                backpatch(statement.next, expression.instr)
                                                                temp_label = newInstr
                                                                backpatch(expression.false, temp_label)
                                                                backpatch(statement.break_dest, temp_label)
                                                            }
->
FOR ( expression_statement1
                                                            {
                                                                expression_statement2.instr = newInstr
                                                            }
expression_statement2
                                                            {
                                                                expression_statement2.true = _
                                                                expression_statement2.false = _
                                                            }
)
                                                            {
                                                                statement.instr = newInstr
                                                                backpatch(expression_statement2.true, statement.instr)
                                                                statement.con_dest = expression_statement2.instr
                                                                statement.break_dest = _                                                                    
                                                            }
statement
                                                            {
                                                                statement.next = _
                                                                backpatch(statement.next, expression_statement2.instr)
                                                                temp_label = newInstr
                                                                backpatch(statement2.false, temp_label)
                                                                backpatch(statement.break_dest, temp_label)
                                                            }
->
FOR ( expression_statement1 
                                                            {
                                                                expression_statement2.instr = newInstr
                                                            }
expression_statement2 
                                                            {
                                                                expression_statement2.true = _
                                                                expression_statement2.false = _
                                                                expression.instr = newInstr
                                                            }
expression
                                                            {
                                                                expression.next = _
                                                                backpatch(expression.next, expression_statement2.instr)
                                                            }
) 
                                                            {
                                                                statement.instr = newInstr
                                                                backpatch(expression_statement2.true, statement.instr)
                                                                statement.con_dest = expression_statement2.instr
                                                                statement.break_dest = _

                                                            }
statement
                                                            {
                                                                statement.next = _
                                                                backpatch(statement.next, expression.instr)
                                                                temp_label = newInstr
                                                                backpatch(statement2.false, temp_label)
                                                                backpatch(statement.break_dest, temp_label)
                                                            }
;;



jump_statement
->
CONTINUE ;
                                                            {
                                                                continue.next = jump_statement.con_dest
                                                            }     
->
BREAK ;
                                                            {
                                                                break.next = jump_statement.break_dest
                                                            }
->
RETURN ;
                                                            {
                                                                gen("RET", ---)
                                                            }
->
RETURN expression ;
                                                            {
                                                                if(expression.type != function_table.get_function(cur_func_name).return_type){ //expression.type 要查表
                                                                    报错 //返回值类型错误
                                                                }
                                                                gen("RET", expression.addr, --)
                                                            }
;;


translation_unit // nothing to do
external_declaration
translation_unit external_declaration
;;



external_declaration // nothing to do
function_definition
declaration
;;


argumented_translation_unit // nothing to do
translation_unit
;;


function_definition
->
type_specifier
                                                            {
                                                                declarator.type = type_specifier.type
                                                            }
direct_declarator
                                                            {
                                                                function_compound_statement.var_name_list = direct_declarator.var_name_list
                                                                function_compound_statement.lexeme = direct_declarator.lexeme
                                                            }
function_compound_statement
;;

